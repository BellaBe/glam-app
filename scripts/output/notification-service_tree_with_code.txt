================================================================================
Directory Structure: /home/bellabe/glam-app/services/notification-service
================================================================================

notification-service/
alembic/
├── versions/
├── alembic.ini
│   
│   ```ini
│   [alembic]
│   script_location = alembic
│   prepend_sys_path = .
│   version_path_separator = os
│   sqlalchemy.url = postgresql+asyncpg://%(DB_USER)s:%(DB_PASSWORD)s@%(DB_HOST)s:%(DB_PORT)s/%(DB_NAME)s
│   
│   [post_write_hooks]
│   hooks = black
│   black.type = console_scripts
│   black.entrypoint = black
│   black.options = -l 100
│   
│   [loggers]
│   keys = root,sqlalchemy,alembic
│   
│   [handlers]
│   keys = console
│   
│   [formatters]
│   keys = generic
│   
│   [logger_root]
│   level = WARN
│   handlers = console
│   qualname =
│   
│   [logger_sqlalchemy]
│   level = WARN
│   handlers =
│   qualname = sqlalchemy.engine
│   
│   [logger_alembic]
│   level = INFO
│   handlers =
│   qualname = alembic
│   
│   [handler_console]
│   class = StreamHandler
│   args = (sys.stderr,)
│   level = NOTSET
│   formatter = generic
│   
│   [formatter_generic]
│   format = %(levelname)-5.5s [%(name)s] %(message)s
│   datefmt = %H:%M:%S
│   ```
│   
└── env.py
logs/
migrations/
└── env.py
    
    ```py
    # services/notification-service/src/migrations/env.py
    from logging.config import fileConfig
    from sqlalchemy import engine_from_config
    from sqlalchemy import pool
    from alembic import context
    import os
    import sys
    from pathlib import Path
    
    # Add parent directory to path
    sys.path.append(str(Path(__file__).parent.parent.parent))
    
    # Import models and database config
    from shared.database.base import Base
    from src.models.database import *  # noqa - Import all models
    from shared.database.config import DatabaseConfig
    
    # this is the Alembic Config object
    config = context.config
    
    # Interpret the config file for logging
    if config.config_file_name is not None:
        fileConfig(config.config_file_name)
    
    # Get database URL from environment
    db_config = DatabaseConfig()
    config.set_main_option("sqlalchemy.url", db_config.sync_database_url)
    
    # Add your model's MetaData object here for 'autogenerate' support
    target_metadata = Base.metadata
    
    
    def run_migrations_offline() -> None:
        """Run migrations in 'offline' mode."""
        url = config.get_main_option("sqlalchemy.url")
        context.configure(
            url=url,
            target_metadata=target_metadata,
            literal_binds=True,
            dialect_opts={"paramstyle": "named"},
        )
    
        with context.begin_transaction():
            context.run_migrations()
    
    
    def run_migrations_online() -> None:
        """Run migrations in 'online' mode."""
        connectable = engine_from_config(
            config.get_section(config.config_ini_section),
            prefix="sqlalchemy.",
            poolclass=pool.NullPool,
        )
    
        with connectable.connect() as connection:
            context.configure(
                connection=connection, target_metadata=target_metadata
            )
    
            with context.begin_transaction():
                context.run_migrations()
    
    
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        run_migrations_online()
    ```
    
src/
├── constants/
│   ├── __init__.py
│   └── notification_types.py
│       
│       ```py
│       from enum import Enum
│       
│       class NotificationType(str, Enum):
│           """Notification type constants"""
│           # System notifications
│           WELCOME = "welcome"
│           REGISTRATION_FINISH = "registration_finish"
│           REGISTRATION_SYNC = "registration_sync"
│           
│           # Billing notifications
│           BILLING_EXPIRED = "billing_expired"
│           BILLING_CHANGED = "billing_changed"
│           BILLING_LOW_CREDITS = "billing_low_credits"
│           BILLING_ZERO_BALANCE = "billing_zero_balance"
│           BILLING_DEACTIVATED = "billing_deactivated"
│           
│           # Custom notifications
│           MARKETING = "marketing"
│           ANNOUNCEMENT = "announcement"
│           CUSTOM = "custom"
│       
│       # Default templates for each type
│       DEFAULT_TEMPLATES = {
│           NotificationType.WELCOME: {
│               "subject": "Welcome to GlamYouUp, {{ shop_name }}!",
│               "required_vars": ["shop_name"],
│               "optional_vars": ["features", "product_count"]
│           },
│           NotificationType.REGISTRATION_FINISH: {
│               "subject": "Product Registration Complete - {{ product_count }} products registered",
│               "required_vars": ["product_count"],
│               "optional_vars": []
│           },
│           NotificationType.REGISTRATION_SYNC: {
│               "subject": "Product Sync Results",
│               "required_vars": ["added_count", "updated_count"],
│               "optional_vars": ["removed_count"]
│           },
│           NotificationType.BILLING_EXPIRED: {
│               "subject": "Your {{ plan_name }} subscription has expired",
│               "required_vars": ["plan_name", "renewal_link"],
│               "optional_vars": []
│           },
│           NotificationType.BILLING_CHANGED: {
│               "subject": "Plan changed to {{ plan_name }}",
│               "required_vars": ["plan_name"],
│               "optional_vars": ["previous_plan"]
│           },
│           NotificationType.BILLING_LOW_CREDITS: {
│               "subject": "Low credit balance warning",
│               "required_vars": ["current_balance", "days_remaining", "expected_depletion_date", "billing_link"],
│               "optional_vars": []
│           },
│           NotificationType.BILLING_ZERO_BALANCE: {
│               "subject": "Zero balance - Features will be deactivated",
│               "required_vars": ["deactivation_time", "billing_link"],
│               "optional_vars": []
│           },
│           NotificationType.BILLING_DEACTIVATED: {
│               "subject": "Features deactivated due to {{ reason }}",
│               "required_vars": ["reason", "reactivation_link"],
│               "optional_vars": []
│           }
│       }
│       ```
│       
├── events/
│   ├── __init__.py
│   ├── publishers.py
│   │   
│   │   ```py
│   │   # services/notification-service/src/events/publishers.py
│   │   from shared.events import (
│   │       Streams,
│   │       DomainEventPublisher,
│   │       EventContextManager,
│   │       EventContext,
│   │   )
│   │   from shared.events.base_publisher import DomainEventPublisher
│   │   from shared.events.notification.types import (
│   │       NotificationEvents,
│   │       EmailSentEventPayload,
│   │       EmailFailedEventPayload,
│   │       BulkCompletedEventPayload,
│   │   )
│   │   from typing import Optional, Dict, Any
│   │   from uuid import UUID
│   │   from datetime import datetime, timezone
│   │   
│   │   
│   │   class NotificationEventPublisher(DomainEventPublisher):
│   │       """Publisher for notification service events with standardized context"""
│   │   
│   │       domain_stream = Streams.NOTIFICATION
│   │       service_name_override = "notification-service"
│   │   
│   │       def __init__(self, client, js, logger=None):
│   │           super().__init__(client, js, logger)
│   │           self.context_manager = EventContextManager(logger or self.logger)
│   │   
│   │       async def publish_email_sent(
│   │           self,
│   │           notification_id: UUID,
│   │           merchant_id: UUID,
│   │           notification_type: str,
│   │           provider: str,
│   │           provider_message_id: str,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │           original_event_id: Optional[str] = None,
│   │       ) -> str:
│   │           """Publish email sent event with typed payload and context"""
│   │           # Create event context
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=NotificationEvents.NOTIFICATION_EMAIL_SENT,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override or "default-service-name",
│   │               metadata={
│   │                   **(metadata or {}),
│   │                   "notification_id": str(notification_id),
│   │                   "triggered_by": original_event_id,
│   │               },
│   │           )
│   │   
│   │           # Create typed payload
│   │           payload = EmailSentEventPayload(
│   │               notification_id=notification_id,
│   │               merchant_id=merchant_id,
│   │               notification_type=notification_type,
│   │               provider=provider,
│   │               provider_message_id=provider_message_id,
│   │               sent_at=datetime.now(timezone.utc),
│   │               metadata=metadata or {},
│   │           )
│   │   
│   │           # Log event publication
│   │           self.logger.info(f"Publishing {context.event_type}", extra=context.to_dict())
│   │   
│   │           return await self.publish_event_response(
│   │               NotificationEvents.NOTIFICATION_EMAIL_SENT,
│   │               payload.model_dump(),
│   │               correlation_id=correlation_id,
│   │               metadata=context.metadata,
│   │           )
│   │   
│   │       async def publish_email_failed(
│   │           self,
│   │           notification_id: UUID,
│   │           merchant_id: UUID,
│   │           notification_type: str,
│   │           error: str,
│   │           error_code: str,
│   │           retry_count: int,
│   │           will_retry: bool,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │           original_event_id: Optional[str] = None,
│   │       ) -> str:
│   │           """Publish email failed event with typed payload and context"""
│   │           # Create event context
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=NotificationEvents.NOTIFICATION_EMAIL_FAILED,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override or "default-service-name",
│   │               metadata={
│   │                   **(metadata or {}),
│   │                   "notification_id": str(notification_id),
│   │                   "triggered_by": original_event_id,
│   │                   "will_retry": will_retry,
│   │               },
│   │           )
│   │   
│   │           # Create typed payload
│   │           payload = EmailFailedEventPayload(
│   │               notification_id=notification_id,
│   │               merchant_id=merchant_id,
│   │               notification_type=notification_type,
│   │               error=error,
│   │               error_code=error_code,
│   │               retry_count=retry_count,
│   │               will_retry=will_retry,
│   │               failed_at=datetime.now(timezone.utc),
│   │           )
│   │   
│   │           # Log event publication
│   │           self.logger.warning(
│   │               f"Publishing {context.event_type}",
│   │               extra={**context.to_dict(), "error": error, "error_code": error_code},
│   │           )
│   │   
│   │           return await self.publish_event_response(
│   │               NotificationEvents.NOTIFICATION_EMAIL_FAILED,
│   │               payload.model_dump(),
│   │               correlation_id=correlation_id,
│   │               metadata=context.metadata,
│   │           )
│   │   
│   │       async def publish_bulk_completed(
│   │           self,
│   │           bulk_job_id: UUID,
│   │           notification_type: str,
│   │           total_recipients: int,
│   │           total_sent: int,
│   │           total_failed: int,
│   │           total_skipped: int,
│   │           duration_seconds: float,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │           original_event_id: Optional[str] = None,
│   │       ) -> str:
│   │           """Publish bulk send completed event with context"""
│   │           # Create event context
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=NotificationEvents.NOTIFICATION_BULK_SEND_COMPLETED,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override or "default-service-name",
│   │               idempotency_key=str(bulk_job_id),  # Use bulk job ID for idempotency
│   │               metadata={
│   │                   **(metadata or {}),
│   │                   "bulk_job_id": str(bulk_job_id),
│   │                   "triggered_by": original_event_id,
│   │                   "success_rate": (
│   │                       total_sent / total_recipients if total_recipients else 0
│   │                   ),
│   │               },
│   │           )
│   │   
│   │           # Create typed payload
│   │           payload = BulkCompletedEventPayload(
│   │               bulk_job_id=bulk_job_id,
│   │               notification_type=notification_type,
│   │               total_recipients=total_recipients,
│   │               total_sent=total_sent,
│   │               total_failed=total_failed,
│   │               total_skipped=total_skipped,
│   │               duration_seconds=duration_seconds,
│   │               completed_at=datetime.now(timezone.utc),
│   │           )
│   │   
│   │           # Log event publication
│   │           self.logger.info(
│   │               f"Publishing {context.event_type}",
│   │               extra={
│   │                   **context.to_dict(),
│   │                   "total_sent": total_sent,
│   │                   "total_failed": total_failed,
│   │                   "duration_seconds": duration_seconds,
│   │               },
│   │           )
│   │   
│   │           return await self.publish_event_response(
│   │               NotificationEvents.NOTIFICATION_BULK_SEND_COMPLETED,
│   │               payload.model_dump(),
│   │               correlation_id=correlation_id,
│   │               metadata=context.metadata,
│   │           )
│   │   
│   │   
│   │   def get_publishers():
│   │       """Get all publishers for this service"""
│   │       return [NotificationEventPublisher]
│   │   ```
│   │   
│   └── subscribers.py
│       
│       ```py
│       # services/notification-service/src/events/subscribers.py
│       """Notification Service event subscribers"""
│       
│       from shared.events.base_subscriber import DomainEventSubscriber
│       from shared.events.notification.types import NotificationCommands, SendEmailCommandPayload, SendEmailBulkCommandPayload
│       
│       class SendEmailSubscriber(DomainEventSubscriber):
│           """Single email send subscriber"""
│           
│           @property
│           def event_type(self) -> str:
│               return NotificationCommands.NOTIFICATION_SEND_EMAIL  # ✅ Correct override
│       
│           @property
│           def subject(self) -> str:
│               return NotificationCommands.NOTIFICATION_SEND_EMAIL
│           @property
│           def durable_name(self) -> str:
│               return "notification-send-email"
│       
│           async def on_event(self, event: dict, headers=None):
│               # Type-safe dependency access - IDE autocompletes valid keys
│               notification_service = self.get_dependency("notification_service")
│               
│               payload = SendEmailCommandPayload(**event["payload"])
│               await notification_service.process_send_email_command(payload)
│       
│       class SendBulkEmailSubscriber(DomainEventSubscriber):
│           """Bulk email send subscriber"""
│       
│           @property
│           def event_type(self)-> str:
│               return NotificationCommands.NOTIFICATION_SEND_BULK
│           
│           @property
│           def subject(self) -> str:
│               return NotificationCommands.NOTIFICATION_SEND_BULK
│           
│           @property
│           def durable_name(self) -> str:
│               return "notification-send-bulk"
│           
│           async def on_event(self, event: dict, headers=None):
│               notification_service = self.get_dependency("notification_service")
│               
│               payload = SendEmailBulkCommandPayload(**event["payload"])
│               await notification_service.process_bulk_email_command(payload)
│       ```
│       
├── mappers/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # File: services/notification-service/src/mappers/__init__.py
│   │   
│   │   """Mappers for converting between schemas and models."""
│   │   
│   │   from .notification_mapper import NotificationMapper
│   │   
│   │   __all__ = [
│   │       "NotificationMapper",
│   │   ]
│   │   ```
│   │   
│   └── notification_mapper.py
│       
│       ```py
│       # services/notification-service/src/mappers/notification_mapper.py
│       """Mapper for notification schemas and models."""
│       
│       from typing import Dict, Any, Optional
│       from uuid import UUID
│       
│       from shared.api.correlation import get_correlation_context
│       from ..models import Notification, NotificationStatus, NotificationProvider
│       from ..schemas import (
│           NotificationCreate,
│           NotificationUpdate,
│           NotificationResponse
│       )
│       from shared.mappers.base import BaseMapper
│       
│       
│       class NotificationMapper(
│           BaseMapper[
│               Notification, NotificationCreate, NotificationUpdate, NotificationResponse
│           ]
│       ):
│           """Maps between notification schemas and models."""
│       
│           def create_to_model(
│               self,
│               create_schema: NotificationCreate,
│               subject: str,
│               content: str,
│               provider: NotificationProvider = NotificationProvider.SENDGRID,
│               unsubscribe_token: Optional[str] = None,
│           ) -> Notification:
│               """
│               Map NotificationCreate schema to Notification model.
│       
│               Args:
│                   create_schema: The create request schema
│                   subject: Rendered email subject
│                   content: Rendered email content (HTML)
│                   provider: Email service provider
│                   unsubscribe_token: Token for unsubscribe link
│       
│               Returns:
│                   Notification model instance
│               """
│               # Build metadata
│               metadata = self._build_metadata(
│                   create_schema=create_schema, unsubscribe_token=unsubscribe_token
│               )
│       
│               return Notification(
│                   merchant_id=create_schema.merchant_id,
│                   merchant_domain=create_schema.merchant_domain,
│                   recipient_email=create_schema.shop_email,
│                   type=create_schema.notification_type,
│                   subject=subject,
│                   content=content,
│                   status=NotificationStatus.PENDING,
│                   provider=provider,
│                   extra_metadata=metadata,
│                   retry_count=0,
│               )
│       
│           def model_to_response(self, model: Notification) -> NotificationResponse:
│               """Convert Notification model to response schema."""
│               return NotificationResponse(
│                   id=model.id,
│                   merchant_id=model.merchant_id,
│                   merchant_domain=model.merchant_domain,
│                   shop_email=model.recipient_email,
│                   type=model.type,
│                   status=model.status,
│                   sent_at=model.sent_at,
│                   created_at=model.created_at,
│                   updated_at=model.updated_at,
│               )
│       
│           def _build_metadata(
│               self, create_schema: NotificationCreate, unsubscribe_token: Optional[str] = None
│           ) -> Dict[str, Any]:
│               """Build metadata dictionary from various sources."""
│               metadata = {"dynamic_content": create_schema.dynamic_content}
│       
│               # Add correlation ID from context
│               correlation_id = get_correlation_context()
│               if correlation_id:
│                   metadata["correlation_id"] = {"correlation_id": correlation_id}
│       
│               # Add unsubscribe token if provided
│               if unsubscribe_token:
│                   metadata["unsubscribe_token"] = {"unsubscribe_token": unsubscribe_token}
│       
│               # Merge extra metadata from request
│               if create_schema.extra_metadata:
│                   metadata.update(create_schema.extra_metadata)
│       
│               return metadata
│       ```
│       
├── models/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # File: services/notification-service/src/models/__init__.py
│   │   
│   │   """Database models for notification service."""
│   │   
│   │   from shared.database.base import Base, TimestampedMixin
│   │   from .notification import Notification, NotificationStatus, NotificationProvider
│   │   from .template import NotificationTemplate, NotificationTemplateHistory, ChangeType
│   │   
│   │   __all__ = [
│   │       # Base (from shared)
│   │       "Base",
│   │       "TimestampedMixin",
│   │   
│   │       
│   │       # Notification
│   │       "Notification",
│   │       "NotificationStatus",
│   │       "NotificationProvider",
│   │       
│   │       # Template
│   │       "NotificationTemplate",
│   │       "NotificationTemplateHistory",
│   │       "ChangeType",
│   │   ]
│   │   ```
│   │   
│   ├── notification.py
│   │   
│   │   ```py
│   │   # File: services/notification-service/src/models/notification.py
│   │   
│   │   """Notification model and related enums."""
│   │   
│   │   import enum
│   │   from datetime import datetime
│   │   from typing import Optional, Dict, Any
│   │   from uuid import UUID, uuid4
│   │   from sqlalchemy import String, Text, Integer, DateTime, Enum, Index, func
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   from sqlalchemy.dialects.postgresql import UUID as PGUUID, JSONB
│   │   from shared.database.base import MerchantMixin, Base, TimestampedMixin
│   │   
│   │   
│   │   class NotificationStatus(str, enum.Enum):
│   │       """Notification delivery status."""
│   │       PENDING = "pending"
│   │       SENT = "sent"
│   │       FAILED = "failed"
│   │       BOUNCED = "bounced"
│   │       DELIVERED = "delivered"
│   │       OPENED = "opened"
│   │       CLICKED = "clicked"
│   │   
│   │   
│   │   class NotificationProvider(str, enum.Enum):
│   │       """Email service providers."""
│   │       SENDGRID = "sendgrid"
│   │       MAILGUN = "mailgun"
│   │       AWS_SES = "aws_ses"
│   │       SMTP = "smtp"
│   │   
│   │   
│   │   class Notification(Base, TimestampedMixin, MerchantMixin):
│   │       """
│   │       Primary table for tracking all email notifications.
│   │       
│   │       Stores all sent and pending notifications with their status,
│   │       content, and delivery information.
│   │       """
│   │       __tablename__ = "notifications"
│   │       
│   │       # Primary key
│   │       id: Mapped[UUID] = mapped_column(
│   │           PGUUID(as_uuid=True),
│   │           primary_key=True,
│   │           default=uuid4
│   │       )
│   │       
│   │       # Recipient and type
│   │       recipient_email: Mapped[str] = mapped_column(String(255), nullable=False)
│   │       type: Mapped[str] = mapped_column(String(50), nullable=False, index=True)
│   │       
│   │       # Template reference (optional)
│   │       template_type: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, index=True)
│   │       
│   │       # Email content
│   │       subject: Mapped[str] = mapped_column(String(255), nullable=False)
│   │       content: Mapped[str] = mapped_column(Text, nullable=False)
│   │       
│   │       # Delivery status
│   │       status: Mapped[NotificationStatus] = mapped_column(
│   │           Enum(NotificationStatus),
│   │           nullable=False,
│   │           default=NotificationStatus.PENDING,
│   │           index=True
│   │       )
│   │       
│   │       # Provider information
│   │       provider: Mapped[Optional[NotificationProvider]] = mapped_column(
│   │           Enum(NotificationProvider),
│   │           nullable=True
│   │       )
│   │       provider_message_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
│   │       
│   │       # Error handling
│   │       error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
│   │       retry_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
│   │       
│   │       # Timestamps
│   │       sent_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │       
│   │       # Additional data
│   │       extra_metadata: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
│   │       
│   │       # Indexes
│   │       __table_args__ = (
│   │           Index('idx_notifications_created_at', 'created_at'),
│   │           Index('idx_notifications_merchant_status', 'merchant_id', 'status'),
│   │           Index('idx_notifications_email_type', 'recipient_email', 'type'),
│   │       )
│   │       
│   │       def __repr__(self):
│   │           return f"<Notification(id={self.id}, type={self.type}, status={self.status})>"
│   │   ```
│   │   
│   └── template.py
│       
│       ```py
│       # File: services/notification-service/src/models/template.py
│       
│       """Notification template models."""
│       
│       import enum
│       from datetime import datetime
│       from typing import Optional, Dict, List
│       from sqlalchemy import String, Text, Boolean, Integer, ForeignKey, UniqueConstraint, Index, func, Enum, DateTime
│       from sqlalchemy.orm import Mapped, mapped_column, relationship
│       from sqlalchemy.dialects.postgresql import UUID, JSONB
│       from shared.database.base import Base, TimestampedMixin
│       
│       
│       class ChangeType(str,enum.Enum):
│           """Type of template change."""
│           CREATE = "create"
│           UPDATE = "update"
│           DELETE = "delete"
│           ACTIVATE = "activate"
│           DEACTIVATE = "deactivate"
│       
│       
│       class NotificationTemplate(Base, TimestampedMixin):
│           """
│           Email templates with variable placeholders.
│           
│           Stores reusable templates for different notification types
│           with Jinja2-style variable substitution.
│           """
│           __tablename__ = "notification_templates"
│           
│           # Primary key
│           id: Mapped[UUID] = mapped_column(
│               UUID(as_uuid=True),
│               primary_key=True,
│               server_default=func.gen_random_uuid()
│           )
│           
│           # Template identification
│           name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False, index=True)
│           type: Mapped[str] = mapped_column(String(50), nullable=False, index=True)
│           
│           # Template content
│           subject_template: Mapped[str] = mapped_column(String(255), nullable=False)
│           body_template: Mapped[str] = mapped_column(Text, nullable=False)
│           
│           # Template variables
│           variables: Mapped[Dict[str, List[str]]] = mapped_column(
│               JSONB,
│               nullable=False,
│               default={"required": [], "optional": []},
│               comment="JSON object with 'required' and 'optional' arrays of variable names"
│           )
│           
│           # Metadata
│           description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
│           is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False, index=True)
│           created_by: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
│           
│           # Relationships
│           history: Mapped[List["NotificationTemplateHistory"]] = relationship(
│               back_populates="template",
│               cascade="all, delete-orphan"
│           )
│           
│           def __repr__(self):
│               return f"<NotificationTemplate(name={self.name}, type={self.type})>"
│       
│       
│       class NotificationTemplateHistory(Base):
│           """
│           Audit trail for template changes.
│           
│           Tracks all modifications to notification templates for
│           compliance and debugging purposes.
│           """
│           __tablename__ = "notification_template_history"
│           
│           # Primary key
│           id: Mapped[UUID] = mapped_column(
│               UUID(as_uuid=True),
│               primary_key=True,
│               server_default=func.gen_random_uuid()
│           )
│           
│           # Template reference
│           template_id: Mapped[UUID] = mapped_column(
│               UUID(as_uuid=True),
│               ForeignKey("notification_templates.id"),
│               nullable=False,
│               index=True
│           )
│           
│           # Version tracking
│           version: Mapped[int] = mapped_column(Integer, nullable=False)
│           
│           # Historical data (snapshot at time of change)
│           name: Mapped[str] = mapped_column(String(100), nullable=False)
│           type: Mapped[str] = mapped_column(String(50), nullable=False)
│           subject_template: Mapped[str] = mapped_column(String(255), nullable=False)
│           body_template: Mapped[str] = mapped_column(Text, nullable=False)
│           variables: Mapped[Dict[str, List[str]]] = mapped_column(JSONB, nullable=False)
│           description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
│           
│           # Change metadata
│           changed_by: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
│           change_type: Mapped[ChangeType] = mapped_column(Enum(ChangeType), nullable=False)
│           created_at: Mapped[datetime] = mapped_column(
│               DateTime(timezone=True),
│               server_default=func.current_timestamp(),
│               nullable=False
│           )
│           
│           # Relationships
│           template: Mapped["NotificationTemplate"] = relationship(back_populates="history")
│           
│           # Constraints and indexes
│           __table_args__ = (
│               UniqueConstraint('template_id', 'version', name='uq_template_version'),
│               Index('idx_template_history_version', 'template_id', 'version'),
│           )
│           
│           def __repr__(self):
│               return f"<TemplateHistory(template_id={self.template_id}, version={self.version})>"
│       ```
│       
├── providers/
│   ├── __init__.py
│   ├── base.py
│   │   
│   │   ```py
│   │   from abc import ABC, abstractmethod
│   │   from typing import Dict, Any, Optional, List
│   │   from dataclasses import dataclass
│   │   from src.models import NotificationProvider
│   │   
│   │   @dataclass
│   │   class EmailMessage:
│   │       """Email message structure"""
│   │       to_email: str
│   │       subject: str
│   │       html_body: str
│   │       text_body: Optional[str] = None
│   │   
│   │   @dataclass
│   │   class EmailResult:
│   │       """Email send result"""
│   │       success: bool
│   │       provider: NotificationProvider
│   │       provider_message_id: Optional[str] = None
│   │       error_message: Optional[str] = None
│   │       error_code: Optional[str] = None
│   │   
│   │   class EmailProvider(ABC):
│   │       """Base email provider interface"""
│   │       
│   │       def __init__(self, config: Dict[str, Any]):
│   │           self.config = config
│   │           self.from_email = config.get('from_email', 'noreply@glamyouup.com')
│   │           self.from_name = config.get('from_name', 'GlamYouUp')
│   │       
│   │       @abstractmethod
│   │       async def send_email(self, message: EmailMessage) -> EmailResult:
│   │           """Send a single email"""
│   │           pass
│   │       
│   │       @abstractmethod
│   │       async def send_bulk_emails(self, messages: List[EmailMessage]) -> List[EmailResult]:
│   │           """Send multiple emails"""
│   │           pass
│   │       
│   │       @abstractmethod
│   │       async def health_check(self) -> bool:
│   │           """Check if provider is healthy"""
│   │           pass
│   │   ```
│   │   
│   ├── sendgrid.py
│   │   
│   │   ```py
│   │   import httpx
│   │   from typing import List, Dict, Any
│   │   from shared.errors.utils import classify_http_error
│   │   from shared.api.correlation import add_correlation_header
│   │   from .base import EmailProvider, EmailMessage, EmailResult
│   │   from src.models import NotificationProvider
│   │   import asyncio
│   │   
│   │   class SendGridProvider(EmailProvider):
│   │       """SendGrid email provider"""
│   │       
│   │       def __init__(self, config: Dict[str, Any]):
│   │           super().__init__(config)
│   │           self.api_key = config.get('api_key')
│   │           self.base_url = "https://api.sendgrid.com/v3"
│   │           self.timeout = config.get('timeout_seconds', 30)
│   │       
│   │       async def send_email(self, message: EmailMessage) -> EmailResult:
│   │           """Send email via SendGrid"""
│   │           try:
│   │               headers = {
│   │                   "Authorization": f"Bearer {self.api_key}",
│   │                   "Content-Type": "application/json"
│   │               }
│   │               
│   │               # Add correlation header for tracing
│   │               headers = add_correlation_header(headers)
│   │               
│   │               async with httpx.AsyncClient() as client:
│   │                   response = await client.post(
│   │                       f"{self.base_url}/mail/send",
│   │                       headers=headers,
│   │                       json={
│   │                           "personalizations": [{
│   │                               "to": [{"email": message.to_email}]
│   │                           }],
│   │                           "from": {
│   │                               "email": self.from_email,
│   │                               "name": self.from_name
│   │                           },
│   │                           "subject": message.subject,
│   │                           "content": [
│   │                               {"type": "text/html", "value": message.html_body},
│   │                               {"type": "text/plain", "value": message.text_body or ""}
│   │                           ]
│   │                       },
│   │                       timeout=self.timeout
│   │                   )
│   │                   
│   │                   if response.status_code in (200, 202):
│   │                       return EmailResult(
│   │                           success=True,
│   │                           provider=NotificationProvider.SENDGRID,
│   │                           provider_message_id=response.headers.get('X-Message-Id')
│   │                       )
│   │                   else:
│   │                       # Parse SendGrid error response
│   │                       error_data = response.json()
│   │                       errors = error_data.get('errors', [])
│   │                       error_message = errors[0].get('message') if errors else response.text
│   │                       
│   │                       return EmailResult(
│   │                           success=False,
│   │                           provider=NotificationProvider.SENDGRID,
│   │                           error_message=error_message,
│   │                           error_code=f"SENDGRID_{response.status_code}"
│   │                       )
│   │                       
│   │           except httpx.HTTPError as e:
│   │               # Use shared error classification
│   │               infra_error = classify_http_error(e, service_name="SendGrid")
│   │               
│   │               return EmailResult(
│   │                   success=False,
│   │                   provider=NotificationProvider.SENDGRID,
│   │                   error_message=str(infra_error),
│   │                   error_code=infra_error.code
│   │               )
│   │           except Exception as e:
│   │               return EmailResult(
│   │                   success=False,
│   │                   provider=NotificationProvider.SENDGRID,
│   │                   error_message=str(e),
│   │                   error_code="NETWORK_ERROR"
│   │               )
│   │       
│   │       async def send_bulk_emails(self, messages: List[EmailMessage]) -> List[EmailResult]:
│   │           """Send bulk emails via SendGrid"""
│   │           # SendGrid supports batch sending, but we'll use concurrent single sends
│   │           # for simplicity and better error handling per email
│   │           tasks = [self.send_email(message) for message in messages]
│   │           return await asyncio.gather(*tasks)
│   │       
│   │       async def health_check(self) -> bool:
│   │           """Check SendGrid API health"""
│   │           try:
│   │               headers = {
│   │                   "Authorization": f"Bearer {self.api_key}"
│   │               }
│   │               headers = add_correlation_header(headers)
│   │               
│   │               async with httpx.AsyncClient() as client:
│   │                   response = await client.get(
│   │                       f"{self.base_url}/scopes",
│   │                       headers=headers,
│   │                       timeout=5
│   │                   )
│   │                   return response.status_code == 200
│   │           except:
│   │               return False
│   │   ```
│   │   
│   ├── ses.py
│   │   
│   │   ```py
│   │   import boto3
│   │   from botocore.exceptions import ClientError
│   │   from typing import List, Dict, Any
│   │   from .base import EmailProvider, EmailMessage, EmailResult
│   │   from src.models import NotificationProvider
│   │   from shared.api.correlation import get_correlation_context
│   │   import asyncio
│   │   
│   │   class SESProvider(EmailProvider):
│   │       """AWS SES email provider"""
│   │       
│   │       def __init__(self, config: Dict[str, Any]):
│   │           super().__init__(config)
│   │           self.region = config.get('region', 'us-east-1')
│   │           
│   │           # Get correlation ID for AWS request context
│   │           correlation_id = get_correlation_context()
│   │           
│   │           # Create client with custom config including correlation ID in user agent
│   │           client_config = {
│   │               'region_name': self.region
│   │           }
│   │           
│   │           if config.get('aws_access_key_id'):
│   │               client_config['aws_access_key_id'] = config.get('aws_access_key_id')
│   │           if config.get('aws_secret_access_key'):
│   │               client_config['aws_secret_access_key'] = config.get('aws_secret_access_key')
│   │               
│   │           self.client = boto3.client('ses', **client_config)
│   │           
│   │           # If we have correlation ID, add it to the client metadata
│   │           if correlation_id:
│   │               self.client._client_config.user_agent_extra = f'correlation_id/{correlation_id}'
│   │       
│   │       async def send_email(self, message: EmailMessage) -> EmailResult:
│   │           """Send email via AWS SES"""
│   │           try:
│   │               # Run boto3 call in thread pool since it's sync
│   │               loop = asyncio.get_event_loop()
│   │               response = await loop.run_in_executor(
│   │                   None,
│   │                   self._send_email_sync,
│   │                   message
│   │               )
│   │               
│   │               return EmailResult(
│   │                   success=True,
│   │                   provider=NotificationProvider.AWS_SES,
│   │                   provider_message_id=response['MessageId']
│   │               )
│   │               
│   │           except ClientError as e:
│   │               error_code = e.response['Error']['Code']
│   │               error_message = e.response['Error']['Message']
│   │               
│   │               # Map AWS errors to our error codes
│   │               if error_code == 'MessageRejected':
│   │                   return EmailResult(
│   │                       success=False,
│   │                       provider=NotificationProvider.AWS_SES,
│   │                       error_message=error_message,
│   │                       error_code="INVALID_RECIPIENT"
│   │                   )
│   │               elif error_code == 'Throttling':
│   │                   return EmailResult(
│   │                       success=False,
│   │                       provider=NotificationProvider.AWS_SES,
│   │                       error_message=error_message,
│   │                       error_code="PROVIDER_RATE_LIMITED"
│   │                   )
│   │               elif error_code == 'MailFromDomainNotVerified':
│   │                   return EmailResult(
│   │                       success=False,
│   │                       provider=NotificationProvider.AWS_SES,
│   │                       error_message=error_message,
│   │                       error_code="CONFIGURATION_ERROR"
│   │                   )
│   │               else:
│   │                   return EmailResult(
│   │                       success=False,
│   │                       provider=NotificationProvider.AWS_SES,
│   │                       error_message=error_message,
│   │                       error_code="PROVIDER_ERROR"
│   │                   )
│   │                   
│   │           except Exception as e:
│   │               return EmailResult(
│   │                   success=False,
│   │                   provider=NotificationProvider.AWS_SES,
│   │                   error_message=str(e),
│   │                   error_code="NETWORK_ERROR"
│   │               )
│   │       
│   │       def _send_email_sync(self, message: EmailMessage) -> dict:
│   │           """Synchronous email send for thread pool"""
│   │           # Add correlation ID as a message tag if available
│   │           correlation_id = get_correlation_context()
│   │           
│   │           email_params = {
│   │               'Source': f"{self.from_name} <{self.from_email}>",
│   │               'Destination': {
│   │                   'ToAddresses': [message.to_email]
│   │               },
│   │               'Message': {
│   │                   'Subject': {
│   │                       'Data': message.subject,
│   │                       'Charset': 'UTF-8'
│   │                   },
│   │                   'Body': {
│   │                       'Html': {
│   │                           'Data': message.html_body,
│   │                           'Charset': 'UTF-8'
│   │                       },
│   │                       'Text': {
│   │                           'Data': message.text_body or '',
│   │                           'Charset': 'UTF-8'
│   │                       }
│   │                   }
│   │               }
│   │           }
│   │           
│   │           # Add correlation ID as a tag if available
│   │           if correlation_id:
│   │               email_params['Tags'] = [
│   │                   {
│   │                       'Name': 'correlation_id',
│   │                       'Value': correlation_id
│   │                   }
│   │               ]
│   │           
│   │           return self.client.send_email(**email_params)
│   │       
│   │       async def send_bulk_emails(self, messages: List[EmailMessage]) -> List[EmailResult]:
│   │           """Send bulk emails via SES"""
│   │           # SES supports bulk sending, but for simplicity we'll use concurrent single sends
│   │           tasks = [self.send_email(message) for message in messages]
│   │           return await asyncio.gather(*tasks)
│   │       
│   │       async def health_check(self) -> bool:
│   │           """Check SES health"""
│   │           try:
│   │               loop = asyncio.get_event_loop()
│   │               # Try to get send quota
│   │               await loop.run_in_executor(
│   │                   None,
│   │                   self.client.get_send_quota
│   │               )
│   │               return True
│   │           except:
│   │               return False
│   │   ```
│   │   
│   └── smtp.py
│       
│       ```py
│       import aiosmtplib
│       from email.mime.text import MIMEText
│       from email.mime.multipart import MIMEMultipart
│       from typing import List, Dict, Any
│       from .base import EmailProvider, EmailMessage, EmailResult
│       from src.models import NotificationProvider
│       from shared.api.correlation import get_correlation_context
│       import asyncio
│       import uuid
│       
│       class SMTPProvider(EmailProvider):
│           """SMTP email provider"""
│           
│           def __init__(self, config: Dict[str, Any]):
│               super().__init__(config)
│               self.host = config.get('host', 'localhost')
│               self.port = config.get('port', 1025)
│               self.username = config.get('username', '')
│               self.password = config.get('password', '')
│               self.use_tls = config.get('use_tls', False)  # MailHog doesn't need TLS
│               self.timeout = config.get('timeout', 30)
│           
│           async def send_email(self, message: EmailMessage) -> EmailResult:
│               """Send email via SMTP"""
│               try:
│                   # Create message
│                   msg = MIMEMultipart('alternative')
│                   msg['Subject'] = message.subject
│                   msg['From'] = f"{self.from_name} <{self.from_email}>"
│                   msg['To'] = message.to_email
│                   
│                   # Add correlation ID as a custom header
│                   correlation_id = get_correlation_context()
│                   if correlation_id:
│                       msg['X-Correlation-ID'] = correlation_id
│                   
│                   # Generate message ID if not already set
│                   if 'Message-ID' not in msg:
│                       msg['Message-ID'] = f"<{uuid.uuid4()}@{self.from_email.split('@')[1]}>"
│                   
│                   # Add text and HTML parts
│                   if message.text_body:
│                       text_part = MIMEText(message.text_body, 'plain', 'utf-8')
│                       msg.attach(text_part)
│                   
│                   html_part = MIMEText(message.html_body, 'html', 'utf-8')
│                   msg.attach(html_part)
│                   
│                   # Send email
│                   async with aiosmtplib.SMTP(
│                       hostname=self.host,
│                       port=self.port,
│                       timeout=self.timeout,
│                       use_tls=self.use_tls
│                   ) as smtp:
│                       if self.username and self.password:
│                           await smtp.login(self.username, self.password)
│                       
│                       response = await smtp.send_message(msg)
│                       
│                       # Check if email was sent successfully
│                       failed_recipients = response[0].get(message.to_email)
│                       if failed_recipients:
│                           return EmailResult(
│                               success=False,
│                               provider=NotificationProvider.SMTP,
│                               error_message=f"Failed to send to {message.to_email}",
│                               error_code="SMTP_SEND_FAILED"
│                           )
│                       
│                       return EmailResult(
│                           success=True,
│                           provider=NotificationProvider.SMTP,
│                           provider_message_id=msg['Message-ID']
│                       )
│                       
│               except aiosmtplib.SMTPAuthenticationError as e:
│                   return EmailResult(
│                       success=False,
│                       provider=NotificationProvider.SMTP,
│                       error_message=str(e),
│                       error_code="AUTHENTICATION_ERROR"
│                   )
│               except aiosmtplib.SMTPTimeoutError as e:
│                   return EmailResult(
│                       success=False,
│                       provider=NotificationProvider.SMTP,
│                       error_message=str(e),
│                       error_code="PROVIDER_TIMEOUT"
│                   )
│               except aiosmtplib.SMTPResponseException as e:
│                   # Handle specific SMTP errors
│                   if e.code == 550:  # Recipient rejected
│                       return EmailResult(
│                           success=False,
│                           provider=NotificationProvider.SMTP,
│                           error_message=str(e),
│                           error_code="INVALID_RECIPIENT"
│                       )
│                   else:
│                       return EmailResult(
│                           success=False,
│                           provider=NotificationProvider.SMTP,
│                           error_message=str(e),
│                           error_code="SMTP_ERROR"
│                       )
│               except Exception as e:
│                   return EmailResult(
│                       success=False,
│                       provider=NotificationProvider.SMTP,
│                       error_message=str(e),
│                       error_code="NETWORK_ERROR"
│                   )
│           
│           async def send_bulk_emails(self, messages: List[EmailMessage]) -> List[EmailResult]:
│               """Send bulk emails via SMTP"""
│               # For SMTP, we'll send emails sequentially to avoid overwhelming the server
│               results = []
│               
│               try:
│                   async with aiosmtplib.SMTP(
│                       hostname=self.host,
│                       port=self.port,
│                       timeout=self.timeout,
│                       use_tls=self.use_tls
│                   ) as smtp:
│                       if self.username and self.password:
│                           await smtp.login(self.username, self.password)
│                       
│                       for message in messages:
│                           # Create message
│                           msg = MIMEMultipart('alternative')
│                           msg['Subject'] = message.subject
│                           msg['From'] = f"{self.from_name} <{self.from_email}>"
│                           msg['To'] = message.to_email
│                           
│                           # Add correlation ID
│                           correlation_id = get_correlation_context()
│                           if correlation_id:
│                               msg['X-Correlation-ID'] = correlation_id
│                           
│                           # Generate message ID
│                           if 'Message-ID' not in msg:
│                               msg['Message-ID'] = f"<{uuid.uuid4()}@{self.from_email.split('@')[1]}>"
│                           
│                           # Add parts
│                           if message.text_body:
│                               text_part = MIMEText(message.text_body, 'plain', 'utf-8')
│                               msg.attach(text_part)
│                           
│                           html_part = MIMEText(message.html_body, 'html', 'utf-8')
│                           msg.attach(html_part)
│                           
│                           # Send
│                           try:
│                               response = await smtp.send_message(msg)
│                               failed = response[0].get(message.to_email)
│                               
│                               if failed:
│                                   results.append(EmailResult(
│                                       success=False,
│                                       provider=NotificationProvider.SMTP,
│                                       error_message=f"Failed to send to {message.to_email}",
│                                       error_code="SMTP_SEND_FAILED"
│                                   ))
│                               else:
│                                   results.append(EmailResult(
│                                       success=True,
│                                       provider=NotificationProvider.SMTP,
│                                       provider_message_id=msg['Message-ID']
│                                   ))
│                           except Exception as e:
│                               results.append(EmailResult(
│                                   success=False,
│                                   provider=NotificationProvider.SMTP,
│                                   error_message=str(e),
│                                   error_code="SMTP_ERROR"
│                               ))
│               except Exception as e:
│                   # Connection failed, all emails fail
│                   return [
│                       EmailResult(
│                           success=False,
│                           provider=NotificationProvider.SMTP,
│                           error_message=str(e),
│                           error_code="NETWORK_ERROR"
│                       ) for _ in messages
│                   ]
│               
│               return results
│           
│           async def health_check(self) -> bool:
│               """Check SMTP server availability"""
│               try:
│                   # For MailHog or other dev SMTP servers without auth
│                   if not self.username and not self.password:
│                       # Just try to connect without auth
│                       import smtplib
│                       with smtplib.SMTP(self.host, self.port, timeout=5) as server:
│                           # MailHog doesn't need STARTTLS or auth
│                           return True
│                   else:
│                       # Production SMTP with auth
│                       import smtplib
│                       with smtplib.SMTP(self.host, self.port, timeout=5) as server:
│                           if self.use_tls and self.port != 25:
│                               server.starttls()
│                           if self.username and self.password:
│                               server.login(self.username, self.password)
│                           return True
│               except Exception as e:
│                   print(f"SMTP health check failed: {e}")
│                   return False
│       ```
│       
├── repositories/
│   ├── __init__.py
│   └── notification_repository.py
│       
│       ```py
│       from __future__ import annotations
│       
│       from datetime import datetime, timezone
│       from typing import Optional, List, Dict, Any
│       from uuid import UUID
│       
│       from sqlalchemy import select, and_, func
│       from sqlalchemy.ext.asyncio import (
│           AsyncSession,
│           async_sessionmaker,
│       )
│       
│       from shared.database import Repository
│       from ..models.notification import Notification, NotificationStatus, NotificationProvider
│       
│       
│       class NotificationRepository(Repository[Notification]):
│           """Async Notification repo that opens a fresh session per call."""
│       
│           def __init__(
│               self,
│               model_class: type[Notification],
│               session_factory: async_sessionmaker[AsyncSession],
│           ):
│               super().__init__(model_class, session_factory)
│       
│           async def get_by_merchant_id(
│               self,
│               merchant_id: UUID,
│               limit: int = 100,
│           ) -> List[Notification]:
│               stmt = (
│                   select(self.model)
│                   .where(self.model.merchant_id == merchant_id)
│                   .order_by(self.model.created_at.desc())
│                   .limit(limit)
│               )
│               async for session in self._session():
│                   result = await session.execute(stmt)
│                   return list(result.scalars().all())
│               return []
│       
│           async def get_by_status(
│               self,
│               status: NotificationStatus,
│               limit: int = 100,
│           ) -> List[Notification]:
│               stmt = (
│                   select(self.model)
│                   .where(self.model.status == status)
│                   .order_by(self.model.created_at.desc())
│                   .limit(limit)
│               )
│               async for session in self._session():
│                   result = await session.execute(stmt)
│                   return list(result.scalars().all())
│               return []
│       
│           async def get_failed_for_retry(
│               self,
│               max_retries: int = 3,
│           ) -> List[Notification]:
│               stmt = (
│                   select(self.model)
│                   .where(
│                       and_(
│                           self.model.status == "failed",
│                           self.model.retry_count < max_retries,
│                       )
│                   )
│                   .order_by(self.model.created_at)
│               )
│               async for session in self._session():
│                   result = await session.execute(stmt)
│                   return list(result.scalars().all())
│       
│               return []
│       
│           async def count_by_type_and_shop(
│               self,
│               merchant_id: UUID,
│               notification_type: str,
│               since: Optional[datetime] = None,
│           ) -> int:
│               stmt = select(func.count(self.model.id)).where(
│                   and_(
│                       self.model.merchant_id == merchant_id,
│                       self.model.type == notification_type,
│                   )
│               )
│               if since:
│                   stmt = stmt.where(self.model.created_at >= since)
│       
│               async for session in self._session():
│                   result = await session.execute(stmt)
│                   return result.scalar() or 0
│       
│               return 0
│       
│           async def get_stats(
│               self,
│               merchant_id: Optional[UUID] = None,
│           ) -> Dict[str, Any]:
│               base_query = select(
│                   self.model.status,
│                   func.count(self.model.id).label("count"),
│               )
│               if merchant_id:
│                   base_query = base_query.where(self.model.merchant_id == merchant_id)
│               base_query = base_query.group_by(self.model.status)
│       
│               type_query = select(
│                   self.model.type,
│                   func.count(self.model.id).label("count"),
│               )
│               if merchant_id:
│                   type_query = type_query.where(self.model.merchant_id == merchant_id)
│               type_query = type_query.group_by(self.model.type)
│       
│               async for session in self._session():
│                   status_rows = await session.execute(base_query)
│                   stats = {row.status: row.count for row in status_rows}
│                   type_rows = await session.execute(type_query)
│                   type_stats = {row.type: row.count for row in type_rows}
│       
│                   return {
│                       "by_status": stats,
│                       "by_type": type_stats,
│                       "total": sum(
│                           int(v) for v in stats.values() if isinstance(v, (int, float))
│                       ),
│                   }
│               return {}
│       
│           async def get_by_id(
│               self,
│               notification_id: UUID,
│           ) -> Optional[Notification]:
│               stmt = select(self.model).where(self.model.id == notification_id)
│               async for session in self._session():
│                   result = await session.execute(stmt)
│                   return result.scalar_one_or_none()
│       
│           async def list(
│               self,
│               merchant_id: Optional[UUID] = None,
│               status: Optional[str] = None,
│               notification_type: Optional[str] = None,
│               offset: int = 1,
│               limit: int = 50,
│           ) -> tuple[list[Notification], int]:
│               """List notifications with optional filters.
│               Args:
│                   merchant_id (Optional[UUID]): Filter by shop ID.
│                   status (Optional[str]): Filter by notification status.
│                   notification_type (Optional[str]): Filter by notification type.
│                   offset (int): Pagination offset.
│                   limit (int): Number of records to return.
│       
│               Returns:
│                   total (int): Total number of notifications.
│                   notifications (List[Notification]): List of notifications matching the filters.
│       
│               """
│               stmt = select(self.model)
│       
│               if merchant_id:
│                   stmt = stmt.where(self.model.merchant_id == merchant_id)
│               if status:
│                   stmt = stmt.where(self.model.status == status)
│               if notification_type:
│                   stmt = stmt.where(self.model.type == notification_type)
│       
│               stmt = stmt.order_by(self.model.created_at.desc())
│               stmt = stmt.offset((offset - 1) * limit).limit(limit)
│               total_stmt = select(func.count(self.model.id)).select_from(self.model)
│       
│               async for session in self._session():
│                   result = await session.execute(stmt)
│                   notifications = result.scalars().all()
│       
│                   total_result = await session.execute(total_stmt)
│                   total = total_result.scalar_one_or_none() or 0
│       
│                   return list(notifications), total
│       
│               return [], 0
│       
│           # ---------------------------------------------------------------- updates
│           async def mark_as_sent(
│               self,
│               notification_id: UUID,
│               provider_message_id: str,
│               provider: NotificationProvider,
│           ) -> Notification:  # type: ignore[return]
│       
│               async for session in self._session():
│                   stmt = select(self.model).where(self.model.id == notification_id)
│                   result = await session.execute(stmt)
│                   notification = result.scalar_one_or_none()
│       
│                   if not notification:
│                       raise ValueError(f"Notification {notification_id} not found")
│       
│                   notification.status = NotificationStatus.SENT
│                   notification.provider_message_id = provider_message_id
│                   notification.provider = provider
│                   notification.sent_at = datetime.now(timezone.utc)
│       
│                   session.add(notification)
│                   await session.commit()
│                   return notification
│       
│           async def mark_as_failed(
│               self,
│               notification_id: UUID,
│               error_message: str,
│               retry_count: int,
│           ) -> Notification:  # type: ignore[return]
│       
│               async for session in self._session():
│                   stmt = select(self.model).where(self.model.id == notification_id)
│                   result = await session.execute(stmt)
│                   notification = result.scalar_one_or_none()
│       
│                   if not notification:
│                       raise ValueError(f"Notification {notification_id} not found")
│       
│                   notification.status = NotificationStatus.FAILED
│                   notification.error_message = error_message
│                   notification.retry_count += retry_count
│                   notification.sent_at = datetime.now(timezone.utc)
│       
│                   session.add(notification)
│                   await session.commit()
│                   return notification
│       
│           # ------------------------------------------------------------------ create
│           async def create(
│               self,
│               notification: Notification,
│           ) -> Notification:  # type: ignore[return]
│               async for session in self._session():
│                   session.add(notification)
│                   await session.commit()
│                   return notification
│       
│           async def bulk_create(
│               self,
│               notifications: List[Notification],
│           ) -> List[Notification]:
│               async for session in self._session():
│                   session.add_all(notifications)
│                   await session.commit()
│                   return notifications
│               return []
│       ```
│       
├── routers/
│   ├── __init__.py
│   ├── health.py
│   │   
│   │   ```py
│   │   from fastapi import APIRouter, Depends
│   │   from typing import Annotated
│   │   from datetime import datetime
│   │   from shared.api import success_response, RequestContextDep
│   │   from shared.errors import GlamBaseError
│   │   from ..dependencies import get_email_service
│   │   from ..services.email_service import EmailService
│   │   from shared.database import get_database_health
│   │   
│   │   router = APIRouter()
│   │   
│   │   @router.get("/health")
│   │   async def health_check(
│   │       ctx: RequestContextDep
│   │   ):
│   │       """Basic health check"""
│   │       return success_response(
│   │           data={
│   │               "status": "healthy",
│   │               "service": "notification-service",
│   │               "timestamp": datetime.utcnow().isoformat()
│   │           },
│   │           request_id=ctx.request_id,
│   │           correlation_id=ctx.correlation_id
│   │       )
│   │   
│   │   @router.get("/health/detailed")
│   │   async def detailed_health_check(
│   │       ctx: RequestContextDep,
│   │       email_service: Annotated[EmailService, Depends(get_email_service)]
│   │   ):
│   │       """Detailed health check including dependencies"""
│   │       health_data = {
│   │           "status": "healthy",
│   │           "service": "notification-service",
│   │           "timestamp": datetime.utcnow().isoformat(),
│   │           "checks": {}
│   │       }
│   │       
│   │       # Check database
│   │       try:
│   │           db_health = await get_database_health()
│   │           health_data["checks"]["database"] = {
│   │               "status": "healthy" if db_health else "unhealthy",
│   │               "responsive": db_health
│   │           }
│   │       except Exception as e:
│   │           health_data["checks"]["database"] = {
│   │               "status": "unhealthy",
│   │               "error": str(e)
│   │           }
│   │           health_data["status"] = "degraded"
│   │       
│   │       # Check email providers
│   │       try:
│   │           provider_health = await email_service.health_check()
│   │           health_data["checks"]["email_providers"] = provider_health
│   │           
│   │           # If no providers are healthy, service is degraded
│   │           if not any(provider_health.values()):
│   │               health_data["status"] = "degraded"
│   │       except Exception as e:
│   │           health_data["checks"]["email_providers"] = {
│   │               "status": "unhealthy",
│   │               "error": str(e)
│   │           }
│   │           health_data["status"] = "degraded"
│   │       
│   │       # If service is unhealthy, raise an error to trigger 503
│   │       if health_data["status"] != "healthy":
│   │           raise GlamBaseError(
│   │               code="SERVICE_DEGRADED",
│   │               message="Service is degraded",
│   │               status=503,
│   │               details=health_data
│   │           )
│   │       
│   │       return success_response(
│   │           data=health_data,
│   │           request_id=ctx.request_id,
│   │           correlation_id=ctx.correlation_id
│   │       )
│   │   
│   │   @router.get("/ready")
│   │   async def readiness_check(
│   │       ctx: RequestContextDep
│   │   ):
│   │       """Kubernetes readiness probe"""
│   │       return success_response(
│   │           data={"ready": True},
│   │           request_id=ctx.request_id,
│   │           correlation_id=ctx.correlation_id
│   │       )
│   │   
│   │   @router.get("/live")
│   │   async def liveness_check(
│   │       ctx: RequestContextDep
│   │   ):
│   │       """Kubernetes liveness probe"""
│   │       return success_response(
│   │           data={"alive": True},
│   │           request_id=ctx.request_id,
│   │           correlation_id=ctx.correlation_id
│   │       )
│   │   ```
│   │   
│   ├── notifications.py
│   │   
│   │   ```py
│   │   from fastapi import APIRouter, Query, HTTPException
│   │   from typing import List, Optional
│   │   from uuid import UUID
│   │   
│   │   from shared.api import (
│   │       ApiResponse,
│   │       success_response,
│   │       paginated_response,
│   │       Links,
│   │       RequestContextDep,
│   │       PaginationDep,
│   │   )
│   │   from src.dependencies import NotificationServiceDep
│   │   
│   │   from src.schemas import (
│   │       NotificationResponse,
│   │       NotificationListResponse,
│   │   )
│   │   
│   │   router = APIRouter(tags=["notifications"])
│   │   
│   │   
│   │   @router.get(
│   │       "",
│   │       response_model=ApiResponse[NotificationListResponse],
│   │       summary="List notification history",
│   │   )
│   │   async def list_notifications(
│   │       svc: NotificationServiceDep,
│   │       pagination: PaginationDep,
│   │       ctx: RequestContextDep,
│   │       merchant_id: Optional[UUID] = Query(None),
│   │       status: Optional[str] = Query(None),
│   │       type: Optional[str] = Query(None),
│   │   ):
│   │       """List notifications with pagination."""
│   │       # Service returns tuple of (items, total)
│   │       items, total = await svc.list_notifications(
│   │           merchant_id=merchant_id,
│   │           status=status,
│   │           notification_type=type,
│   │           offset=pagination.offset,
│   │           limit=pagination.limit,
│   │       )
│   │   
│   │       return paginated_response(
│   │           data=items,
│   │           page=pagination.page,
│   │           limit=pagination.limit,
│   │           total=total,
│   │           base_url="/api/v1/notifications",
│   │           request_id=ctx.request_id,
│   │           correlation_id=ctx.correlation_id,
│   │           merchant_id=merchant_id,
│   │           status=status,
│   │           type=type,
│   │       )
│   │   
│   │   
│   │   @router.get(
│   │       "/{notification_id}",
│   │       response_model=ApiResponse[NotificationResponse],
│   │       summary="Get notification details",
│   │   )
│   │   async def get_notification(
│   │       notification_id: UUID,
│   │       svc: NotificationServiceDep,
│   │       ctx: RequestContextDep,
│   │   ):
│   │       """Get detailed notification information."""
│   │       notification = await svc.get_notification(notification_id)
│   │   
│   │       if not notification:
│   │           # The middleware will catch this and convert to standard error response
│   │           raise HTTPException(status_code=404, detail="Notification not found")
│   │   
│   │       return success_response(
│   │           data=notification,
│   │           request_id=ctx.request_id,
│   │           correlation_id=ctx.correlation_id,
│   │           links=Links(self=f"/api/v1/notifications/{notification_id}"),
│   │       )
│   │   ```
│   │   
│   └── templates.py
│       
│       ```py
│       # services/notification-service/src/api/templates.py
│       """Template management endpoints"""
│       
│       from fastapi import APIRouter, Query, HTTPException
│       from typing import Optional
│       
│       from shared.api import (
│           ApiResponse,
│           success_response,
│           Links,
│           RequestContextDep
│       )
│       from src.dependencies import TemplateServiceDep
│       
│       from src.schemas.template import (
│           TemplateResponse,
│           TemplateListResponse,
│           TemplatePreviewRequest,
│           TemplatePreviewResponse,
│           TemplateValidationRequest,
│           TemplateValidationResponse
│       )
│       
│       router = APIRouter(tags=["templates"])
│       
│       @router.get(
│           "",
│           response_model=ApiResponse[TemplateListResponse],
│           summary="List all available templates"
│       )
│       async def list_templates(
│           svc: TemplateServiceDep,
│           ctx: RequestContextDep,
│           category: Optional[str] = Query(None, description="Filter by category (system, marketing, transactional)"),
│       ):
│           """
│           List all available notification templates.
│           
│           Templates are defined in the system and include:
│           - System templates (billing notifications)
│           - Transactional templates (order, registration)
│           - Marketing templates (custom campaigns)
│           """
│           # Get all template types
│           template_types = svc.get_available_types()
│           
│           # Build template list with metadata
│           templates = []
│           for template_type in template_types:
│               template = await svc.get_template_for_type(template_type)
│               if template:
│                   # Determine category based on type
│                   template_category = _get_template_category(template_type)
│                   
│                   # Filter by category if specified
│                   if category and template_category != category:
│                       continue
│                   
│                   templates.append({
│                       'type': template_type,
│                       'name': template_type.replace('_', ' ').title(),
│                       'category': template_category,
│                       'variables': template['variables'],
│                       'preview_available': True
│                   })
│           
│           # Sort templates by category and name
│           templates.sort(key=lambda x: (x['category'], x['name']))
│           
│           return success_response(
│               data={
│                   'templates': templates,
│                   'total': len(templates)
│               },
│               request_id=ctx.request_id,
│               correlation_id=ctx.correlation_id,
│               links=Links(self="/api/v1/templates")
│           )
│       
│       @router.get(
│           "/{template_type}",
│           response_model=ApiResponse[TemplateResponse],
│           summary="Get template details by type"
│       )
│       async def get_template(
│           template_type: str,
│           svc: TemplateServiceDep,
│           ctx: RequestContextDep,
│           preview: bool = Query(False, description="Include preview with sample data")
│       ):
│           """
│           Get detailed information about a specific template type.
│           
│           Optionally include a preview with sample data to see how the template renders.
│           """
│           template = await svc.get_template_for_type(template_type)
│           
│           if not template:
│               raise HTTPException(
│                   status_code=404, 
│                   detail=f"Template not found: {template_type}"
│               )
│           
│           response_data = {
│               'type': template_type,
│               'name': template_type.replace('_', ' ').title(),
│               'category': _get_template_category(template_type),
│               'subject_template': template['subject'],
│               'body_template': template['body'],
│               'variables': template['variables'],
│               'global_variables': [
│                   'platform_name',
│                   'current_year',
│                   'support_url',
│                   'unsubscribe_url'
│               ]
│           }
│           
│           # Include preview if requested
│           if preview:
│               preview_result = await svc.preview_template(template_type)
│               response_data['preview'] = preview_result
│           
│           return success_response(
│               data=response_data,
│               request_id=ctx.request_id,
│               correlation_id=ctx.correlation_id,
│               links=Links(
│                   self=f"/api/v1/templates/{template_type}",
│                   next=f"/api/v1/templates/{template_type}/preview"
│               )
│           )
│       
│       @router.post(
│           "/{template_type}/preview",
│           response_model=ApiResponse[TemplatePreviewResponse],
│           summary="Preview template with custom data"
│       )
│       async def preview_template(
│           template_type: str,
│           request: TemplatePreviewRequest,
│           svc: TemplateServiceDep,
│           ctx: RequestContextDep,
│       ):
│           """
│           Preview a template with custom sample data.
│           
│           Useful for testing templates with specific variable values
│           before sending actual notifications.
│           """
│           template = await svc.get_template_for_type(template_type)
│           
│           if not template:
│               raise HTTPException(
│                   status_code=404,
│                   detail=f"Template not found: {template_type}"
│               )
│           
│           # Preview with provided data
│           preview_result = await svc.preview_template(
│               template_type,
│               request.sample_data
│           )
│           
│           if 'error' in preview_result:
│               raise HTTPException(
│                   status_code=400,
│                   detail=preview_result['error']
│               )
│           
│           return success_response(
│               data=preview_result,
│               request_id=ctx.request_id,
│               correlation_id=ctx.correlation_id,
│               links=Links(
│                   self=f"/api/v1/templates/{template_type}/preview",
│                   previous=f"/api/v1/templates/{template_type}"
│               )
│           )
│       
│       @router.post(
│           "/validate",
│           response_model=ApiResponse[TemplateValidationResponse],
│           summary="Validate template syntax"
│       )
│       async def validate_template(
│           request: TemplateValidationRequest,
│           svc: TemplateServiceDep,
│           ctx: RequestContextDep,
│       ):
│           """
│           Validate Jinja2 template syntax.
│           
│           Useful for validating custom templates before saving them.
│           """
│           validation_result = svc.validate_template_syntax(
│               request.subject,
│               request.body
│           )
│           
│           return success_response(
│               data=validation_result,
│               request_id=ctx.request_id,
│               correlation_id=ctx.correlation_id,
│               links=Links(self="/api/v1/templates/validate")
│           )
│       
│       def _get_template_category(template_type: str) -> str:
│           """Determine template category based on type"""
│           if template_type.startswith('billing_'):
│               return 'system'
│           elif template_type in ['welcome', 'sync_start', 'sync_completed']:
│               return 'transactional'
│           else:
│               return 'marketing'
│       ```
│       
├── schemas/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # -------------------------------
│   │   # services/notification-service/src/schemas/__init__.py
│   │   # -------------------------------
│   │   
│   │   """Request and response schemas for notification service."""
│   │   
│   │   from .notification import (
│   │       # Requests
│   │       NotificationCreate,
│   │       NotificationUpdate,
│   │       BulkNotificationCreate,
│   │       NotificationFilter,
│   │       
│   │       # Responses
│   │       NotificationResponse,
│   │       NotificationDetailResponse,
│   │       NotificationListResponse,
│   │   )
│   │   
│   │   from .template import (
│   │       # Requests
│   │       TemplateRequest,
│   │       TemplatePreviewRequest,
│   │       TemplateValidationRequest,
│   │       
│   │       # Responses
│   │       TemplateResponse,
│   │       TemplateDetailResponse,
│   │       TemplateListResponse,
│   │       TemplatePreviewResponse,
│   │       TemplateValidationResponse,
│   │   )
│   │   
│   │   
│   │   from .common import (
│   │       # Common schemas
│   │       ShopInfo,
│   │       PaginationParams,
│   │       DateRangeFilter,
│   │       SortOrder,
│   │   )
│   │   
│   │   __all__ = [
│   │       # Notification
│   │       "NotificationCreate",
│   │       "NotificationUpdate",
│   │       "BulkNotificationCreate",
│   │       "NotificationFilter",
│   │       "NotificationResponse",
│   │       "NotificationDetailResponse",
│   │       "NotificationListResponse",
│   │       
│   │       # Template
│   │       "TemplateRequest",
│   │       "TemplatePreviewRequest",
│   │       "TemplateValidationRequest",
│   │       "TemplateResponse",
│   │       "TemplateDetailResponse",
│   │       "TemplateListResponse",
│   │       "TemplatePreviewResponse",
│   │       "TemplateValidationResponse",
│   │       
│   │       # Common
│   │       "ShopInfo",
│   │       "PaginationParams",
│   │       "DateRangeFilter",
│   │       "SortOrder",
│   │   ]
│   │   ```
│   │   
│   ├── common.py
│   │   
│   │   ```py
│   │   # services/notification-service/src/schemas/common.py
│   │   
│   │   """Common schemas used across the notification service."""
│   │   
│   │   from datetime import datetime
│   │   from typing import Optional
│   │   from pydantic import BaseModel, Field, ConfigDict, EmailStr
│   │   from enum import Enum
│   │   from uuid import UUID
│   │   
│   │   
│   │   class SortOrder(str, Enum):
│   │       """Sort order options."""
│   │   
│   │       ASC = "asc"
│   │       DESC = "desc"
│   │   
│   │   
│   │   class ShopInfo(BaseModel):
│   │       """Shop identification information."""
│   │   
│   │       merchant_id: UUID
│   │       merchant_domain: str = Field(..., min_length=1, max_length=255)
│   │       shop_email: EmailStr
│   │       unsubscribe_token: str = Field(..., min_length=1, max_length=255)
│   │       dynamic_content: Optional[dict] = None
│   │   
│   │       model_config = ConfigDict(from_attributes=True)
│   │   
│   │   
│   │   class PaginationParams(BaseModel):
│   │       """Standard pagination parameters."""
│   │   
│   │       page: int = Field(1, ge=1)
│   │       limit: int = Field(50, ge=1, le=100)
│   │   
│   │       @property
│   │       def offset(self) -> int:
│   │           return (self.page - 1) * self.limit
│   │   
│   │   
│   │   class DateRangeFilter(BaseModel):
│   │       """Date range filter for queries."""
│   │   
│   │       start_date: Optional[datetime] = None
│   │       end_date: Optional[datetime] = None
│   │   
│   │       def validate_range(self) -> "DateRangeFilter":
│   │           """Validate that start is before end."""
│   │           if self.start_date and self.end_date and self.start_date > self.end_date:
│   │               raise ValueError("start_date must be before end_date")
│   │           return self
│   │   ```
│   │   
│   ├── notification.py
│   │   
│   │   ```py
│   │   # File: services/notification-service/src/schemas/notification.py
│   │   
│   │   """Notification-related request and response schemas."""
│   │   
│   │   from datetime import datetime
│   │   from typing import Optional, Dict, List, Any
│   │   from pydantic import BaseModel, Field, EmailStr, field_validator, ConfigDict, conlist
│   │   from uuid import UUID
│   │   
│   │   from ..models.notification import NotificationStatus, NotificationProvider
│   │   from .common import ShopInfo, DateRangeFilter, SortOrder
│   │   
│   │   
│   │   # Request Schemas
│   │   
│   │   
│   │   class NotificationCreate(ShopInfo):
│   │       """Create a new notification request."""
│   │   
│   │       notification_type: str = Field(..., min_length=1, max_length=50)
│   │       extra_metadata: Dict[str, Any] = Field(default_factory=dict)
│   │   
│   │       @field_validator(
│   │           "merchant_id", "merchant_domain", "shop_email", "unsubscribe_token"
│   │       )
│   │       def validate_content_source(cls, v):
│   │           """Ensure required fields are provided."""
│   │           if not v:
│   │               raise ValueError("This field is required")
│   │           return v
│   │   
│   │   
│   │   class BulkNotificationCreate(BaseModel):
│   │       """Create multiple notifications at once."""
│   │   
│   │       notification_type: str = Field(..., min_length=1, max_length=50)
│   │       recipients: List[ShopInfo] = Field(..., min_length=1, max_length=100)
│   │   
│   │       @field_validator("recipients")
│   │       def validate_recipients(cls, v):
│   │           """Validate recipients list size and required fields."""
│   │           if not (1 <= len(v) <= 100):
│   │               raise ValueError("Recipients list must have between 1 and 100 items")
│   │           for recipient in v:
│   │               if (
│   │                   not recipient.merchant_id
│   │                   or not recipient.merchant_domain
│   │                   or not recipient.shop_email
│   │                   or not recipient.unsubscribe_token
│   │               ):
│   │                   raise ValueError(
│   │                       "Each recipient must have merchant_id, merchant_domain, shop_email, and unsubscribe_token"
│   │                   )
│   │           return v
│   │   
│   │   
│   │   class NotificationUpdate(BaseModel):
│   │       """Update notification status."""
│   │   
│   │       status: NotificationStatus
│   │       provider_message_id: Optional[str] = None
│   │       error_message: Optional[str] = None
│   │       sent_at: Optional[datetime] = None
│   │   
│   │   
│   │   class NotificationFilter(BaseModel):
│   │       """Filter parameters for notification queries."""
│   │   
│   │       merchant_id: Optional[UUID] = None
│   │       recipient_email: Optional[EmailStr] = None
│   │       type: Optional[str] = None
│   │       status: Optional[NotificationStatus] = None
│   │       provider: Optional[NotificationProvider] = None
│   │       date_range: Optional[DateRangeFilter] = None
│   │       sort_by: str = Field("created_at", pattern="^(created_at|sent_at|status|type)$")
│   │       sort_order: SortOrder = SortOrder.DESC
│   │   
│   │   
│   │   # Response Schemas
│   │   
│   │   class NotificationResponse(BaseModel):
│   │       """Basic notification response."""
│   │   
│   │       id: UUID
│   │       merchant_id: UUID
│   │       merchant_domain: str
│   │       shop_email: str
│   │       type: str
│   │       status: NotificationStatus
│   │       sent_at: Optional[datetime] = None
│   │       created_at: datetime
│   │       updated_at: datetime
│   │   
│   │       model_config = ConfigDict(from_attributes=True)
│   │   
│   │   
│   │   class NotificationDetailResponse(NotificationResponse):
│   │       """Detailed notification response with full information."""
│   │   
│   │       content: str
│   │       provider: Optional[NotificationProvider] = None
│   │       provider_message_id: Optional[str] = None
│   │       error_message: Optional[str] = None
│   │       retry_count: int
│   │       extra_metadata: Optional[Dict[str, Any]] = None
│   │   
│   │   
│   │   class NotificationListResponse(BaseModel):
│   │       """Paginated list of notifications."""
│   │   
│   │       notifications: List[NotificationResponse]
│   │       total: int
│   │       page: int
│   │       limit: int
│   │       has_next: bool
│   │       has_previous: bool
│   │   ```
│   │   
│   └── template.py
│       
│       ```py
│       # services/notification-service/src/schemas/template.py
│       """Template-related request/response schemas"""
│       
│       from pydantic import BaseModel, Field
│       from typing import Dict, List, Optional, Any
│       
│       
│       class TemplateRequest(BaseModel):
│           """Requestbody for getting template"""
│           type: str = Field(..., description="Type of the template to retrieve")
│           
│           class Config:
│               json_schema_extra = {
│                   "example": {
│                       "type": "welcome_email"
│                   }
│               }
│       
│       
│       class TemplatePreviewRequest(BaseModel):
│           """Request body for template preview"""
│           sample_data: Dict[str, Any] = Field(
│               description="Sample data to render the template with"
│           )
│           
│           class Config:
│               json_schema_extra = {
│                   "example": {
│                       "sample_data": {
│                           "shop_name": "My Fashion Store",
│                           "product_count": 150
│                       }
│                   }
│               }
│               
│       class TemplateValidationRequest(BaseModel):
│           """Request body for template validation"""
│           subject: str = Field(description="Subject template to validate")
│           body: str = Field(description="Body template to validate")
│           
│           class Config:
│               json_schema_extra = {
│                   "example": {
│                       "subject": "Hello {{ shop_name }}!",
│                       "body": "<p>Welcome to {{ platform_name }}</p>"
│                   }
│               }
│       
│       
│       class TemplateVariables(BaseModel):
│           """Template variable requirements"""
│           required: List[str] = Field(default_factory=list)
│           optional: List[str] = Field(default_factory=list)
│       
│       
│       class TemplateResponse(BaseModel):
│           """Basic template information"""
│           type: str
│           name: str
│           category: str
│           variables: TemplateVariables
│           preview_available: bool = True
│       
│       
│       class TemplateListResponse(BaseModel):
│           """Template list response"""
│           templates: List[TemplateResponse]
│           total: int
│       
│       
│       class TemplateDetailResponse(BaseModel):
│           """Detailed template information"""
│           type: str
│           name: str
│           category: str
│           subject_template: str
│           body_template: str
│           variables: TemplateVariables
│           global_variables: List[str]
│           preview: Optional[Dict[str, Any]] = None
│       
│       
│       class TemplatePreviewResponse(BaseModel):
│           """Template preview response"""
│           subject: str
│           body_html: str
│           body_text: str
│           missing_variables: List[str]
│           unused_variables: List[str]
│           all_variables: List[str]
│           sample_data_used: Dict[str, Any]
│           notification_type: str
│       
│       
│       class TemplateValidationResponse(BaseModel):
│           """Template validation response"""
│           is_valid: bool
│           syntax_errors: List[str]
│           warnings: List[str]
│       
│       ```
│       
├── services/
│   ├── __init__.py
│   ├── email_service.py
│   │   
│   │   ```py
│   │   from typing import List, Dict, Any, Optional
│   │   from shared.utils.logger import ServiceLogger
│   │   from shared.errors.utils import wrap_external_error
│   │   from shared.api.correlation import add_correlation_header
│   │   
│   │   from ..providers.base import EmailProvider, EmailMessage, EmailResult
│   │   from ..providers.sendgrid import SendGridProvider
│   │   from ..providers.ses import SESProvider
│   │   from ..providers.smtp import SMTPProvider
│   │   from ..exceptions import EmailProviderError
│   │   
│   │   
│   │   class EmailService:
│   │       """Email service with fallback support"""
│   │       
│   │       def __init__(self, config: dict, logger: ServiceLogger):
│   │           self.config = config
│   │           self.logger = logger
│   │           self.providers: Dict[str, EmailProvider] = {}
│   │           self.current_provider = config.get('email_primary_provider')
│   │           self._init_providers()
│   │       
│   │       def _init_providers(self):
│   │           """Initialize email providers"""
│   │           try:
│   │               # SendGrid
│   │               if self.config.get('sendgrid_config'):
│   │                   self.providers['sendgrid'] = SendGridProvider(self.config['sendgrid_config'])
│   │               
│   │               # SES
│   │               if self.config.get('ses_config'):
│   │                   self.providers['ses'] = SESProvider(self.config['ses_config'])
│   │               
│   │               # SMTP
│   │               if self.config.get('smtp_config'):
│   │                   self.providers['smtp'] = SMTPProvider(self.config['smtp_config'])
│   │           except Exception as e:
│   │               raise wrap_external_error(
│   │                   EmailProviderError,
│   │                   "Failed to initialize email providers",
│   │                   cause=e,
│   │                   provider="initialization"
│   │               )
│   │       
│   │       async def send_email(self, message: EmailMessage) -> EmailResult:
│   │           """Send email with automatic fallback"""
│   │           if not isinstance(self.current_provider, str):
│   │               raise EmailProviderError(
│   │                   "Current provider is not a valid string",
│   │                   provider=self.current_provider,
│   │                   provider_error_code="INVALID_PROVIDER"
│   │               )
│   │           primary_provider = self.providers.get(self.current_provider)
│   │           
│   │           if not primary_provider:
│   │               raise EmailProviderError(
│   │                   f"Primary provider {self.current_provider} not configured",
│   │                   provider=self.current_provider,
│   │                   provider_error_code="NOT_CONFIGURED"
│   │               )
│   │           
│   │           # Try primary provider
│   │           try:
│   │               self.logger.info(f"Sending email via primary provider: {self.current_provider}")
│   │               add_correlation_header({})
│   │               
│   │               result = await primary_provider.send_email(message)
│   │               
│   │               if result.success:
│   │                   return result
│   │               else:
│   │                   self.logger.warning(
│   │                       f"Primary provider {self.current_provider} failed with error: {result.error_message}",
│   │                       extra={"provider": self.current_provider}
│   │                   )
│   │                   result = EmailResult(
│   │                       success=False,
│   │                       provider=self.current_provider,
│   │                       provider_message_id=result.provider_message_id,
│   │                       error_message=result.error_message,
│   │                       error_code=result.error_code or "PROVIDER_ERROR"
│   │                   )
│   │                   
│   │                   return result
│   │           except Exception as e:
│   │               self.logger.warning(
│   │                   f"Primary provider {self.current_provider} failed: {e}",
│   │                   extra={"provider": self.current_provider}
│   │               )
│   │               result = EmailResult(
│   │                   success=False,
│   │                   provider=self.current_provider,
│   │                   provider_message_id=None,
│   │                   error_message=str(e),
│   │                   error_code="PROVIDER_ERROR"
│   │               )
│   │       
│   │           
│   │           # Try fallback provider if primary fails
│   │           fallback_name = self.config.get('fallback_provider')
│   │           if fallback_name and fallback_name != self.current_provider:
│   │               fallback_provider = self.providers.get(fallback_name)
│   │               
│   │               if fallback_provider:
│   │                   self.logger.info(f"Trying fallback provider {fallback_name}")
│   │                   self.current_provider = fallback_name
│   │                   
│   │                   try:
│   │                       result = await fallback_provider.send_email(message)
│   │                       
│   │                       if result.success:
│   │                           return result
│   │                   except Exception as e:
│   │                       self.logger.error(
│   │                           f"Fallback provider {fallback_name} also failed: {e}",
│   │                           extra={"provider": fallback_name}
│   │                       )
│   │                       result = EmailResult(
│   │                           success=False,
│   │                           provider=fallback_name,
│   │                           error_message=str(e),
│   │                           error_code="PROVIDER_ERROR"
│   │                       )
│   │           
│   │           # All providers failed
│   │           raise EmailProviderError(
│   │               "All email providers failed",
│   │               provider=self.current_provider,
│   │               provider_message=result.error_message,
│   │               provider_error_code=result.error_code
│   │           )
│   │       
│   │       async def send_bulk_emails(self, messages: List[EmailMessage]) -> List[EmailResult]:
│   │           """Send bulk emails"""
│   │           provider = self.providers.get(self.current_provider)
│   │           
│   │           if not provider:
│   │               raise EmailProviderError(
│   │                   f"Provider {self.current_provider} not configured",
│   │                   provider=self.current_provider,
│   │                   provider_error_code="NOT_CONFIGURED"
│   │               )
│   │           
│   │           try:
│   │               return await provider.send_bulk_emails(messages)
│   │           except Exception as e:
│   │               raise wrap_external_error(
│   │                   EmailProviderError,
│   │                   f"Bulk send failed via {self.current_provider}",
│   │                   cause=e,
│   │                   provider=self.current_provider
│   │               )
│   │       
│   │       async def health_check(self) -> Dict[str, bool]:
│   │           """Check health of all providers"""
│   │           health_status = {}
│   │           
│   │           for name, provider in self.providers.items():
│   │               try:
│   │                   health_status[name] = await provider.health_check()
│   │               except Exception as e:
│   │                   self.logger.error(f"Health check failed for {name}: {e}")
│   │                   health_status[name] = False
│   │           
│   │           return health_status
│   │   ```
│   │   
│   ├── notification_service.py
│   │   
│   │   ```py
│   │   # File: services/notification-service/src/services/notification_service.py
│   │   """Refactored notification service with improved separation of concerns"""
│   │   
│   │   from typing import Optional
│   │   
│   │   import time
│   │   from dataclasses import dataclass
│   │   from uuid import UUID
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   from shared.errors.utils import is_retryable_error
│   │   
│   │   from .email_service import EmailService
│   │   from .template_service import TemplateService
│   │   
│   │   from ..config import ServiceConfig
│   │   from ..repositories.notification_repository import NotificationRepository
│   │   from ..exceptions import TemplateNotFoundError
│   │   from ..events.publishers import NotificationEventPublisher
│   │   from ..providers.base import EmailMessage, EmailResult
│   │   from ..models.notification import Notification
│   │   from ..mappers.notification_mapper import NotificationMapper
│   │   from ..metrics import (
│   │       increment_notification_sent,
│   │       observe_notification_duration,
│   │       observe_template_render_duration,
│   │   )
│   │   from ..schemas import NotificationCreate
│   │   
│   │   
│   │   class NotificationService:
│   │       """Core notification business logic"""
│   │   
│   │       def __init__(
│   │           self,
│   │           config: ServiceConfig,
│   │           publisher: NotificationEventPublisher,
│   │           email_service: EmailService,
│   │           template_service: TemplateService,
│   │           notification_mapper: NotificationMapper,
│   │           notification_repository: NotificationRepository,
│   │           logger: ServiceLogger,
│   │       ):
│   │           self.config = config
│   │           self.publisher = publisher
│   │           self.email_service = email_service
│   │           self.template_service = template_service
│   │           self.notification_repo = notification_repository
│   │           self.logger = logger
│   │           self.mapper = notification_mapper
│   │   
│   │           # Bulk sending configuration
│   │           self.bulk_config = {
│   │               "default_batch_size": 100,
│   │               "max_batch_size": 1000,
│   │               "min_batch_size": 1,
│   │               "batch_delay_seconds": 1.0,
│   │               "max_delay_seconds": 60.0,
│   │               "concurrent_batches": 10,
│   │           }
│   │   
│   │       async def create_and_send_notification(
│   │           self, notification_create: NotificationCreate
│   │       ) -> UUID:
│   │           """
│   │           Create and send a notification
│   │   
│   │           This method is the main entry point for creating and sending notifications.
│   │           It handles preference checks, rate limiting, template rendering, and email delivery.
│   │           Parameters:
│   │               notification_create (NotificationCreate): The notification details
│   │           """
│   │   
│   │           # Validate input
│   │           if (
│   │               not notification_create.merchant_id
│   │               or not notification_create.merchant_domain
│   │           ):
│   │               raise ValueError("Shop ID and domain are required")
│   │   
│   │           # Create notification record
│   │           notification = await self.create_notification(notification_create)
│   │   
│   │           # Send the notification
│   │           return await self.send_notification(notification)
│   │   
│   │       async def create_notification(
│   │           self, notification_create: NotificationCreate
│   │       ) -> Notification:
│   │           """
│   │           Create and send a notification
│   │   
│   │           This method is a simplified entry point for sending notifications.
│   │           It handles preference checks, rate limiting, template rendering, and email delivery.
│   │           """
│   │   
│   │           # Extract notification details
│   │           notification_type = notification_create.notification_type
│   │           merchant_id = notification_create.merchant_id
│   │           merchant_domain = notification_create.merchant_domain
│   │           unsubscribe_token = notification_create.unsubscribe_token
│   │           dynamic_content = notification_create.dynamic_content or {}
│   │           extra_metadata = notification_create.extra_metadata or {}
│   │   
│   │           self.logger.info(
│   │               "Creating and sending notification",
│   │               extra={
│   │                   "merchant_id": str(merchant_id),
│   │                   "merchant_domain": merchant_domain,
│   │                   "notification_type": notification_type,
│   │                   "correlation_id": extra_metadata.get("correlation_id", None),
│   │               },
│   │           )
│   │   
│   │           template = await self.template_service.get_template_for_type(notification_type)
│   │   
│   │           self.logger.debug(
│   │               f"Retrieved template for notification type {notification_type}",
│   │               extra={
│   │                   "merchant_id": str(merchant_id),
│   │                   "merchant_domain": merchant_domain,
│   │                   "correlation_id": extra_metadata.get("correlation_id", None),
│   │               },
│   │           )
│   │           if not template:
│   │               self.logger.error(
│   │                   f"No template found for notification type: {notification_type}",
│   │                   extra={
│   │                       "merchant_id": str(merchant_id),
│   │                       "merchant_domain": merchant_domain,
│   │                       "correlation_id": extra_metadata.get("correlation_id", None),
│   │                   },
│   │               )
│   │               raise TemplateNotFoundError(
│   │                   f"No template found for notification type: {notification_type}",
│   │                   notification_type=notification_type,
│   │               )
│   │   
│   │           template_start = time.time()
│   │   
│   │           subject, html_body, text_body = await self.template_service.render_template(
│   │               template=template,
│   │               dynamic_content=dynamic_content,
│   │               unsubscribe_token=unsubscribe_token,
│   │           )
│   │   
│   │           observe_template_render_duration(
│   │               template_type=notification_type, duration=time.time() - template_start
│   │           )
│   │   
│   │           new_notification = self.mapper.create_to_model(
│   │               notification_create, subject=subject, content=html_body
│   │           )
│   │   
│   │           notification = await self.notification_repo.create(new_notification)
│   │   
│   │           self.logger.info(
│   │               f"Created notification record {notification.id}",
│   │               extra={
│   │                   "notification_id": str(notification.id),
│   │                   "notification_type": notification_type,
│   │                   "correlation_id": extra_metadata.get("correlation_id", None),
│   │               },
│   │           )
│   │   
│   │           return notification
│   │   
│   │       async def send_notification(self, notification: Notification) -> UUID:
│   │           """
│   │           Send a single notification
│   │   
│   │           This is the main entry point for sending notifications. It orchestrates
│   │           the entire process including preference checks, rate limiting, template
│   │           rendering, and email delivery.
│   │           """
│   │           start_time = time.time()
│   │   
│   │           self.logger.info(
│   │               "Sending notification",
│   │               extra={
│   │                   "notification_id": str(notification.id),
│   │                   "merchant_id": str(notification.merchant_id),
│   │                   "merchant_domain": notification.merchant_domain,
│   │                   "recipient_email": notification.recipient_email,
│   │                   "notification_type": notification.type,
│   │                   "correlation_id": (notification.extra_metadata or {}).get(
│   │                       "correlation_id", None
│   │                   ),
│   │               },
│   │           )
│   │   
│   │           try:
│   │               email_message = EmailMessage(
│   │                   to_email=notification.recipient_email,
│   │                   subject=notification.subject,
│   │                   html_body=notification.content,
│   │                   text_body=notification.content,
│   │               )
│   │               provider_response: EmailResult = await self.email_service.send_email(
│   │                   message=email_message
│   │               )
│   │   
│   │               increment_notification_sent(
│   │                   notification_type=notification.type,
│   │                   provider="sendgrid",
│   │                   status="success",
│   │               )
│   │               # Update notification status to sent
│   │               await self.notification_repo.mark_as_sent(
│   │                   notification_id=UUID(str(notification.id)),
│   │                   provider=provider_response.provider,
│   │                   provider_message_id=(
│   │                       provider_response.provider_message_id
│   │                       if provider_response.provider_message_id
│   │                       else "No response received"
│   │                   ),
│   │               )
│   │   
│   │               self.logger.info(
│   │                   f"Email sent successfully via {provider_response.provider}",
│   │                   extra={
│   │                       "notification_id": str(notification.id),
│   │                       "provider_message_id": provider_response.provider_message_id,
│   │                       "correlation_id": (notification.extra_metadata or {}).get(
│   │                           "correlation_id", None
│   │                       ),
│   │                   },
│   │               )
│   │   
│   │               # Publish success event
│   │               await self.publisher.publish_email_sent(
│   │                   notification_id=UUID(str(notification.id)),
│   │                   merchant_id=UUID(str(notification.merchant_id)),
│   │                   notification_type=notification.type,
│   │                   provider=provider_response.provider,
│   │                   provider_message_id=(
│   │                       provider_response.provider_message_id
│   │                       if provider_response.provider_message_id
│   │                       else "No response received"
│   │                   ),
│   │                   correlation_id=(notification.extra_metadata or {}).get(
│   │                       "correlation_id", None
│   │                   ),
│   │               )
│   │   
│   │           except Exception as e:
│   │               # Record failure
│   │               increment_notification_sent(
│   │                   notification_type=notification.type,
│   │                   provider="sendgrid",
│   │                   status="failure",
│   │               )
│   │               # Update notification status to failed
│   │               await self.notification_repo.mark_as_failed(
│   │                   notification_id=UUID(str(notification.id)),
│   │                   error_message=str(e),
│   │                   retry_count=1,
│   │               )
│   │   
│   │               self.logger.error(
│   │                   f"Failed to send email: {e}",
│   │                   extra={
│   │                       "notification_id": UUID(str(notification.id)),
│   │                       "error": str(e),
│   │                       "correlation_id": (notification.extra_metadata or {}).get(
│   │                           "correlation_id", None
│   │                       ),
│   │                   },
│   │               )
│   │   
│   │               # Publish failure event
│   │               await self.publisher.publish_email_failed(
│   │                   notification_id=UUID(str(notification.id)),
│   │                   merchant_id=UUID(str(notification.merchant_id)),
│   │                   notification_type=notification.type,
│   │                   error=str(e),
│   │                   error_code=getattr(e, "code", "UNKNOWN_ERROR"),
│   │                   retry_count=1,
│   │                   will_retry=is_retryable_error(e),
│   │                   correlation_id=(notification.extra_metadata or {}).get(
│   │                       "correlation_id", None
│   │                   ),
│   │               )
│   │   
│   │               raise
│   │   
│   │           finally:
│   │               # Record total duration
│   │               observe_notification_duration(
│   │                   notification_type=notification.type,
│   │                   provider="sendgrid",
│   │                   duration=time.time() - start_time,
│   │               )
│   │   
│   │           return UUID(str(notification.id))
│   │   
│   │       async def retry_notification(
│   │           self, notification_id: UUID, correlation_id: Optional[str] = None
│   │       ) -> UUID:
│   │           """Retry a failed notification"""
│   │   
│   │           # Get original notification
│   │           notification = await self.notification_repo.get_by_id(notification_id)
│   │           if not notification:
│   │               raise ValueError(f"Notification {notification_id} not found")
│   │   
│   │           if notification.status != "failed":
│   │               raise ValueError(
│   │                   f"Can only retry failed notifications. Current status: {notification.status}"
│   │               )
│   │   
│   │           # Extract original data and retry
│   │           return await self.send_notification(notification=notification)
│   │   
│   │       async def list_notifications(
│   │           self,
│   │           offset,
│   │           limit,
│   │           merchant_id: Optional[UUID] = None,
│   │           status: Optional[str] = None,
│   │           notification_type: Optional[str] = None,
│   │       ) -> tuple[list[Notification], int]:
│   │           """
│   │           List notifications with optional filters
│   │   
│   │           Parameters:
│   │               offset (int): Pagination offset
│   │               limit (int): Number of records to return
│   │               merchant_id (Optional[UUID]): Filter by shop ID
│   │               status (Optional[str]): Filter by notification status
│   │               notification_type (Optional[str]): Filter by notification type
│   │   
│   │           Returns:
│   │               Dict[List[Notification], int]: Tuple of notifications and total count
│   │           """
│   │   
│   │           self.logger.info(
│   │               "Listing notifications",
│   │               extra={
│   │                   "merchant_id": str(merchant_id) if merchant_id else None,
│   │                   "status": status,
│   │                   "notification_type": notification_type,
│   │                   "offset": offset,
│   │                   "limit": limit,
│   │               },
│   │           )
│   │   
│   │           notifications, total_count = await self.notification_repo.list(
│   │               merchant_id=merchant_id,
│   │               status=status,
│   │               notification_type=notification_type,
│   │               offset=offset,
│   │               limit=limit,
│   │           )
│   │   
│   │           self.logger.info(
│   │               f"Listed {len(notifications)} notifications",
│   │               extra={
│   │                   "merchant_id": str(merchant_id) if merchant_id else None,
│   │                   "status": status,
│   │                   "notification_type": notification_type,
│   │                   "offset": offset,
│   │                   "limit": limit,
│   │                   "total_count": total_count,
│   │               },
│   │           )
│   │   
│   │           return notifications, total_count
│   │   
│   │       async def get_notification(self, notification_id: UUID) -> Notification:
│   │           """
│   │           Get a single notification by ID
│   │   
│   │           Parameters:
│   │               notification_id (UUID): Notification ID
│   │   
│   │           Returns:
│   │               Notification: The requested notification
│   │           """
│   │   
│   │           self.logger.info(
│   │               f"Fetching notification {notification_id}",
│   │               extra={"notification_id": str(notification_id)},
│   │           )
│   │   
│   │           notification = await self.notification_repo.get_by_id(notification_id)
│   │   
│   │           if not notification:
│   │               self.logger.warning(
│   │                   f"Notification {notification_id} not found",
│   │                   extra={"notification_id": str(notification_id)},
│   │               )
│   │               raise ValueError(f"Notification {notification_id} not found")
│   │   
│   │           self.logger.info(
│   │               f"Fetched notification {notification.id}",
│   │               extra={"notification_id": str(notification.id)},
│   │           )
│   │   
│   │           return notification
│   │   ```
│   │   
│   └── template_service.py
│       
│       ```py
│       # services/notification-service/src/services/template_service.py
│       """
│       Template Service - File-based implementation
│       
│       Responsibilities:
│       1. Load templates from EmailTemplates class (file-based)
│       2. Validate required variables
│       3. Render templates using Jinja2
│       4. Generate plain text versions
│       5. Provide template preview functionality
│       """
│       
│       from typing import Dict, Any, Optional, Tuple, List
│       from datetime import datetime
│       import html2text
│       from jinja2 import Environment, TemplateError, select_autoescape, meta
│       
│       from shared.utils.logger import ServiceLogger
│       from ..templates.email_templates import EmailTemplates
│       from ..exceptions import (
│           TemplateNotFoundError,
│           TemplateRenderError,
│           ValidationError,
│       )
│       from ..config import ServiceConfig
│       
│       
│       class TemplateService:
│           """
│           Service for managing and rendering file-based email templates.
│           All templates are defined in EmailTemplates class.
│           """
│       
│           def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│               """
│               Initialize template service
│       
│               Args:
│                   config: Service configuration containing URLs
│                   logger: Service logger
│               """
│               self.config = config
│               self.logger = logger
│       
│               # Initialize Jinja2 environment
│               self.env = Environment(
│                   autoescape=select_autoescape(["html", "xml"]),
│                   trim_blocks=True,
│                   lstrip_blocks=True,
│               )
│       
│               # Initialize html2text for plain text conversion
│               self.html2text = html2text.HTML2Text()
│               self.html2text.ignore_links = False
│               self.html2text.ignore_images = True
│               self.html2text.body_width = 78
│       
│               # Cache compiled templates
│               self._template_cache: Dict[str, Any] = {}
│       
│           async def get_template_for_type(
│               self, notification_type: str
│           ) -> Optional[Dict[str, Any]]:
│               """
│               Get template data for a specific notification type
│       
│               Args:
│                   notification_type: Type of notification (e.g., 'welcome', 'billing_expired')
│       
│               Returns:
│                   Template data or None if not found
│               """
│               try:
│                   template_data = EmailTemplates.get_template(notification_type)
│                   return {
│                       "type": notification_type,
│                       "subject": template_data["subject"],
│                       "body": template_data["body"],
│                       "variables": template_data["variables"],
│                   }
│               except ValueError:
│                   self.logger.warning(f"Template not found for type: {notification_type}")
│                   return None
│       
│           async def render_template(
│               self,
│               template: Dict[str, Any],
│               dynamic_content: Dict[str, Any],
│               unsubscribe_token: Optional[str] = None,
│           ) -> Tuple[str, str, str]:
│               """
│               Render email template with provided variables
│       
│               Args:
│                   template: Template data from get_template_for_type
│                   dynamic_content: Variables to inject into template
│                   unsubscribe_token: Token for unsubscribe URL (optional for non-marketing)
│       
│               Returns:
│                   Tuple of (subject, html_body, text_body)
│       
│               Raises:
│                   ValidationError: If required variables are missing
│                   TemplateRenderError: If template rendering fails
│               """
│               notification_type = template["type"]
│       
│               # Validate required variables
│               validation = self._validate_variables(template, dynamic_content)
│               if not validation["is_valid"]:
│                   raise ValidationError(
│                       f"Missing required variables for {notification_type}: {validation['missing_required']}"
│                   )
│       
│               # Log unused variables as warning
│               if validation["unused_variables"]:
│                   self.logger.warning(
│                       f"Unused variables in {notification_type} template",
│                       extra={
│                           "notification_type": notification_type,
│                           "unused_variables": validation["unused_variables"],
│                       },
│                   )
│       
│               # Prepare context with global and dynamic variables
│               context = self._prepare_context(dynamic_content, unsubscribe_token)
│       
│               try:
│                   # Render subject
│                   subject_template = self._get_or_compile_template(
│                       f"{notification_type}_subject", template["subject"]
│                   )
│                   subject = subject_template.render(**context)
│       
│                   # Render HTML body
│                   body_template = self._get_or_compile_template(
│                       f"{notification_type}_body", template["body"]
│                   )
│                   html_body = body_template.render(**context)
│       
│                   # Generate plain text version
│                   text_body = self.html2text.handle(html_body)
│       
│                   self.logger.info(
│                       f"Successfully rendered {notification_type} template",
│                       extra={"notification_type": notification_type},
│                   )
│       
│                   return subject, html_body, text_body
│       
│               except TemplateError as e:
│                   self.logger.error(
│                       f"Template rendering failed for {notification_type}",
│                       extra={"notification_type": notification_type, "error": str(e)},
│                   )
│                   raise TemplateRenderError(
│                       f"Failed to render {notification_type} template: {e}",
│                       template_name=notification_type,
│                       render_error=str(e),
│                   )
│       
│           def _prepare_context(
│               self, dynamic_content: Dict[str, Any], unsubscribe_token: Optional[str] = None
│           ) -> Dict[str, Any]:
│               """Prepare template context with global and dynamic variables"""
│       
│               # Global variables available in all templates
│               global_vars = {
│                   "platform_name": "GlamYouUp",
│                   "current_year": datetime.now().year,
│                   "support_url": "https://support.glamyouup.com",  # TODO: Use config value
│               }
│       
│               # Add unsubscribe URL only if token is provided (marketing emails)
│               if unsubscribe_token:
│                   app_url = "https://app.glamyouup.com"  # TODO: Use config value
│                   global_vars["unsubscribe_url"] = (
│                       f"{app_url}/unsubscribe/{unsubscribe_token}"
│                   )
│               else:
│                   # For non-marketing emails, provide empty string to avoid template errors
│                   global_vars["unsubscribe_url"] = ""
│       
│               # Merge global and dynamic variables
│               return {**global_vars, **dynamic_content}
│       
│           def _validate_variables(
│               self, template: Dict[str, Any], provided_variables: Dict[str, Any]
│           ) -> Dict[str, Any]:
│               """Validate that all required variables are provided"""
│       
│               template_vars = template["variables"]
│               required = set(template_vars["required"])
│               optional = set(template_vars["optional"])
│       
│               # Global variables that are always available
│               global_vars = {
│                   "platform_name",
│                   "current_year",
│                   "support_url",
│                   "unsubscribe_url",
│               }
│       
│               # Variables provided
│               provided = set(provided_variables.keys()) | global_vars
│       
│               # Check for missing required variables
│               missing_required = required - provided
│       
│               # Check for unused variables (excluding globals)
│               all_expected = required | optional | global_vars
│               unused = set(provided_variables.keys()) - all_expected
│       
│               return {
│                   "is_valid": len(missing_required) == 0,
│                   "missing_required": list(missing_required),
│                   "unused_variables": list(unused),
│                   "all_variables": list(all_expected),
│               }
│       
│           def _get_or_compile_template(self, cache_key: str, template_string: str):
│               """Get compiled template from cache or compile and cache it"""
│               if cache_key not in self._template_cache:
│                   self._template_cache[cache_key] = self.env.from_string(template_string)
│               return self._template_cache[cache_key]
│       
│           async def preview_template(
│               self, notification_type: str, sample_data: Optional[Dict[str, Any]] = None
│           ) -> Dict[str, Any]:
│               """
│               Preview template with sample data
│       
│               Args:
│                   notification_type: Type of notification to preview
│                   sample_data: Optional sample data, uses defaults if not provided
│       
│               Returns:
│                   Preview data including rendered content and validation info
│               """
│               # Get template
│               template = await self.get_template_for_type(notification_type)
│               if not template:
│                   return {
│                       "error": f"Template not found for type: {notification_type}",
│                       "notification_type": notification_type,
│                   }
│       
│               # Use default sample data if none provided
│               if sample_data is None:
│                   sample_data = self._get_default_sample_data(notification_type)
│       
│               # Use dummy token for preview
│               dummy_token = "preview_token_123456"
│       
│               try:
│                   # Render template
│                   subject, html_body, text_body = await self.render_template(
│                       template, sample_data, dummy_token
│                   )
│       
│                   # Get validation info
│                   validation = self._validate_variables(template, sample_data)
│       
│                   return {
│                       "subject": subject,
│                       "body_html": html_body,
│                       "body_text": text_body,
│                       "missing_variables": validation["missing_required"],
│                       "unused_variables": validation["unused_variables"],
│                       "all_variables": validation["all_variables"],
│                       "sample_data_used": sample_data,
│                       "notification_type": notification_type,
│                   }
│       
│               except Exception as e:
│                   return {
│                       "error": str(e),
│                       "notification_type": notification_type,
│                       "sample_data_used": sample_data,
│                   }
│       
│           def _get_default_sample_data(self, notification_type: str) -> Dict[str, Any]:
│               """Get default sample data for template preview"""
│       
│               defaults = {
│                   "welcome": {
│                       "shop_name": "Example Fashion Store",
│                       "merchant_domain": "example-store.myshopify.com",
│                   },
│                   "registration_finish": {"product_count": 150},
│                   "registration_sync": {
│                       "added_count": 25,
│                       "updated_count": 10,
│                       "removed_count": 5,
│                   },
│                   "billing_expired": {
│                       "plan_name": "Professional Plan",
│                       "renewal_link": "https://app.glamyouup.com/billing/renew",
│                   },
│                   "billing_changed": {"plan_name": "Enterprise Plan"},
│                   "billing_low_credits": {
│                       "current_balance": "125.50",
│                       "days_remaining": 5,
│                       "expected_depletion_date": "January 20, 2025",
│                       "billing_link": "https://app.glamyouup.com/billing",
│                   },
│                   "billing_zero_balance": {
│                       "deactivation_time": "January 16, 2025 at 2:00 AM UTC",
│                       "billing_link": "https://app.glamyouup.com/billing",
│                   },
│                   "billing_deactivated": {
│                       "reason": "insufficient credits",
│                       "reactivation_link": "https://app.glamyouup.com/billing/reactivate",
│                   },
│               }
│       
│               return defaults.get(
│                   notification_type, {"content": "Sample notification content"}
│               )
│       
│           def validate_template_syntax(self, subject: str, body: str) -> Dict[str, Any]:
│               """
│               Validate Jinja2 template syntax
│       
│               Args:
│                   subject: Subject template string
│                   body: Body template string
│       
│               Returns:
│                   Validation results with errors and warnings
│               """
│               errors = []
│               warnings = []
│       
│               # Validate subject template
│               try:
│                   subject_ast = self.env.parse(subject)
│                   subject_vars = meta.find_undeclared_variables(subject_ast)
│               except TemplateError as e:
│                   errors.append(f"Subject template error: {str(e)}")
│       
│               # Validate body template
│               try:
│                   body_ast = self.env.parse(body)
│                   body_vars = meta.find_undeclared_variables(body_ast)
│               except TemplateError as e:
│                   errors.append(f"Body template error: {str(e)}")
│       
│               # Check for common issues
│               if "{{" in subject + body and not "}}" in subject + body:
│                   warnings.append("Possible unclosed variable tag detected")
│       
│               if "{%" in subject + body and not "%}" in subject + body:
│                   warnings.append("Possible unclosed block tag detected")
│       
│               return {
│                   "is_valid": len(errors) == 0,
│                   "syntax_errors": errors,
│                   "warnings": warnings,
│               }
│       
│           def get_available_types(self) -> List[str]:
│               """Get list of all available notification types"""
│               return EmailTemplates.get_all_types()
│       
│           def clear_template_cache(self):
│               """Clear the compiled template cache"""
│               self._template_cache.clear()
│               self.logger.info("Template cache cleared")
│       
│       
│       # Example usage
│       """
│       # Initialize service
│       config = {
│           'app_url': 'https://app.glamyouup.com',
│           'support_url': 'https://support.glamyouup.com'
│       }
│       template_service = TemplateService(config, logger)
│       
│       # Get and render a template
│       template = await template_service.get_template_for_type('welcome')
│       if template:
│           subject, html, text = await template_service.render_template(
│               template,
│               {'shop_name': 'My Shop', 'merchant_domain': 'myshop.com'},
│               unsubscribe_token='abc123'  # Only for marketing emails
│           )
│       
│       # Preview a template
│       preview = await template_service.preview_template('billing_expired')
│       print(preview['subject'])
│       """
│       ```
│       
├── templates/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/notification-service/src/templates/email_templates.py
│   │   """Email templates for different notification types"""
│   │   
│   │   from typing import Dict, Any
│   │   from datetime import datetime
│   │   
│   │   
│   │   class EmailTemplates:
│   │       """Email template definitions with all required variables"""
│   │   
│   │       # Base footer template used in all emails
│   │       FOOTER_TEMPLATE = """
│   │       <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
│   │           <div style="text-align: center; font-size: 12px; color: #666;">
│   │               <p>
│   │                   <a href="{{ support_url }}" style="color: #666; text-decoration: none;">Contact Support</a> | 
│   │                   <a href="{{ unsubscribe_url }}" style="color: #666; text-decoration: none;">Unsubscribe</a>
│   │               </p>
│   │               <p>&copy; {{ current_year }} {{ platform_name }}. All rights reserved.</p>
│   │           </div>
│   │       </div>
│   │       """
│   │   
│   │       WELCOME = {
│   │           "subject": "Welcome to GlamYouUp! 🎉",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #f8f9fa; padding: 20px; text-align: center;">
│   │                   <h1 style="color: #333;">Welcome to GlamYouUp!</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi {{ shop_name }},</p>
│   │                   
│   │                   <p>Thank you for launching GlamYouUp on your store! We're excited to help you provide an amazing shopping experience for your customers.</p>
│   │                   
│   │                   <h2 style="color: #666;">Key Features Now Available:</h2>
│   │                   
│   │                   <div style="margin: 20px 0;">
│   │                       <h3 style="color: #333;">✨ Personal Style Analysis</h3>
│   │                       <p>Help customers discover their unique style profile with AI-powered analysis.</p>
│   │                   </div>
│   │                   
│   │                   <div style="margin: 20px 0;">
│   │                       <h3 style="color: #333;">👗 Best Style Fit Recommendation</h3>
│   │                       <p>Match customers with products that perfectly suit their style preferences.</p>
│   │                   </div>
│   │                   
│   │                   <div style="margin: 20px 0;">
│   │                       <h3 style="color: #333;">🤳 Proactive Tryon Analysis</h3>
│   │                       <p>Let customers virtually try on products before making a purchase.</p>
│   │                   </div>
│   │                   
│   │                   <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 30px 0;">
│   │                       <h3 style="color: #1976d2;">Next Steps:</h3>
│   │                       <ol style="color: #555;">
│   │                           <li>Complete product registration to enable AI features</li>
│   │                           <li>Customize your style preferences</li>
│   │                           <li>Start promoting virtual try-on to your customers</li>
│   │                       </ol>
│   │                   </div>
│   │                   
│   │                   <p>If you have any questions, don't hesitate to reach out to our support team!</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {"required": ["shop_name"], "optional": []},
│   │       }
│   │   
│   │       REGISTRATION_FINISH = {
│   │           "subject": "Product Registration Complete! ✅",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #4caf50; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Registration Complete!</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Great news!</p>
│   │                   
│   │                   <p>We've successfully registered <strong>{{ product_count }}</strong> products from your store with our AI system.</p>
│   │                   
│   │                   <div style="background-color: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
│   │                       <h3 style="color: #2e7d32;">What This Means:</h3>
│   │                       <ul style="color: #555;">
│   │                           <li>Your products are now ready for AI-powered style analysis</li>
│   │                           <li>Customers can use virtual try-on features</li>
│   │                           <li>Personalized recommendations are active</li>
│   │                       </ul>
│   │                   </div>
│   │                   
│   │                   <p>Your customers can now enjoy the full GlamYouUp experience!</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {"required": ["product_count"], "optional": []},
│   │       }
│   │   
│   │       REGISTRATION_SYNC = {
│   │           "subject": "Product Catalog Updated 🔄",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #2196f3; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Catalog Sync Complete</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi there,</p>
│   │                   
│   │                   <p>We've detected changes in your product catalog and automatically synced them with GlamYouUp.</p>
│   │                   
│   │                   <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
│   │                       <h3 style="color: #1976d2;">Sync Summary:</h3>
│   │                       <ul style="color: #555;">
│   │                           <li><strong>{{ added_count }}</strong> new products added</li>
│   │                           <li><strong>{{ updated_count }}</strong> products updated</li>
│   │                           {% if removed_count > 0 %}
│   │                           <li><strong>{{ removed_count }}</strong> products removed</li>
│   │                           {% endif %}
│   │                       </ul>
│   │                   </div>
│   │                   
│   │                   <p>The updated products are being processed by our AI system and will be ready for virtual try-on shortly.</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {
│   │               "required": ["added_count", "updated_count"],
│   │               "optional": ["removed_count"],
│   │           },
│   │       }
│   │   
│   │       BILLING_EXPIRED = {
│   │           "subject": "Your GlamYouUp Subscription Has Expired ⚠️",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #ff9800; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Subscription Expired</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi there,</p>
│   │                   
│   │                   <p>Your GlamYouUp subscription ({{ plan_name }}) has expired.</p>
│   │                   
│   │                   <div style="background-color: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
│   │                       <h3 style="color: #e65100;">What This Means:</h3>
│   │                       <ul style="color: #555;">
│   │                           <li>Virtual try-on features are temporarily disabled</li>
│   │                           <li>AI style recommendations are paused</li>
│   │                           <li>Your product data is safely stored</li>
│   │                       </ul>
│   │                   </div>
│   │                   
│   │                   <div style="text-align: center; margin: 30px 0;">
│   │                       <a href="{{ renewal_link }}" style="background-color: #4caf50; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
│   │                           Renew Subscription
│   │                       </a>
│   │                   </div>
│   │                   
│   │                   <p>Renew your subscription to continue providing amazing experiences for your customers!</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {"required": ["plan_name", "renewal_link"], "optional": []},
│   │       }
│   │   
│   │       BILLING_CHANGED = {
│   │           "subject": "Billing Plan Updated Successfully ✅",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #4caf50; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Plan Updated!</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi there,</p>
│   │                   
│   │                   <p>Your billing plan has been successfully updated to: <strong>{{ plan_name }}</strong></p>
│   │                   
│   │                   <div style="background-color: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
│   │                       <p>All GlamYouUp features are now active and ready to use!</p>
│   │                   </div>
│   │                   
│   │                   <p>Thank you for continuing to trust GlamYouUp for your virtual try-on needs.</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {"required": ["plan_name"], "optional": []},
│   │       }
│   │   
│   │       BILLING_LOW_CREDITS = {
│   │           "subject": "Credit Balance Running Low ⚠️",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #ff9800; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Low Credit Balance</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi there,</p>
│   │                   
│   │                   <p>Your GlamYouUp credit balance is running low.</p>
│   │                   
│   │                   <div style="background-color: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
│   │                       <h3 style="color: #e65100;">Current Status:</h3>
│   │                       <ul style="color: #555;">
│   │                           <li>Current balance: <strong>${{ current_balance }}</strong></li>
│   │                           <li>Estimated days remaining: <strong>{{ days_remaining }} days</strong></li>
│   │                           <li>Expected depletion: <strong>{{ expected_depletion_date }}</strong></li>
│   │                       </ul>
│   │                   </div>
│   │                   
│   │                   <p>To avoid service interruption, please add credits or upgrade your plan.</p>
│   │                   
│   │                   <div style="text-align: center; margin: 30px 0;">
│   │                       <a href="{{ billing_link }}" style="background-color: #2196f3; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
│   │                           Add Credits
│   │                       </a>
│   │                   </div>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {
│   │               "required": [
│   │                   "current_balance",
│   │                   "days_remaining",
│   │                   "expected_depletion_date",
│   │                   "billing_link",
│   │               ],
│   │               "optional": [],
│   │           },
│   │       }
│   │   
│   │       BILLING_ZERO_BALANCE = {
│   │           "subject": "URGENT: Zero Balance - Service Deactivation in 16 Hours 🚨",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #f44336; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Zero Balance Alert</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi there,</p>
│   │                   
│   │                   <p><strong>Your GlamYouUp credit balance has reached $0.</strong></p>
│   │                   
│   │                   <div style="background-color: #ffebee; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #f44336;">
│   │                       <h3 style="color: #c62828;">⏰ IMPORTANT:</h3>
│   │                       <p style="color: #555; font-size: 16px;">
│   │                           GlamYouUp features will be automatically deactivated at:<br>
│   │                           <strong style="font-size: 18px;">{{ deactivation_time }}</strong>
│   │                       </p>
│   │                   </div>
│   │                   
│   │                   <p>To continue using GlamYouUp without interruption, please add credits immediately.</p>
│   │                   
│   │                   <div style="text-align: center; margin: 30px 0;">
│   │                       <a href="{{ billing_link }}" style="background-color: #f44336; color: white; padding: 15px 40px; text-decoration: none; border-radius: 5px; display: inline-block; font-size: 18px;">
│   │                           Add Credits Now
│   │                       </a>
│   │                   </div>
│   │                   
│   │                   <p>Don't let your customers miss out on the virtual try-on experience!</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {
│   │               "required": ["deactivation_time", "billing_link"],
│   │               "optional": [],
│   │           },
│   │       }
│   │   
│   │       BILLING_DEACTIVATED = {
│   │           "subject": "GlamYouUp Features Deactivated 🔒",
│   │           "body": """
│   │           <html>
│   │           <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│   │               <div style="background-color: #757575; padding: 20px; text-align: center;">
│   │                   <h1 style="color: white;">Features Deactivated</h1>
│   │               </div>
│   │               
│   │               <div style="padding: 30px;">
│   │                   <p>Hi there,</p>
│   │                   
│   │                   <p>GlamYouUp features have been deactivated for your store due to: <strong>{{ reason }}</strong></p>
│   │                   
│   │                   <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
│   │                       <h3 style="color: #424242;">Currently Disabled:</h3>
│   │                       <ul style="color: #555;">
│   │                           <li>Virtual try-on functionality</li>
│   │                           <li>AI style recommendations</li>
│   │                           <li>Product analysis features</li>
│   │                       </ul>
│   │                   </div>
│   │                   
│   │                   <p>Your product data and settings are safely stored and will be restored once you reactivate your account.</p>
│   │                   
│   │                   <div style="text-align: center; margin: 30px 0;">
│   │                       <a href="{{ reactivation_link }}" style="background-color: #4caf50; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
│   │                           Reactivate Account
│   │                       </a>
│   │                   </div>
│   │                   
│   │                   <p>We'd love to have you back!</p>
│   │                   
│   │                   <p>Best regards,<br>The GlamYouUp Team</p>
│   │                   
│   │                   """
│   │           + FOOTER_TEMPLATE
│   │           + """
│   │               </div>
│   │           </body>
│   │           </html>
│   │           """,
│   │           "variables": {"required": ["reason", "reactivation_link"], "optional": []},
│   │       }
│   │   
│   │       @classmethod
│   │       def get_template(cls, notification_type: str) -> Dict[str, Any]:
│   │           """Get template for notification type"""
│   │           templates = {
│   │               "welcome": cls.WELCOME,
│   │               "registration_finish": cls.REGISTRATION_FINISH,
│   │               "registration_sync": cls.REGISTRATION_SYNC,
│   │               "billing_expired": cls.BILLING_EXPIRED,
│   │               "billing_changed": cls.BILLING_CHANGED,
│   │               "billing_low_credits": cls.BILLING_LOW_CREDITS,
│   │               "billing_zero_balance": cls.BILLING_ZERO_BALANCE,
│   │               "billing_deactivated": cls.BILLING_DEACTIVATED,
│   │           }
│   │   
│   │           return templates.get(
│   │               notification_type,
│   │               {
│   │                   "subject": "GlamYouUp Notification",
│   │                   "body": "<html><body><p>{{ content }}</p></body></html>",
│   │                   "variables": {"required": ["content"], "optional": []},
│   │               },
│   │           )
│   │   
│   │       @classmethod
│   │       def get_all_templates(cls) -> Dict[str, Dict[str, Any]]:
│   │           """Get all available templates"""
│   │           return {
│   │               "welcome": cls.WELCOME,
│   │               "registration_finish": cls.REGISTRATION_FINISH,
│   │               "registration_sync": cls.REGISTRATION_SYNC,
│   │               "billing_expired": cls.BILLING_EXPIRED,
│   │               "billing_changed": cls.BILLING_CHANGED,
│   │               "billing_low_credits": cls.BILLING_LOW_CREDITS,
│   │               "billing_zero_balance": cls.BILLING_ZERO_BALANCE,
│   │               "billing_deactivated": cls.BILLING_DEACTIVATED,
│   │           }
│   │   
│   │       @classmethod
│   │       def get_template_info(cls, notification_type: str) -> Dict[str, Any]:
│   │           """Get template information including variables"""
│   │           template = cls.get_template(notification_type)
│   │           return {
│   │               "type": notification_type,
│   │               "subject": template.get("subject", ""),
│   │               "variables": template.get("variables", {"required": [], "optional": []}),
│   │               "has_body": bool(template.get("body")),
│   │           }
│   │   
│   │       @classmethod
│   │       def validate_variables(
│   │           cls, notification_type: str, provided_variables: Dict[str, Any]
│   │       ) -> Dict[str, Any]:
│   │           """Validate that all required variables are provided"""
│   │           template = cls.get_template(notification_type)
│   │           required_vars = template.get("variables", {}).get("required", [])
│   │           optional_vars = template.get("variables", {}).get("optional", [])
│   │   
│   │           missing_required = [
│   │               var for var in required_vars if var not in provided_variables
│   │           ]
│   │           unused_variables = [
│   │               var
│   │               for var in provided_variables
│   │               if var
│   │               not in required_vars
│   │               + optional_vars
│   │               + ["unsubscribe_token", "merchant_id", "merchant_domain"]
│   │           ]
│   │   
│   │           return {
│   │               "is_valid": len(missing_required) == 0,
│   │               "missing_required": missing_required,
│   │               "unused_variables": unused_variables,
│   │           }
│   │   ```
│   │   
│   ├── email_templates.py
│   │   
│   │   ```py
│   │   # services/notification-service/src/templates/email_templates.py
│   │   """System email templates for all notification types"""
│   │   
│   │   from typing import Dict, Any
│   │   
│   │   
│   │   class EmailTemplates:
│   │       """System email templates with proper styling and variables"""
│   │   
│   │       # Base HTML template wrapper for consistent styling
│   │       BASE_TEMPLATE = """<!DOCTYPE html>
│   │   <html lang="en">
│   │   <head>
│   │       <meta charset="UTF-8">
│   │       <meta name="viewport" content="width=device-width, initial-scale=1.0">
│   │       <title>{{ subject }}</title>
│   │       <style>
│   │           body {
│   │               font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
│   │               line-height: 1.6;
│   │               color: #333;
│   │               background-color: #f5f5f5;
│   │               margin: 0;
│   │               padding: 0;
│   │           }
│   │           .container {
│   │               max-width: 600px;
│   │               margin: 0 auto;
│   │               background-color: #ffffff;
│   │               box-shadow: 0 2px 4px rgba(0,0,0,0.1);
│   │           }
│   │           .header {
│   │               background-color: #6B46C1;
│   │               color: #ffffff;
│   │               padding: 30px;
│   │               text-align: center;
│   │           }
│   │           .header h1 {
│   │               margin: 0;
│   │               font-size: 28px;
│   │               font-weight: 600;
│   │           }
│   │           .content {
│   │               padding: 40px 30px;
│   │           }
│   │           .content h2 {
│   │               color: #6B46C1;
│   │               margin-top: 0;
│   │               margin-bottom: 20px;
│   │               font-size: 24px;
│   │           }
│   │           .button {
│   │               display: inline-block;
│   │               padding: 12px 30px;
│   │               background-color: #6B46C1;
│   │               color: #ffffff;
│   │               text-decoration: none;
│   │               border-radius: 5px;
│   │               font-weight: 600;
│   │               margin: 20px 0;
│   │           }
│   │           .button:hover {
│   │               background-color: #553C9A;
│   │           }
│   │           .warning {
│   │               background-color: #FEF3C7;
│   │               border-left: 4px solid #F59E0B;
│   │               padding: 15px;
│   │               margin: 20px 0;
│   │           }
│   │           .error {
│   │               background-color: #FEE2E2;
│   │               border-left: 4px solid #EF4444;
│   │               padding: 15px;
│   │               margin: 20px 0;
│   │           }
│   │           .success {
│   │               background-color: #D1FAE5;
│   │               border-left: 4px solid #10B981;
│   │               padding: 15px;
│   │               margin: 20px 0;
│   │           }
│   │           .metric {
│   │               background-color: #F3F4F6;
│   │               padding: 20px;
│   │               border-radius: 5px;
│   │               margin: 15px 0;
│   │           }
│   │           .metric-value {
│   │               font-size: 32px;
│   │               font-weight: bold;
│   │               color: #6B46C1;
│   │               margin: 5px 0;
│   │           }
│   │           .metric-label {
│   │               color: #6B7280;
│   │               font-size: 14px;
│   │           }
│   │           .footer {
│   │               background-color: #F9FAFB;
│   │               padding: 30px;
│   │               text-align: center;
│   │               font-size: 14px;
│   │               color: #6B7280;
│   │           }
│   │           .footer a {
│   │               color: #6B46C1;
│   │               text-decoration: none;
│   │           }
│   │           .unsubscribe {
│   │               margin-top: 20px;
│   │               font-size: 12px;
│   │           }
│   │           table {
│   │               width: 100%;
│   │               border-collapse: collapse;
│   │               margin: 20px 0;
│   │           }
│   │           th, td {
│   │               padding: 12px;
│   │               text-align: left;
│   │               border-bottom: 1px solid #E5E7EB;
│   │           }
│   │           th {
│   │               background-color: #F9FAFB;
│   │               font-weight: 600;
│   │               color: #374151;
│   │           }
│   │           .list-item {
│   │               padding: 10px 0;
│   │               border-bottom: 1px solid #E5E7EB;
│   │           }
│   │           .list-item:last-child {
│   │               border-bottom: none;
│   │           }
│   │       </style>
│   │   </head>
│   │   <body>
│   │       <div class="container">
│   │           <div class="header">
│   │               <h1>{{ platform_name }}</h1>
│   │           </div>
│   │           <div class="content">
│   │               {% block content %}{% endblock %}
│   │           </div>
│   │           <div class="footer">
│   │               <p>Need help? <a href="{{ support_url }}">Contact our support team</a></p>
│   │               <p class="unsubscribe">
│   │                   <a href="{{ unsubscribe_url }}">Unsubscribe from these emails</a>
│   │               </p>
│   │               <p>&copy; {{ current_year }} {{ platform_name }}. All rights reserved.</p>
│   │           </div>
│   │       </div>
│   │   </body>
│   │   </html>"""
│   │   
│   │       TEMPLATES = {
│   │           "welcome": {
│   │               "subject": "Welcome to {{ platform_name }}, {{ shop_name }}! 🎉",
│   │               "body": """
│   │   <h2>Welcome aboard, {{ shop_name }}!</h2>
│   │   
│   │   <p>We're thrilled to have you join the {{ platform_name }} family! Your shop <strong>{{ merchant_domain }}</strong> is now connected and ready to transform your product imagery.</p>
│   │   
│   │   <div class="success">
│   │       <strong>✅ Setup Complete!</strong><br>
│   │       Your shop is successfully connected and ready to start creating stunning product visuals.
│   │   </div>
│   │   
│   │   <h3>What's Next?</h3>
│   │   
│   │   <div class="list-item">
│   │       <strong>1. Import Your Products</strong><br>
│   │       We'll automatically sync your product catalog to get you started quickly.
│   │   </div>
│   │   
│   │   <div class="list-item">
│   │       <strong>2. Create Your First Visual</strong><br>
│   │       Use our AI-powered tools to generate professional product images and social media content.
│   │   </div>
│   │   
│   │   <div class="list-item">
│   │       <strong>3. Explore Features</strong><br>
│   │       Discover background removal, image enhancement, and batch processing capabilities.
│   │   </div>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ platform_name|lower }}.com/dashboard" class="button">Go to Dashboard</a>
│   │   </p>
│   │   
│   │   <p>If you have any questions, our support team is here to help you get the most out of {{ platform_name }}.</p>
│   │   
│   │   <p>Here's to creating amazing visuals together! 🚀</p>
│   │   
│   │   <p><strong>The {{ platform_name }} Team</strong></p>
│   │   """,
│   │               "variables": {
│   │                   "required": ["shop_name", "merchant_domain"],
│   │                   "optional": ["merchant_id"],
│   │               },
│   │           },
│   │           "registration_finish": {
│   │               "subject": "✅ Product Import Complete - {{ product_count }} Products Ready!",
│   │               "body": """
│   │   <h2>Product Import Successful!</h2>
│   │   
│   │   <p>Great news! We've successfully imported your products to {{ platform_name }}.</p>
│   │   
│   │   <div class="metric">
│   │       <div class="metric-value">{{ product_count }}</div>
│   │       <div class="metric-label">Products Imported</div>
│   │   </div>
│   │   
│   │   <p>Your products are now ready for:</p>
│   │   <ul>
│   │       <li>✨ AI-powered background removal</li>
│   │       <li>🎨 Professional image enhancement</li>
│   │       <li>📱 Social media content creation</li>
│   │       <li>🚀 Batch processing and automation</li>
│   │   </ul>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ platform_name|lower }}.com/products" class="button">View Your Products</a>
│   │   </p>
│   │   
│   │   <p>Tip: Start with your best-selling products to maximize impact!</p>
│   │   """,
│   │               "variables": {"required": ["product_count"], "optional": []},
│   │           },
│   │           "registration_sync": {
│   │               "subject": "📊 Product Sync Update - {{ added_count + updated_count }} Changes Detected",
│   │               "body": """
│   │   <h2>Product Catalog Sync Complete</h2>
│   │   
│   │   <p>We've just finished syncing your product catalog with the latest changes from your shop.</p>
│   │   
│   │   <h3>Sync Summary</h3>
│   │   
│   │   <table>
│   │       <tr>
│   │           <th>Action</th>
│   │           <th>Count</th>
│   │       </tr>
│   │       <tr>
│   │           <td>✅ New Products Added</td>
│   │           <td><strong>{{ added_count }}</strong></td>
│   │       </tr>
│   │       <tr>
│   │           <td>🔄 Products Updated</td>
│   │           <td><strong>{{ updated_count }}</strong></td>
│   │       </tr>
│   │       {% if removed_count %}
│   │       <tr>
│   │           <td>🗑️ Products Removed</td>
│   │           <td><strong>{{ removed_count }}</strong></td>
│   │       </tr>
│   │       {% endif %}
│   │   </table>
│   │   
│   │   {% if added_count > 0 %}
│   │   <div class="success">
│   │       <strong>New Products Ready!</strong><br>
│   │       Your {{ added_count }} new products are ready for visual content creation.
│   │   </div>
│   │   {% endif %}
│   │   
│   │   <p>All changes have been automatically applied to your {{ platform_name }} catalog.</p>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ platform_name|lower }}.com/products?filter=recent" class="button">View Updated Products</a>
│   │   </p>
│   │   """,
│   │               "variables": {
│   │                   "required": ["added_count", "updated_count"],
│   │                   "optional": ["removed_count"],
│   │               },
│   │           },
│   │           "billing_expired": {
│   │               "subject": "⚠️ Subscription Expired - Action Required",
│   │               "body": """
│   │   <h2>Your Subscription Has Expired</h2>
│   │   
│   │   <div class="error">
│   │       <strong>Important:</strong> Your {{ plan_name }} subscription has expired. Your account features are currently limited.
│   │   </div>
│   │   
│   │   <p>To continue enjoying all {{ platform_name }} features, please renew your subscription.</p>
│   │   
│   │   <h3>What This Means:</h3>
│   │   <ul>
│   │       <li>❌ New image generation is paused</li>
│   │       <li>❌ Batch processing is unavailable</li>
│   │       <li>❌ API access is suspended</li>
│   │       <li>✅ Your existing images remain accessible</li>
│   │       <li>✅ Your product catalog is preserved</li>
│   │   </ul>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ renewal_link }}" class="button">Renew Subscription</a>
│   │   </p>
│   │   
│   │   <p>Don't lose your momentum! Renew now to continue creating amazing product visuals.</p>
│   │   
│   │   <p>If you have any questions about your subscription or need assistance, please contact our support team.</p>
│   │   """,
│   │               "variables": {"required": ["plan_name", "renewal_link"], "optional": []},
│   │           },
│   │           "billing_changed": {
│   │               "subject": "✅ Subscription Updated to {{ plan_name }}",
│   │               "body": """
│   │   <h2>Subscription Successfully Updated</h2>
│   │   
│   │   <div class="success">
│   │       <strong>Confirmed!</strong> You're now on the {{ plan_name }} plan.
│   │   </div>
│   │   
│   │   <p>Your subscription has been updated and all features associated with your new plan are now active.</p>
│   │   
│   │   <h3>What's Included in {{ plan_name }}:</h3>
│   │   <div class="metric">
│   │       <p>✅ Enhanced processing limits<br>
│   │       ✅ Priority support<br>
│   │       ✅ Advanced features<br>
│   │       ✅ API access<br>
│   │       ✅ Bulk operations</p>
│   │   </div>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ platform_name|lower }}.com/billing" class="button">View Billing Details</a>
│   │   </p>
│   │   
│   │   <p>Thank you for choosing {{ platform_name }}! We're excited to support your business growth.</p>
│   │   """,
│   │               "variables": {"required": ["plan_name"], "optional": []},
│   │           },
│   │           "billing_low_credits": {
│   │               "subject": "⚠️ Low Credit Balance - {{ days_remaining }} Days Remaining",
│   │               "body": """
│   │   <h2>Credit Balance Running Low</h2>
│   │   
│   │   <div class="warning">
│   │       <strong>Attention Required:</strong> Your credit balance is running low and may be depleted soon.
│   │   </div>
│   │   
│   │   <h3>Current Status:</h3>
│   │   
│   │   <div class="metric">
│   │       <div class="metric-value">${{ current_balance }}</div>
│   │       <div class="metric-label">Current Balance</div>
│   │   </div>
│   │   
│   │   <table>
│   │       <tr>
│   │           <td><strong>Estimated Days Remaining:</strong></td>
│   │           <td>{{ days_remaining }} days</td>
│   │       </tr>
│   │       <tr>
│   │           <td><strong>Expected Depletion Date:</strong></td>
│   │           <td>{{ expected_depletion_date }}</td>
│   │       </tr>
│   │   </table>
│   │   
│   │   <p>To ensure uninterrupted service, please add credits to your account before they run out.</p>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ billing_link }}" class="button">Add Credits Now</a>
│   │   </p>
│   │   
│   │   <h3>What Happens When Credits Run Out?</h3>
│   │   <ul>
│   │       <li>Image generation will be paused</li>
│   │       <li>API requests will be limited</li>
│   │       <li>Batch operations will be unavailable</li>
│   │   </ul>
│   │   
│   │   <p>Don't let your creative flow stop! Add credits now to continue creating amazing visuals.</p>
│   │   """,
│   │               "variables": {
│   │                   "required": [
│   │                       "current_balance",
│   │                       "days_remaining",
│   │                       "expected_depletion_date",
│   │                       "billing_link",
│   │                   ],
│   │                   "optional": [],
│   │               },
│   │           },
│   │           "billing_zero_balance": {
│   │               "subject": "🚨 Urgent: Zero Balance - Service Deactivation Pending",
│   │               "body": """
│   │   <h2>Your Credit Balance is Now Zero</h2>
│   │   
│   │   <div class="error">
│   │       <strong>Immediate Action Required!</strong><br>
│   │       Your credit balance has reached zero. Services will be deactivated at <strong>{{ deactivation_time }}</strong>.
│   │   </div>
│   │   
│   │   <p>To prevent service interruption, please add credits to your account immediately.</p>
│   │   
│   │   <div class="metric">
│   │       <div class="metric-value">$0.00</div>
│   │       <div class="metric-label">Current Balance</div>
│   │   </div>
│   │   
│   │   <h3>⏰ Deactivation Timeline:</h3>
│   │   <p><strong>{{ deactivation_time }}</strong> - All premium features will be disabled</p>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ billing_link }}" class="button">Add Credits Urgently</a>
│   │   </p>
│   │   
│   │   <h3>Services at Risk:</h3>
│   │   <ul>
│   │       <li>❌ Image generation and processing</li>
│   │       <li>❌ API access</li>
│   │       <li>❌ Batch operations</li>
│   │       <li>❌ New product imports</li>
│   │   </ul>
│   │   
│   │   <p><strong>Act now to avoid disruption to your workflow!</strong></p>
│   │   """,
│   │               "variables": {
│   │                   "required": ["deactivation_time", "billing_link"],
│   │                   "optional": [],
│   │               },
│   │           },
│   │           "billing_deactivated": {
│   │               "subject": "❌ Services Deactivated - {{ reason|title }}",
│   │               "body": """
│   │   <h2>Services Have Been Deactivated</h2>
│   │   
│   │   <div class="error">
│   │       <strong>Service Status:</strong> Your {{ platform_name }} services have been deactivated due to <strong>{{ reason }}</strong>.
│   │   </div>
│   │   
│   │   <h3>Currently Unavailable:</h3>
│   │   <ul>
│   │       <li>❌ Image generation and processing</li>
│   │       <li>❌ API access</li>
│   │       <li>❌ Batch operations</li>
│   │       <li>❌ Product catalog updates</li>
│   │   </ul>
│   │   
│   │   <h3>Still Available:</h3>
│   │   <ul>
│   │       <li>✅ Access to existing images</li>
│   │       <li>✅ Download your data</li>
│   │       <li>✅ View your product catalog</li>
│   │       <li>✅ Account settings</li>
│   │   </ul>
│   │   
│   │   <p>To restore full access to all features, please resolve the billing issue.</p>
│   │   
│   │   <p style="text-align: center; margin-top: 30px;">
│   │       <a href="{{ reactivation_link }}" class="button">Reactivate Services</a>
│   │   </p>
│   │   
│   │   <p>We value your business and hope to have you back soon. If you need assistance or have questions about your account, our support team is here to help.</p>
│   │   """,
│   │               "variables": {"required": ["reason", "reactivation_link"], "optional": []},
│   │           },
│   │       }
│   │   
│   │       @classmethod
│   │       def get_template(cls, notification_type: str) -> Dict[str, Any]:
│   │           """Get template for notification type"""
│   │           if notification_type not in cls.TEMPLATES:
│   │               raise ValueError(f"Unknown notification type: {notification_type}")
│   │   
│   │           template = cls.TEMPLATES[notification_type].copy()
│   │   
│   │           # Wrap body in base template
│   │           template["body"] = cls.BASE_TEMPLATE.replace(
│   │               "{% block content %}{% endblock %}", template["body"]
│   │           )
│   │   
│   │           return template
│   │   
│   │       @classmethod
│   │       def get_all_types(cls) -> list:
│   │           """Get all available notification types"""
│   │           return list(cls.TEMPLATES.keys())
│   │   
│   │       @classmethod
│   │       def validate_variables(
│   │           cls, notification_type: str, provided_variables: Dict[str, Any]
│   │       ) -> Dict[str, Any]:
│   │           """Validate that required variables are provided"""
│   │           if notification_type not in cls.TEMPLATES:
│   │               raise ValueError(f"Unknown notification type: {notification_type}")
│   │   
│   │           template_vars = cls.TEMPLATES[notification_type]["variables"]
│   │           required = set(template_vars["required"])
│   │           optional = set(template_vars["optional"])
│   │           provided = set(provided_variables.keys())
│   │   
│   │           # Global variables that are always available
│   │           global_vars = {
│   │               "unsubscribe_url",
│   │               "support_url",
│   │               "current_year",
│   │               "platform_name",
│   │           }
│   │   
│   │           missing_required = required - provided
│   │           unused_variables = provided - required - optional - global_vars
│   │   
│   │           return {
│   │               "is_valid": len(missing_required) == 0,
│   │               "missing_required": list(missing_required),
│   │               "unused_variables": list(unused_variables),
│   │               "all_variables": list(required | optional | global_vars),
│   │           }
│   │   ```
│   │   
│   └── template_renderer.py
│       
│       ```py
│       # services/notification-service/src/services/template_service.py
│       """
│       Template Service - File-based implementation
│       
│       Responsibilities:
│       1. Load templates from EmailTemplates class (file-based)
│       2. Validate required variables
│       3. Render templates using Jinja2
│       4. Generate plain text versions
│       5. Provide template preview functionality
│       """
│       
│       from typing import Dict, Any, Optional, Tuple, List
│       from datetime import datetime
│       import html2text
│       from jinja2 import Environment, TemplateError, select_autoescape, meta
│       
│       from shared.utils.logger import ServiceLogger
│       from ..templates.email_templates import EmailTemplates
│       from ..exceptions import (
│           TemplateNotFoundError,
│           TemplateRenderError,
│           ValidationError,
│       )
│       
│       
│       class TemplateService:
│           """
│           Service for managing and rendering file-based email templates.
│           All templates are defined in EmailTemplates class.
│           """
│       
│           def __init__(self, config: Dict[str, Any], logger: ServiceLogger):
│               """
│               Initialize template service
│       
│               Args:
│                   config: Service configuration containing URLs
│                   logger: Service logger
│               """
│               self.config = config
│               self.logger = logger
│       
│               # Initialize Jinja2 environment
│               self.env = Environment(
│                   autoescape=select_autoescape(["html", "xml"]),
│                   trim_blocks=True,
│                   lstrip_blocks=True,
│               )
│       
│               # Initialize html2text for plain text conversion
│               self.html2text = html2text.HTML2Text()
│               self.html2text.ignore_links = False
│               self.html2text.ignore_images = True
│               self.html2text.body_width = 78
│       
│               # Cache compiled templates
│               self._template_cache: Dict[str, Any] = {}
│       
│           async def get_template_for_type(
│               self, notification_type: str
│           ) -> Optional[Dict[str, Any]]:
│               """
│               Get template data for a specific notification type
│       
│               Args:
│                   notification_type: Type of notification (e.g., 'welcome', 'billing_expired')
│       
│               Returns:
│                   Template data or None if not found
│               """
│               try:
│                   template_data = EmailTemplates.get_template(notification_type)
│                   return {
│                       "type": notification_type,
│                       "subject": template_data["subject"],
│                       "body": template_data["body"],
│                       "variables": template_data["variables"],
│                   }
│               except ValueError:
│                   self.logger.warning(f"Template not found for type: {notification_type}")
│                   return None
│       
│           async def render_template(
│               self,
│               template: Dict[str, Any],
│               dynamic_content: Dict[str, Any],
│               unsubscribe_token: Optional[str] = None,
│           ) -> Tuple[str, str, str]:
│               """
│               Render email template with provided variables
│       
│               Args:
│                   template: Template data from get_template_for_type
│                   dynamic_content: Variables to inject into template
│                   unsubscribe_token: Token for unsubscribe URL (optional for non-marketing)
│       
│               Returns:
│                   Tuple of (subject, html_body, text_body)
│       
│               Raises:
│                   ValidationError: If required variables are missing
│                   TemplateRenderError: If template rendering fails
│               """
│               notification_type = template["type"]
│       
│               # Validate required variables
│               validation = self._validate_variables(template, dynamic_content)
│               if not validation["is_valid"]:
│                   raise ValidationError(
│                       f"Missing required variables for {notification_type}: {validation['missing_required']}"
│                   )
│       
│               # Log unused variables as warning
│               if validation["unused_variables"]:
│                   self.logger.warning(
│                       f"Unused variables in {notification_type} template",
│                       extra={
│                           "notification_type": notification_type,
│                           "unused_variables": validation["unused_variables"],
│                       },
│                   )
│       
│               # Prepare context with global and dynamic variables
│               context = self._prepare_context(dynamic_content, unsubscribe_token)
│       
│               try:
│                   # Render subject
│                   subject_template = self._get_or_compile_template(
│                       f"{notification_type}_subject", template["subject"]
│                   )
│                   subject = subject_template.render(**context)
│       
│                   # Render HTML body
│                   body_template = self._get_or_compile_template(
│                       f"{notification_type}_body", template["body"]
│                   )
│                   html_body = body_template.render(**context)
│       
│                   # Generate plain text version
│                   text_body = self.html2text.handle(html_body)
│       
│                   self.logger.info(
│                       f"Successfully rendered {notification_type} template",
│                       extra={"notification_type": notification_type},
│                   )
│       
│                   return subject, html_body, text_body
│       
│               except TemplateError as e:
│                   self.logger.error(
│                       f"Template rendering failed for {notification_type}",
│                       extra={"notification_type": notification_type, "error": str(e)},
│                   )
│                   raise TemplateRenderError(
│                       f"Failed to render {notification_type} template: {e}",
│                       template_name=notification_type,
│                       render_error=str(e),
│                   )
│       
│           def _prepare_context(
│               self, dynamic_content: Dict[str, Any], unsubscribe_token: Optional[str] = None
│           ) -> Dict[str, Any]:
│               """Prepare template context with global and dynamic variables"""
│       
│               # Global variables available in all templates
│               global_vars = {
│                   "platform_name": "GlamYouUp",
│                   "current_year": datetime.now().year,
│                   "support_url": self.config.get(
│                       "support_url", "https://support.glamyouup.com"
│                   ),
│               }
│       
│               # Add unsubscribe URL only if token is provided (marketing emails)
│               if unsubscribe_token:
│                   app_url = self.config.get("app_url", "https://app.glamyouup.com")
│                   global_vars["unsubscribe_url"] = (
│                       f"{app_url}/unsubscribe/{unsubscribe_token}"
│                   )
│               else:
│                   # For non-marketing emails, provide empty string to avoid template errors
│                   global_vars["unsubscribe_url"] = ""
│       
│               # Merge global and dynamic variables
│               return {**global_vars, **dynamic_content}
│       
│           def _validate_variables(
│               self, template: Dict[str, Any], provided_variables: Dict[str, Any]
│           ) -> Dict[str, Any]:
│               """Validate that all required variables are provided"""
│       
│               template_vars = template["variables"]
│               required = set(template_vars["required"])
│               optional = set(template_vars["optional"])
│       
│               # Global variables that are always available
│               global_vars = {
│                   "platform_name",
│                   "current_year",
│                   "support_url",
│                   "unsubscribe_url",
│               }
│       
│               # Variables provided
│               provided = set(provided_variables.keys()) | global_vars
│       
│               # Check for missing required variables
│               missing_required = required - provided
│       
│               # Check for unused variables (excluding globals)
│               all_expected = required | optional | global_vars
│               unused = set(provided_variables.keys()) - all_expected
│       
│               return {
│                   "is_valid": len(missing_required) == 0,
│                   "missing_required": list(missing_required),
│                   "unused_variables": list(unused),
│                   "all_variables": list(all_expected),
│               }
│       
│           def _get_or_compile_template(self, cache_key: str, template_string: str):
│               """Get compiled template from cache or compile and cache it"""
│               if cache_key not in self._template_cache:
│                   self._template_cache[cache_key] = self.env.from_string(template_string)
│               return self._template_cache[cache_key]
│       
│           async def preview_template(
│               self, notification_type: str, sample_data: Optional[Dict[str, Any]] = None
│           ) -> Dict[str, Any]:
│               """
│               Preview template with sample data
│       
│               Args:
│                   notification_type: Type of notification to preview
│                   sample_data: Optional sample data, uses defaults if not provided
│       
│               Returns:
│                   Preview data including rendered content and validation info
│               """
│               # Get template
│               template = await self.get_template_for_type(notification_type)
│               if not template:
│                   return {
│                       "error": f"Template not found for type: {notification_type}",
│                       "notification_type": notification_type,
│                   }
│       
│               # Use default sample data if none provided
│               if sample_data is None:
│                   sample_data = self._get_default_sample_data(notification_type)
│       
│               # Use dummy token for preview
│               dummy_token = "preview_token_123456"
│       
│               try:
│                   # Render template
│                   subject, html_body, text_body = await self.render_template(
│                       template, sample_data, dummy_token
│                   )
│       
│                   # Get validation info
│                   validation = self._validate_variables(template, sample_data)
│       
│                   return {
│                       "subject": subject,
│                       "body_html": html_body,
│                       "body_text": text_body,
│                       "missing_variables": validation["missing_required"],
│                       "unused_variables": validation["unused_variables"],
│                       "all_variables": validation["all_variables"],
│                       "sample_data_used": sample_data,
│                       "notification_type": notification_type,
│                   }
│       
│               except Exception as e:
│                   return {
│                       "error": str(e),
│                       "notification_type": notification_type,
│                       "sample_data_used": sample_data,
│                   }
│       
│           def _get_default_sample_data(self, notification_type: str) -> Dict[str, Any]:
│               """Get default sample data for template preview"""
│       
│               defaults = {
│                   "welcome": {
│                       "shop_name": "Example Fashion Store",
│                       "merchant_domain": "example-store.myshopify.com",
│                   },
│                   "registration_finish": {"product_count": 150},
│                   "registration_sync": {
│                       "added_count": 25,
│                       "updated_count": 10,
│                       "removed_count": 5,
│                   },
│                   "billing_expired": {
│                       "plan_name": "Professional Plan",
│                       "renewal_link": "https://app.glamyouup.com/billing/renew",
│                   },
│                   "billing_changed": {"plan_name": "Enterprise Plan"},
│                   "billing_low_credits": {
│                       "current_balance": "125.50",
│                       "days_remaining": 5,
│                       "expected_depletion_date": "January 20, 2025",
│                       "billing_link": "https://app.glamyouup.com/billing",
│                   },
│                   "billing_zero_balance": {
│                       "deactivation_time": "January 16, 2025 at 2:00 AM UTC",
│                       "billing_link": "https://app.glamyouup.com/billing",
│                   },
│                   "billing_deactivated": {
│                       "reason": "insufficient credits",
│                       "reactivation_link": "https://app.glamyouup.com/billing/reactivate",
│                   },
│               }
│       
│               return defaults.get(
│                   notification_type, {"content": "Sample notification content"}
│               )
│       
│           def validate_template_syntax(self, subject: str, body: str) -> Dict[str, Any]:
│               """
│               Validate Jinja2 template syntax
│       
│               Args:
│                   subject: Subject template string
│                   body: Body template string
│       
│               Returns:
│                   Validation results with errors and warnings
│               """
│               errors = []
│               warnings = []
│       
│               # Validate subject template
│               try:
│                   subject_ast = self.env.parse(subject)
│                   subject_vars = meta.find_undeclared_variables(subject_ast)
│               except TemplateError as e:
│                   errors.append(f"Subject template error: {str(e)}")
│       
│               # Validate body template
│               try:
│                   body_ast = self.env.parse(body)
│                   body_vars = meta.find_undeclared_variables(body_ast)
│               except TemplateError as e:
│                   errors.append(f"Body template error: {str(e)}")
│       
│               # Check for common issues
│               if "{{" in subject + body and not "}}" in subject + body:
│                   warnings.append("Possible unclosed variable tag detected")
│       
│               if "{%" in subject + body and not "%}" in subject + body:
│                   warnings.append("Possible unclosed block tag detected")
│       
│               return {
│                   "is_valid": len(errors) == 0,
│                   "syntax_errors": errors,
│                   "warnings": warnings,
│               }
│       
│           def get_available_types(self) -> List[str]:
│               """Get list of all available notification types"""
│               return EmailTemplates.get_all_types()
│       
│           def clear_template_cache(self):
│               """Clear the compiled template cache"""
│               self._template_cache.clear()
│               self.logger.info("Template cache cleared")
│       
│       
│       # Example usage
│       """
│       # Initialize service
│       config = {
│           'app_url': 'https://app.glamyouup.com',
│           'support_url': 'https://support.glamyouup.com'
│       }
│       template_service = TemplateService(config, logger)
│       
│       # Get and render a template
│       template = await template_service.get_template_for_type('welcome')
│       if template:
│           subject, html, text = await template_service.render_template(
│               template,
│               {'shop_name': 'My Shop', 'merchant_domain': 'myshop.com'},
│               unsubscribe_token='abc123'  # Only for marketing emails
│           )
│       
│       # Preview a template
│       preview = await template_service.preview_template('billing_expired')
│       print(preview['subject'])
│       """
│       ```
│       
├── __init__.py
├── config.py
│   
│   ```py
│   from functools import lru_cache
│   import os
│   from typing import List, Optional
│   from pydantic import BaseModel, Field
│   from shared.config.loader import merged_config, flatten_config
│   from shared.database import DatabaseConfig, create_database_config
│   
│   
│   class ServiceConfig(BaseModel):
│       # Service Identity (from shared + service YAML)
│       service_name: str = Field(..., alias="service.name")
│       service_version: str = Field(..., alias="service.version")
│       environment: str
│       debug: bool
│       
│       # API Configuration (from shared + service YAML)
│       api_host: str = Field(..., alias="api.host")
│       api_port: int = Field(..., alias="api.port")
│       api_external_port: int = Field(..., alias="api.external_port")  # Local development port
│       api_cors_origins: List[str] = Field(..., alias="api.cors_origins")
│       
│       # Infrastructure (from shared YAML)
│       infrastructure_nats_url: str = Field(..., alias="infrastructure.nats_url")
│       infrastructure_redis_url: str = Field(..., alias="infrastructure.redis_url")
│       
│       # Database Configuration
│       db_enabled: bool = Field(..., alias="database.enabled")
│       
│       # Logging (from shared YAML)
│       logging_level: str = Field(..., alias="logging.level")
│       logging_format: str = Field(..., alias="logging.format")
│       
│       # Email Configuration (from shared + service YAML)
│       email_primary_provider: str = Field(..., alias="email.primary_provider")
│       email_fallback_provider: str = Field(..., alias="email.fallback_provider")
│       email_from_domain: str = Field(..., alias="email.from_domain")
│       email_smtp_port: int = Field(..., alias="email.smtp_port")
│       
│       # AWS (from shared YAML)
│       aws_region: str = Field(..., alias="aws.region")
│       
│       # Rate Limiting (from shared + service YAML)
│       rate_limiting_enabled: bool = Field(..., alias="rate_limiting.enabled")
│       rate_limiting_window_seconds: int = Field(..., alias="rate_limiting.window_seconds")
│       rate_limiting_per_hour: int = Field(..., alias="rate_limiting.per_hour")
│       rate_limiting_per_day: int = Field(..., alias="rate_limiting.per_day")
│       
│       # Monitoring (from shared YAML)
│       monitoring_metrics_enabled: bool = Field(..., alias="monitoring.metrics_enabled")
│       monitoring_tracing_enabled: bool = Field(..., alias="monitoring.tracing_enabled")
│       
│       # Template Configuration (service-specific)
│       template_max_size: int = Field(..., alias="template.max_size")
│       template_render_timeout: int = Field(..., alias="template.render_timeout")
│       
│       # Retry Configuration (service-specific)
│       retry_max_attempts: int = Field(..., alias="retry.max_attempts")
│       retry_initial_delay_ms: int = Field(..., alias="retry.initial_delay_ms")
│       retry_max_delay_ms: int = Field(..., alias="retry.max_delay_ms")
│       
│       # Bulk Email Configuration (service-specific)
│       bulk_email_default_batch_size: int = Field(..., alias="bulk_email.default_batch_size")
│       bulk_email_max_batch_size: int = Field(..., alias="bulk_email.max_batch_size")
│       bulk_email_min_batch_size: int = Field(..., alias="bulk_email.min_batch_size")
│       bulk_email_batch_delay_seconds: float = Field(..., alias="bulk_email.batch_delay_seconds")
│       bulk_email_max_delay_seconds: float = Field(..., alias="bulk_email.max_delay_seconds")
│       bulk_email_concurrent_batches: int = Field(..., alias="bulk_email.concurrent_batches")
│       
│       # External Services (env-only, optional)
│       sendgrid_api_key: Optional[str] = None
│       aws_access_key_id: Optional[str] = None
│       aws_secret_access_key: Optional[str] = None
│       smtp_host: Optional[str] = None
│       smtp_username: Optional[str] = None
│       smtp_password: Optional[str] = None
│       email_from_address: Optional[str] = None
│       email_from_name: Optional[str] = None
│       
│       @property
│       def database_config(self) -> DatabaseConfig:
│           """Get database configuration"""
│           return create_database_config(prefix="NOTIFICATION_")
│       
│       @property
│       def effective_port(self) -> int:
│           """
│           Get the effective port to use based on environment.
│           
│           Logic:
│           - Local development (not in Docker): use external_port
│           - Docker/container environment: use internal port
│           - Environment override: NOTIFICATION_USE_EXTERNAL_PORT=true forces external_port
│           """
│           # Check if explicitly requested to use external port
│           use_external = os.getenv("NOTIFICATION_USE_EXTERNAL_PORT", "false").lower() == "true"
│   
│           # Check if running in container (common Docker environment variables)
│           in_container = any([
│               os.getenv("DOCKER_CONTAINER"),
│               os.getenv("HOSTNAME", "").startswith("notification-service"),
│               os.path.exists("/.dockerenv")
│           ])
│           
│           if use_external or (not in_container and self.environment == "development"):
│               return self.api_external_port
│           else:
│               return self.api_port
│   
│   
│   @lru_cache
│   def get_service_config() -> ServiceConfig:
│       """Load and cache service configuration"""
│       cfg_dict = merged_config("notification", env_prefix="NOTIFICATION")
│       flattened = flatten_config(cfg_dict)
│       return ServiceConfig(**flattened) #type: ingnore
│   ```
│   
├── dependencies.py
│   
│   ```py
│   # services/notification-service/src/dependencies.py
│   
│   """
│   FastAPI dependency providers with type aliases for cleaner code.
│   """
│   from typing import Annotated, Any
│   from fastapi import Depends, Request, HTTPException
│   
│   from shared.api.dependencies import RequestIdDep, RequestContextDep, PaginationDep, CorrelationIdDep
│   
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   from .lifecycle import ServiceLifecycle
│   from .services.notification_service import NotificationService
│   from .services.template_service import TemplateService
│   from .services.email_service import EmailService
│   from .events.publishers import NotificationEventPublisher
│   
│   # ---------------------------------------------------------------- shared --- #
│   # Re-export shared dependencies for convenience
│   __all__ = [
│       # Shared deps (re-exported)
│       "RequestIdDep", 
│       "RequestContextDep", 
│       "PaginationDep", 
│       "CorrelationIdDep",
│       
│       # Core deps
│       "LifecycleDep",
│       "ConfigDep",
│       
│       # Messaging deps
│       "MessagingDep",
│       "PublisherDep",
│       
│       # Service deps
│       "NotificationServiceDep",
│       "TemplateServiceDep",
│       "EmailServiceDep",
│   ]
│   
│   # --------------------------- core singletons via lifecycle ----------------- #
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       return request.app.state.lifecycle                 
│   
│   def get_config(request: Request):
│       return request.app.state.config                   
│   
│   # Type aliases for core dependencies
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[Any, Depends(get_config)]  # Replace Any with your Config type
│   
│   # ------------------------------- messaging --------------------------------- #
│   def get_messaging_wrapper(lifecycle: LifecycleDep) -> JetStreamWrapper:
│       if not lifecycle.messaging_wrapper:
│           raise HTTPException(500, "Messaging not initialized")
│       return lifecycle.messaging_wrapper
│   
│   def get_publisher(wrapper: "MessagingDep") -> NotificationEventPublisher:
│       pub = wrapper.get_publisher(NotificationEventPublisher)
│       if not pub:
│           raise HTTPException(500, "NotificationEventPublisher not initialized")
│       return pub
│   
│   # Type aliases for messaging
│   MessagingDep = Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)]
│   PublisherDep = Annotated[NotificationEventPublisher, Depends(get_publisher)]
│   
│   # --------------------------------- utils ----------------------------------- #
│   
│   def get_email_service(lifecycle: LifecycleDep) -> EmailService:
│       if not lifecycle.email_service:
│           raise HTTPException(500, "EmailService not initialized")
│       return lifecycle.email_service
│   
│   
│   # Type aliases for utils
│   EmailServiceDep = Annotated[EmailService, Depends(get_email_service)]
│   
│   # --------------------------- domain services ------------------------------- #
│   def get_template_service(lifecycle: LifecycleDep) -> TemplateService:
│       if not lifecycle.template_service:
│           raise HTTPException(500, "TemplateService not initialized")
│       return lifecycle.template_service
│   
│   
│   def get_notification_service(lifecycle: LifecycleDep) -> NotificationService:
│       if not lifecycle.notification_service:
│           raise HTTPException(500, "NotificationService not initialized")
│       return lifecycle.notification_service
│   
│   
│   # Type aliases for domain services
│   TemplateServiceDep = Annotated[TemplateService, Depends(get_template_service)]
│   NotificationServiceDep = Annotated[NotificationService, Depends(get_notification_service)]
│   ```
│   
├── exceptions.py
│   
│   ```py
│   # File: services/notification-service/src/exceptions.py
│   """
│   Notification service exceptions using shared error classes.
│   
│   All exceptions are re-exported from shared.errors for consistency
│   across the platform.
│   """
│   
│   from shared.errors.notification import (
│       NotificationNotFoundError,
│       TemplateNotFoundError,
│       TemplateRenderError,
│       InvalidRecipientError,
│       PreferencesNotFoundError,
│       EmailProviderError,
│       UnsubscribedError,
│   )
│   from shared.errors.base import (
│       RateLimitedError,
│       ValidationError,
│       ConflictError,
│       DomainError,
│   )
│   
│   # Re-export all notification errors for convenience
│   __all__ = [
│       # From shared.errors.notification
│       "NotificationNotFoundError",
│       "TemplateNotFoundError",
│       "TemplateRenderError",
│       "InvalidRecipientError",
│       "PreferencesNotFoundError",
│       "EmailProviderError",
│       "UnsubscribedError",
│       # From shared.errors.base
│       "RateLimitedError",
│       "ValidationError",
│       "ConflictError",
│   ]
│   
│   
│   # Custom error for duplicate template name
│   class DuplicateTemplateName(ConflictError):
│       """Template name already exists."""
│   
│       def __init__(self, message: str, template_name: str):
│           super().__init__(
│               message,
│               conflicting_resource="template",
│               current_state=f"Template with name '{template_name}' already exists",
│           )
│   
│   
│   class PreferenceAlreadyExists(DomainError):
│       """Raised when trying to create preferences that already exist"""
│   
│       def __init__(self, message: str, merchant_id: str):
│           super().__init__(
│               message=message,
│               code="PREFERENCE_ALREADY_EXISTS",
│               status=409,  # Conflict
│               details={"merchant_id": merchant_id},
│           )
│   
│   
│   class TemplateAlreadyExistsError(DomainError):
│       """Raised when trying to create templat that already exist"""
│   
│       def __init__(self, message: str, template_id: str):
│           super().__init__(
│               message=message,
│               code="TEMPLATE_ALREADY_EXISTS",
│               status=409,
│               details={"template_id": template_id},
│           )
│   
│   
│   class RateLimitExceededError(RateLimitedError):
│       """Rate limit exceeded for notification service"""
│   
│       def __init__(self, message: str, recipient_email: str, notification_type: str):
│           super().__init__(
│               message=message,
│               recipient_email=recipient_email,
│               notification_type=notification_type,
│           )
│   ```
│   
├── lifecycle.py
│   
│   ```py
│   # services/notification_service/src/lifecycle.py
│   """
│   Process-wide lifecycle manager for the Notification Service.
│   
│   • Connects to NATS / JetStream and ensures NOTIFICATION stream exists
│   • Opens async SQLAlchemy engine and auto-creates tables
│   • Builds repositories (DB-backed) + their services
│   • Instantiates NotificationService with all dependencies
│   • Starts JetStream subscribers as background tasks
│   • Cleans everything up on shutdown
│   """
│   
│   from __future__ import annotations
│   
│   import asyncio
│   from typing import List, Optional, cast
│   
│   from nats.js.api import StreamConfig, RetentionPolicy, StorageType
│   
│   from shared.utils.logger import ServiceLogger
│   from shared.database import DatabaseSessionManager, set_database_manager
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   
│   from .config import ServiceConfig
│   from .services.email_service import EmailService
│   from .services.notification_service import NotificationService
│   from .services.template_service   import TemplateService
│   
│   # repositories --------------------------------------------------------------
│   from .repositories.notification_repository import NotificationRepository
│   
│   
│   # models ----------------------------------------------------------------
│   from .models.notification import Notification
│   
│   # events / subs -------------------------------------------------------------
│   from .events.publishers import NotificationEventPublisher
│   from .events.subscribers   import SendEmailSubscriber, SendBulkEmailSubscriber
│   
│   # domain mappers --------------------------------------------------------
│   from .mappers.notification_mapper import NotificationMapper
│   
│   
│   class ServiceLifecycle:
│       """Owns singletons that must exist exactly once per process."""
│   
│       def __init__(self, config: ServiceConfig, logger: ServiceLogger) -> None:
│           self.config = config
│           self.logger = logger
│   
│           # external connections
│           self.messaging_wrapper: Optional[JetStreamWrapper]        = None
│           self.db_manager:        Optional[DatabaseSessionManager]  = None
│   
│           # repositories
│           self.notification_repo: Optional[NotificationRepository] = None
│   
│           # utils / domain services
│           self.email_service:       Optional[EmailService]              = None
│           self.template_service:    Optional[TemplateService]           = None
│           self.notification_service:Optional[NotificationService]     = None
│           self.notification_mapper: Optional[NotificationMapper] = None
│   
│           # bookkeeping
│           self._tasks: List[asyncio.Task] = []
│           self._shutdown_event = asyncio.Event()
│   
│       # ─────────────────────────── FastAPI lifespan hooks ────────────────────
│       async def startup(self) -> None:
│           try:
│               await self._init_messaging()
│               await self._init_database()
│               self._init_repositories()
│               self._init_local_services()
│               await self._init_subscribers()
│               self.logger.info("%s started successfully", self.config.service_name)
│           except Exception:
│               self.logger.critical("Service failed to start")
│               await self.shutdown()
│               raise
│   
│       async def shutdown(self) -> None:
│           self.logger.info("Shutting down %s", self.config.service_name)
│   
│           for t in self._tasks:
│               t.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│   
│           if self.messaging_wrapper:
│               await self.messaging_wrapper.close()
│           if self.db_manager:
│               await self.db_manager.close()
│   
│           self.logger.info("%s shutdown complete", self.config.service_name)
│   
│       # ───────────────────────────── init helpers ────────────────────────────
│       async def _init_messaging(self) -> None:
│           self.messaging_wrapper = JetStreamWrapper(self.logger)
│           await self.messaging_wrapper.connect([self.config.infrastructure_nats_url])
│           self.logger.info("Connected to NATS %s", self.config.infrastructure_nats_url)
│   
│           js = self.messaging_wrapper.js
│           cfg = StreamConfig(
│               name      = "NOTIFICATION",
│               subjects  = ["cmd.notification.*", "evt.notification.*"],
│               retention = RetentionPolicy.LIMITS,
│               max_age   = 7 * 24 * 60 * 60,
│               max_msgs  = 1_000_000,
│               max_bytes = 1_024 ** 3,
│               storage   = StorageType.FILE,
│               duplicate_window = 60,
│           )
│           try:
│               await js.stream_info("NOTIFICATION")
│           except Exception:
│               await js.add_stream(cfg)
│               self.logger.info("Created NOTIFICATION stream")
│   
│       async def _init_database(self) -> None:
│           if not (self.config.db_enabled and self.config.database_config):
│               self.logger.warning("DB disabled; repositories will not be initialised")
│               return
│           
│           print("Database URL:", self.config.database_config.database_url)
│   
│           self.db_manager = DatabaseSessionManager(
│               database_url=self.config.database_config.database_url,
│               echo=self.config.database_config.DB_ECHO,
│               pool_size=self.config.database_config.DB_POOL_SIZE,
│               max_overflow=self.config.database_config.DB_MAX_OVERFLOW,
│           )
│           await self.db_manager.init()
│           set_database_manager(self.db_manager)
│           self.logger.info("Connected to DB")
│   
│           from shared.database.base import Base
│           async with self.db_manager.engine.begin() as conn:
│               await conn.run_sync(Base.metadata.create_all)
│   
│       def _init_repositories(self) -> None:
│           """Create repository singletons (requires DB)."""
│           if not self.db_manager:
│               return
│   
│           session_factory = self.db_manager.session_factory
│           self.notification_repo = NotificationRepository(Notification, session_factory)
│   
│       def _init_local_services(self) -> None:
│   
│           # self.email_service = EmailService(
│           #     {
│           #         "primary_provider":  self.config.email_primary_provider,
│           #         "fallback_provider": self.config.email_fallback_provider,
│           #         "sendgrid_config":   self.config.sendgrid_config.model_dump(),
│           #         "ses_config":        self.config.ses_config.model_dump(),
│           #         "smtp_config":       self.config.smtp_config.model_dump(),
│           #     },
│           #     self.logger,
│           # )
│           
│           self.email_service = EmailService(
│               {
│                   "primary_provider":  self.config.email_primary_provider,
│                   "fallback_provider": self.config.email_fallback_provider,
│                   "sendgrid_config":   {},
│                   "ses_config":        {},
│                   "smtp_config":       {},
│               },
│               self.logger,
│           )
│           
│           self.template_service = TemplateService(
│               config=self.config,
│               logger= self.logger,
│           )
│       
│   
│           if not self.messaging_wrapper:
│               raise RuntimeError("Messaging wrapper is not initialized")
│           
│           publisher = cast(
│               NotificationEventPublisher,
│               self.messaging_wrapper.create_publisher(NotificationEventPublisher),
│           )
│   
│           if not self.notification_repo:
│               raise RuntimeError("Notification repository is not initialized")
│           
│           self.notification_service = NotificationService(
│               config                  = self.config,
│               publisher               = publisher,
│               email_service           = self.email_service,
│               template_service        = self.template_service,
│               notification_repository = self.notification_repo,
│               notification_mapper     = NotificationMapper(),
│               logger                  = self.logger,
│           )
│   
│       async def _init_subscribers(self) -> None:
│           if not self.messaging_wrapper:
│               raise RuntimeError("Messaging wrapper not initialized")
│           
│           # ⚠️ Register deps BEFORE launching subscribers – they may receive a
│           # message immediately after pull_subscribe().
│           self.messaging_wrapper.register_dependency("notification_service", self.notification_service)
│           self.messaging_wrapper.register_dependency("logger", self.logger)
│           
│           # Start subscribers - wrapper provides dependencies
│           await self.messaging_wrapper.start_subscriber(SendEmailSubscriber)
│           await self.messaging_wrapper.start_subscriber(SendBulkEmailSubscriber)
│       # ──────────────────────────── convenience tools ───────────────────────
│       def add_task(self, coro) -> asyncio.Task:
│           t = asyncio.create_task(coro)
│           self._tasks.append(t)
│           return t
│   
│       async def wait_for_shutdown(self) -> None:
│           await self._shutdown_event.wait()
│   
│       def signal_shutdown(self) -> None:
│           self._shutdown_event.set()
│   ```
│   
├── main.py
│   
│   ```py
│   # services/notification-service/src/main.py
│   
│   """Main entry point for the Notification Service"""
│   
│   from fastapi import FastAPI
│   from contextlib import asynccontextmanager
│   from shared.api import setup_middleware
│   from shared.utils.logger import create_logger
│   from .config import get_service_config
│   from .lifecycle import ServiceLifecycle
│   from .routers import health, notifications, templates
│   
│   # Global singletons
│   config = get_service_config()
│   logger = create_logger(config.service_name)
│   lifecycle = ServiceLifecycle(config, logger)
│   
│   
│   @asynccontextmanager
│   async def lifespan(app: FastAPI):
│       """FastAPI lifespan adapter"""
│      
│       logger.info(f"Starting {config.service_name}", extra={
│           "service_name": config.service_name,
│           "version": config.service_version,
│           "environment": config.environment,
│           "api_host": config.api_host,
│           "api_port": config.effective_port,
│       })
│       app.state.lifecycle = lifecycle
│       app.state.config = config
│       app.state.logger = logger
│       try:
│           await lifecycle.startup()
│           yield
│       finally:
│           await lifecycle.shutdown()
│   
│   
│   def create_application() -> FastAPI:
│       """Create and configure the FastAPI application."""
│       app = FastAPI(
│           title=config.service_name,
│           version=config.service_version,
│           lifespan=lifespan,
│           description="Email notification service for GlamYouUp platform",
│           exception_handlers={} # Use shared middleware for exception handling
│       )
│       
│       setup_middleware(
│           app,
│           service_name=config.service_name,
│           enable_metrics=True
│       )
│       
│       # Include routers
│       app.include_router(health.router, tags=["health"])
│       app.include_router(notifications.router, prefix="/api/v1/notifications", tags=["notifications"])
│       app.include_router(templates.router, prefix="/api/v1/templates", tags=["templates"])
│   
│       return app
│   
│   
│   app = create_application()
│   
│   if __name__ == "__main__":
│       import uvicorn
│       
│       port = config.effective_port
│       uvicorn.run(
│           "src.main:app",
│           host=config.api_host,
│           port=port,
│           reload=config.debug
│       )
│   ```
│   
└── metrics.py
    
    ```py
    # -------------------------------
    # services/notification-service/src/metrics.py
    # -------------------------------
    
    """
    Notification service specific metrics.
    
    This module defines domain-specific metrics for the notification service
    that extend the standard HTTP metrics from shared.
    """
    
    from prometheus_client import Counter, Histogram, Gauge
    
    # Notification-specific metrics
    notifications_sent_total = Counter(
        "notifications_sent_total",
        "Total notifications sent",
        ["type", "provider", "status"],
    )
    
    notifications_duration_seconds = Histogram(
        "notifications_duration_seconds",
        "Notification sending duration in seconds",
        ["type", "provider"],
    )
    
    email_queue_size = Gauge("email_queue_size", "Current size of email queue")
    
    template_render_duration_seconds = Histogram(
        "template_render_duration_seconds",
        "Template rendering duration in seconds",
        ["template_type"],
    )
    
    rate_limit_hits_total = Counter(
        "rate_limit_hits_total", "Total rate limit hits", ["merchant_id", "limit_type"]
    )
    
    
    # Helper functions for easier metric updates
    def increment_notification_sent(notification_type: str, provider: str, status: str):
        """Increment notification sent counter."""
        notifications_sent_total.labels(
            type=notification_type, provider=provider, status=status
        ).inc()
    
    
    def observe_notification_duration(
        notification_type: str, provider: str, duration: float
    ):
        """Record notification sending duration."""
        notifications_duration_seconds.labels(
            type=notification_type, provider=provider
        ).observe(duration)
    
    
    def set_email_queue_size(size: int):
        """Update email queue size gauge."""
        email_queue_size.set(size)
    
    
    def observe_template_render_duration(template_type: str, duration: float):
        """Record template rendering duration."""
        template_render_duration_seconds.labels(template_type=template_type).observe(
            duration
        )
    
    
    def increment_rate_limit_hit(merchant_id: str, limit_type: str):
        """Increment rate limit hit counter."""
        rate_limit_hits_total.labels(merchant_id=merchant_id, limit_type=limit_type).inc()
    ```
    
tests/
├── unit/
├── __init__.py
└── conftest.py
.python-version
Dockerfile

```
# ──────────────────────────────────────────────────────────────
# 🛠  Stage 1  ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim AS builder

# Base toolchain
RUN apt-get update -qq && apt-get install -y --no-install-recommends \
        curl ca-certificates build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install --no-cache-dir poetry==1.7.1
ENV POETRY_VIRTUALENVS_CREATE=false \
    POETRY_NO_INTERACTION=1

WORKDIR /app

# ---- 1️⃣  Copy shared lib -----------------------------------------------------
COPY shared /shared
RUN pip install --no-cache-dir -e /shared

# Make shared importable
ENV PYTHONPATH="/shared:/app"

# ---- 2️⃣  Service deps --------------------------------------------------------
COPY services/notification-service/pyproject.toml \
     services/notification-service/poetry.lock* /app/
RUN poetry install --no-root --no-ansi \
    && rm -rf ~/.cache/pypoetry ~/.cache/pip

# ---- 3️⃣  Copy service source -------------------------------------------------
COPY services/notification-service /app

# ---- 4️⃣  Copy config -----------------------------------------------------

COPY config /app/config

# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app       /app
COPY --from=builder /shared    /shared

ENV PYTHONPATH="/shared:/app"
WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run with optimal settings for notification service
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "2"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
[tool.poetry]
name = "notification-service"
version = "1.0.0"
description = "Email notification service for GlamYouUp platform"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
sqlalchemy = "^2.0.23"
asyncpg = "^0.29.0"
alembic = "^1.13.0"
nats-py = "^2.6.0"
redis = "^5.0.1"
jinja2 = "^3.1.2"
email-validator = "^2.1.0"
python-multipart = "^0.0.6"
httpx = "^0.25.2"
croniter = "^2.0.1"  # For cron expression parsing
pytz = "^2023.3"  # For timezone support
python-jose = {extras = ["cryptography"], version = "^3.3.0"}  # For JWT
python-dotenv = "^1.0.0"  # For .env file support
shared = { path = "../../shared", develop = true }
# Email providers
boto3 = "^1.34.0"  # For AWS SES
sendgrid = "^6.11.0"  # For SendGrid
aiosmtplib = "^3.0.1"  # For SMTP
# Shared package is installed from local path in Dockerfile
html2text = "^2025.4.15"
cachetools = "^6.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
flake8 = "^6.1.0"
mypy = "^1.7.1"
faker = "^20.1.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 88
target-version = ['py311']

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true
```

README.md

```md
# Notification Service

Email notification service for the GlamYouUp platform.

## Features

- Multiple email provider support (SendGrid, AWS SES, SMTP)
- Automatic failover between providers
- Template management with Jinja2
- Rate limiting per recipient and notification type
- Bulk email sending
- Notification preferences per shop
- Event-driven architecture with NATS JetStream
- Complete audit trail

## Architecture

### Service Type
- **Type**: API Service with Event Subscribers
- **Port**: 8007
- **Database**: PostgreSQL (dedicated)

### Key Components

1. **Email Providers**
   - SendGrid (primary)
   - AWS SES (fallback)
   - SMTP (additional fallback)

2. **Template Engine**
   - Jinja2 for template rendering
   - Variable validation
   - HTML to text conversion

3. **Rate Limiting**
   - Per-recipient limits
   - Per-notification-type limits
   - Burst protection

4. **Event Handling**
   - Subscribes to: `cmd.notification.send.email`, `cmd.notification.send.bulk`
   - Publishes: `evt.notification.email.sent`, `evt.notification.email.failed`

## API Endpoints

### Notifications
- `GET /api/v1/notifications` - List notifications with pagination
- `GET /api/v1/notifications/{id}` - Get notification details

### Templates
- `GET /api/v1/notifications/templates` - List templates
- `GET /api/v1/notifications/templates/{id}` - Get template
- `POST /api/v1/notifications/templates` - Create template
- `PUT /api/v1/notifications/templates/{id}` - Update template
- `DELETE /api/v1/notifications/templates/{id}` - Delete template
- `POST /api/v1/notifications/templates/{id}/preview` - Preview template
- `POST /api/v1/notifications/templates/{id}/validate` - Validate template
- `POST /api/v1/notifications/templates/{id}/clone` - Clone template

### Preferences
- `POST /api/v1/notifications/preferences` - Update preferences
- `GET /api/v1/notifications/preferences/{merchant_id}` - Get preferences

## Environment Variables

See `.env.example` for all configuration options.

## Development

```bash
# Install dependencies
poetry install

# Run migrations
alembic upgrade head

# Start service
uvicorn app.main:app --reload --port 8007

# Run tests
pytest

Docker
bash# Build image
docker build -t notification-service .

# Run with docker-compose
docker-compose up notification-service
Database Migrations
bash# Create new migration
alembic revision --autogenerate -m "Description"

# Apply migrations
alembic upgrade head

# Rollback one version
alembic downgrade -1
Template Variables
Global Variables (always available)

unsubscribe_url - Unsubscribe link
support_url - Support page link
current_year - Current year
platform_name - "GlamYouUp"

Template-Specific Variables
Defined per template in the variables field:

required: Must be provided
optional: Can be provided

Rate Limits
Default Limits

10 emails per minute per recipient
20 burst limit
1000 daily limit

Type-Specific Limits

billing_low_credits: Max 5 total
billing_zero_balance: Max 2 total
billing_deactivated: Max 7 total

```


================================================================================
Output includes file contents
================================================================================