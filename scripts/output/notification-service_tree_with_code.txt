================================================================================
Directory Structure: /home/bellabe/glam-app/services/notification-service
================================================================================

notification-service/
.ruff_cache/
├── 0.1.9/
│   ├── 12925870412564400397
│   └── 16880118436713266958
├── .gitignore
└── CACHEDIR.TAG
prisma/
├── migrations/
│   ├── 20250818083358_desktop_pgt_1_cqb/
│   │   └── migration.sql
│   │
│   │       ```sql
│   │       -- CreateTable
│   │       CREATE TABLE "notifications" (
│   │           "id" UUID NOT NULL,
│   │           "merchant_id" UUID NOT NULL,
│   │           "platform_name" VARCHAR(255) NOT NULL,
│   │           "platform_id" VARCHAR(255) NOT NULL,
│   │           "domain" VARCHAR(255) NOT NULL,
│   │           "recipient_email" VARCHAR(255) NOT NULL,
│   │           "template_type" VARCHAR(100) NOT NULL,
│   │           "subject" TEXT NOT NULL,
│   │           "status" VARCHAR(50) NOT NULL DEFAULT 'pending',
│   │           "provider" VARCHAR(50),
│   │           "provider_message_id" VARCHAR(255),
│   │           "error_message" TEXT,
│   │           "retry_count" INTEGER NOT NULL DEFAULT 0,
│   │           "trigger_event" VARCHAR(255) NOT NULL,
│   │           "trigger_event_id" VARCHAR(100),
│   │           "idempotency_key" VARCHAR(255) NOT NULL,
│   │           "template_variables" JSON,
│   │           "extra_metadata" JSON,
│   │           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "sent_at" TIMESTAMPTZ(3),
│   │           "failed_at" TIMESTAMPTZ(3),
│   │
│   │           CONSTRAINT "notifications_pkey" PRIMARY KEY ("id")
│   │       );
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "notifications_provider_message_id_key" ON "notifications"("provider_message_id");
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "notifications_idempotency_key_key" ON "notifications"("idempotency_key");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "notifications_merchant_id_created_at_idx" ON "notifications"("merchant_id", "created_at");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "notifications_platform_name_platform_id_idx" ON "notifications"("platform_name", "platform_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "notifications_domain_idx" ON "notifications"("domain");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "notifications_status_idx" ON "notifications"("status");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "notifications_template_type_idx" ON "notifications"("template_type");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "notifications_idempotency_key_idx" ON "notifications"("idempotency_key");
│   │       ```
│   │
│   └── migration_lock.toml
│
│       ```toml
│       # Please do not edit this file manually
│       # It should be added in your version-control system (i.e. Git)
│       provider = "postgresql"
│       ```
│
└── schema.prisma
src/
├── api/
│   ├── v1/
│   │   ├── __init__.py
│   │   └── notifications.py
│   │
│   │       ```py
│   │       # services/notification-service/src/api/v1/notifications.py
│   │       from uuid import UUID
│   │
│   │       from fastapi import APIRouter, Query, Request
│   │
│   │       from shared.api import ApiResponse, paginated_response, success_response
│   │       from shared.api.dependencies import ClientAuthDep, PaginationDep, RequestContextDep
│   │       from shared.utils.exceptions import ForbiddenError
│   │
│   │       from ...dependencies import NotificationServiceDep
│   │       from ...schemas.notification import NotificationOut, NotificationStats
│   │
│   │       router = APIRouter(prefix="/api/v1/notifications", tags=["Notifications"])
│   │
│   │
│   │       @router.get("", response_model=ApiResponse[list[NotificationOut]], summary="List sent notifications")
│   │       async def list_notifications(
│   │           svc: NotificationServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: ClientAuthDep,
│   │           pagination: PaginationDep,
│   │           request: Request,
│   │           status: str | None = Query(None, description="Filter by status"),
│   │           merchant_id: UUID | None = Query(None, description="Filter by merchant"),
│   │       ):
│   │           """List notifications with optional filters"""
│   │           # Permission check
│   │           if auth.scope not in ["notifications:read", "notifications:write"]:
│   │               raise ForbiddenError(message="Cannot read notifications", required_permission="notifications:read")
│   │
│   │           # Get notifications
│   │           total, notifications = await svc.list_notifications(
│   │               skip=pagination.offset, limit=pagination.limit, status=status, merchant_id=merchant_id
│   │           )
│   │
│   │           # Return paginated response
│   │           return paginated_response(
│   │               data=notifications,
│   │               page=pagination.page,
│   │               limit=pagination.limit,
│   │               total=total,
│   │               base_url=str(request.url.path),
│   │               request_id=ctx.request_id,
│   │               correlation_id=ctx.correlation_id,
│   │           )
│   │
│   │
│   │       @router.get("/stats", response_model=ApiResponse[NotificationStats], summary="Get notification statistics")
│   │       async def get_stats(svc: NotificationServiceDep, ctx: RequestContextDep, auth: ClientAuthDep):
│   │           """Get daily notification statistics"""
│   │           # Permission check
│   │           if auth.scope not in ["notifications:read", "notifications:write"]:
│   │               raise ForbiddenError(message="Cannot read notification stats", required_permission="notifications:read")
│   │
│   │           stats = await svc.get_stats()
│   │
│   │           return success_response(data=stats, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │
│   │
│   │       @router.get("/{notification_id}", response_model=ApiResponse[NotificationOut], summary="Get notification details")
│   │       async def get_notification(
│   │           notification_id: UUID, svc: NotificationServiceDep, ctx: RequestContextDep, auth: ClientAuthDep
│   │       ):
│   │           """Get notification by ID"""
│   │           # Permission check
│   │           if auth.scope not in ["notifications:read", "notifications:write"]:
│   │               raise ForbiddenError(message="Cannot read notifications", required_permission="notifications:read")
│   │
│   │           # Get notification - service raises NotFoundError if missing
│   │           notification = await svc.get_notification(notification_id)
│   │
│   │           return success_response(data=notification, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │       ```
│   │
│   └── __init__.py
├── events/
│   ├── __init__.py
│   ├── listeners.py
│   │
│   │   ```py
│   │   # services/notification-service/src/events/listeners.py
│   │   from typing import Any
│   │
│   │   from shared.messaging.listener import Listener
│   │   from shared.messaging.subjects import Subjects
│   │   from shared.utils.exceptions import ValidationError
│   │
│   │   from ..schemas.events import (
│   │       CatalogSyncCompletedPayload,
│   │       CreditBalanceDepletedPayload,
│   │       CreditBalanceLowPayload,
│   │       MerchantCreatedPayload,
│   │   )
│   │
│   │
│   │   class MerchantCreatedListener(Listener):
│   │       """Listen for merchant created events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.merchant.created.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "notification-merchant-created"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "notification-service"
│   │
│   │       def __init__(self, js_client, notification_service, event_publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.notification_service = notification_service
│   │           self.event_publisher = event_publisher
│   │
│   │       async def on_message(self, data: dict[str, Any]) -> None:
│   │           """Process merchant created event"""
│   │           try:
│   │               # Validate payload
│   │               payload = MerchantCreatedPayload(**data)
│   │
│   │               # Process notification
│   │               notification = await self.notification_service.process_event(
│   │                   event_type=self.subject,
│   │                   event_data=payload.model_dump(),
│   │                   correlation_id=payload.correlation_id or "unknown",
│   │               )
│   │
│   │               # Publish result event
│   │               if notification:
│   │                   if notification.status == "sent":
│   │                       await self.event_publisher.email_sent(notification)
│   │                   else:
│   │                       await self.event_publisher.email_failed(
│   │                           notification,
│   │                           error=notification.error_message or "Unknown error",
│   │                       )
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid merchant created event: {e}")
│   │               # ACK invalid messages
│   │               return
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to process merchant created: {e}")
│   │               raise  # NACK for retry
│   │
│   │
│   │   class CatalogSyncCompletedListener(Listener):
│   │       """Listen for catalog sync completed events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.catalog.sync.completed.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "notification-catalog-sync"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "notification-service"
│   │
│   │       def __init__(self, js_client, notification_service, event_publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.notification_service = notification_service
│   │           self.event_publisher = event_publisher
│   │
│   │       async def on_message(self, data: dict[str, Any]) -> None:
│   │           """Process catalog sync completed event"""
│   │           try:
│   │               payload = CatalogSyncCompletedPayload(**data)
│   │
│   │               notification = await self.notification_service.process_event(
│   │                   event_type=self.subject,
│   │                   event_data=payload.model_dump(),
│   │                   correlation_id=payload.correlation_id or "unknown",
│   │               )
│   │
│   │               if notification:
│   │                   if notification.status == "sent":
│   │                       await self.event_publisher.email_sent(notification)
│   │                   else:
│   │                       await self.event_publisher.email_failed(
│   │                           notification,
│   │                           error=notification.error_message or "Unknown error",
│   │                       )
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid catalog sync event: {e}")
│   │               return
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to process catalog sync: {e}")
│   │               raise
│   │
│   │
│   │   class CreditBalanceLowListener(Listener):
│   │       """Listen for credit balance low events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return Subjects.CREDIT_BALANCE_LOW.value
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "notification-credit-low"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "notification-service"
│   │
│   │       def __init__(self, js_client, notification_service, event_publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.notification_service = notification_service
│   │           self.event_publisher = event_publisher
│   │
│   │       async def on_message(self, data: dict[str, Any]) -> None:
│   │           """Process credit balance low event"""
│   │           try:
│   │               payload = CreditBalanceLowPayload(**data)
│   │
│   │               notification = await self.notification_service.process_event(
│   │                   event_type=self.subject,
│   │                   event_data=payload.model_dump(),
│   │                   correlation_id=payload.correlation_id or "unknown",
│   │               )
│   │
│   │               if notification:
│   │                   if notification.status == "sent":
│   │                       await self.event_publisher.email_sent(notification)
│   │                   else:
│   │                       await self.event_publisher.email_failed(
│   │                           notification,
│   │                           error=notification.error_message or "Unknown error",
│   │                       )
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid credit balance low event: {e}")
│   │               return
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to process credit balance low: {e}")
│   │               raise
│   │
│   │
│   │   class CreditBalanceDepletedListener(Listener):
│   │       """Listen for credit balance depleted events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return Subjects.CREDIT_BALANCE_DEPLETED.value
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "notification-credit-depleted"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "notification-service"
│   │
│   │       def __init__(self, js_client, notification_service, event_publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.notification_service = notification_service
│   │           self.event_publisher = event_publisher
│   │
│   │       async def on_message(self, data: dict[str, Any]) -> None:
│   │           """Process credit balance depleted event"""
│   │           try:
│   │               payload = CreditBalanceDepletedPayload(**data)
│   │
│   │               notification = await self.notification_service.process_event(
│   │                   event_type=self.subject,
│   │                   event_data=payload.model_dump(),
│   │                   correlation_id=payload.correlation_id or "unknown",
│   │               )
│   │
│   │               if notification:
│   │                   if notification.status == "sent":
│   │                       await self.event_publisher.email_sent(notification)
│   │                   else:
│   │                       await self.event_publisher.email_failed(
│   │                           notification,
│   │                           error=notification.error_message or "Unknown error",
│   │                       )
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid credit depleted event: {e}")
│   │               return
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to process credit depleted: {e}")
│   │               raise
│   │   ```
│   │
│   └── publishers.py
│
│       ```py
│       # services/notification-service/src/events/publishers.py
│       from shared.api.correlation import get_correlation_context
│       from shared.messaging.publisher import Publisher
│
│       from ..schemas.events import EmailFailedPayload, EmailSentPayload
│       from ..schemas.notification import NotificationOut
│
│
│       class NotificationEventPublisher(Publisher):
│           """Publisher for notification events"""
│
│           @property
│           def service_name(self) -> str:
│               return "notification-service"
│
│           async def email_sent(self, notification: NotificationOut) -> str:
│               """Publish email sent event"""
│               payload = EmailSentPayload(
│                   notification_id=notification.id,
│                   merchant_id=notification.merchant_id,
│                   platform_name=notification.platform_name,
│                   platform_shop_id=notification.platform_shop_id,
│                   domain=notification.domain,
│                   template_type=notification.template_type,
│                   sent_at=notification.sent_at or notification.created_at,
│               )
│
│               # Get correlation ID from context (set by listener)
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.notification.email.sent.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│                   metadata={
│                       "recipient_email": notification.recipient_email,
│                       "provider": notification.provider,
│                   },
│               )
│
│           async def email_failed(self, notification: NotificationOut, error: str) -> str:
│               """Publish email failed event"""
│               payload = EmailFailedPayload(
│                   notification_id=notification.id,
│                   merchant_id=notification.merchant_id,
│                   platform_name=notification.platform_name,
│                   platform_shop_id=notification.platform_shop_id,
│                   domain=notification.domain,
│                   template_type=notification.template_type,
│                   error=error,
│                   failed_at=notification.failed_at or notification.created_at,
│               )
│
│               # Get correlation ID from context
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.notification.email.failed.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│                   metadata={
│                       "recipient_email": notification.recipient_email,
│                       "retry_count": notification.retry_count,
│                       "trigger_event": notification.trigger_event,
│                   },
│               )
│       ```
│
├── providers/
│   ├── base.py
│   │
│   │   ```py
│   │   # services/notification-service/src/providers/base.py
│   │   from abc import ABC, abstractmethod
│   │   from dataclasses import dataclass
│   │   from typing import Any
│   │
│   │
│   │   @dataclass
│   │   class EmailMessage:
│   │       """Email message structure"""
│   │
│   │       to: str
│   │       subject: str
│   │       html: str
│   │       text: str
│   │       from_email: str | None = None
│   │       from_name: str | None = None
│   │       metadata: dict[str, Any] | None = None
│   │
│   │
│   │   class EmailProvider(ABC):
│   │       """Base email provider interface"""
│   │
│   │       @property
│   │       @abstractmethod
│   │       def name(self) -> str:
│   │           """Provider name"""
│   │           pass
│   │
│   │       @abstractmethod
│   │       async def send(self, message: EmailMessage) -> str:
│   │           """
│   │           Send email and return provider message ID
│   │
│   │           Raises:
│   │               Exception: On send failure
│   │           """
│   │           pass
│   │
│   │       @abstractmethod
│   │       async def get_status(self, message_id: str) -> dict[str, Any]:
│   │           """Get message status from provider"""
│   │           pass
│   │   ```
│   │
│   ├── mailhog_provider.py
│   │
│   │   ```py
│   │   # services/notification-service/src/providers/mailhog_provider.py
│   │   import smtplib
│   │   import uuid
│   │   from email.mime.multipart import MIMEMultipart
│   │   from email.mime.text import MIMEText
│   │   from typing import Any
│   │
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │   from .base import EmailMessage, EmailProvider
│   │
│   │
│   │   class MailhogProvider(EmailProvider):
│   │       """Mailhog SMTP provider for local testing"""
│   │
│   │       def __init__(
│   │           self,
│   │           smtp_host: str = "localhost",
│   │           smtp_port: int = 1025,
│   │           logger: ServiceLogger = None,
│   │       ):
│   │           self.smtp_host = smtp_host
│   │           self.smtp_port = smtp_port
│   │           self.logger = logger
│   │
│   │       @property
│   │       def name(self) -> str:
│   │           return "mailhog"
│   │
│   │       async def send(self, message: EmailMessage) -> str:
│   │           """Send email via Mailhog SMTP"""
│   │           # Create message
│   │           msg = MIMEMultipart("alternative")
│   │           msg["Subject"] = message.subject
│   │           msg["From"] = message.from_email or "noreply@glamyouup.com"
│   │           msg["To"] = message.to
│   │
│   │           # Generate a message ID
│   │           message_id = f"mailhog-{uuid.uuid4().hex[:12]}"
│   │           msg["Message-ID"] = f"<{message_id}@glamyouup.com>"
│   │
│   │           # Add text and HTML parts
│   │           text_part = MIMEText(message.text, "plain")
│   │           html_part = MIMEText(message.html, "html")
│   │           msg.attach(text_part)
│   │           msg.attach(html_part)
│   │
│   │           # Send via SMTP
│   │           try:
│   │               with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
│   │                   server.send_message(msg)
│   │
│   │               if self.logger:
│   │                   self.logger.info(
│   │                       "Email sent via Mailhog",
│   │                       extra={
│   │                           "to": message.to,
│   │                           "message_id": message_id,
│   │                           "host": self.smtp_host,
│   │                           "port": self.smtp_port,
│   │                       },
│   │                   )
│   │
│   │               return message_id
│   │
│   │           except Exception as e:
│   │               raise Exception(f"Mailhog SMTP error: {e!s}") from e
│   │
│   │       async def get_status(self, message_id: str) -> dict[str, Any]:
│   │           """Get message status (always sent for Mailhog)"""
│   │           return {"message_id": message_id, "status": "sent", "provider": self.name}
│   │   ```
│   │
│   └── sendgrid_provider.py
│
│       ```py
│       # services/notification-service/src/providers/sendgrid_provider.py
│       from typing import Any
│
│       import httpx
│
│       from shared.utils.logger import ServiceLogger
│
│       from .base import EmailMessage, EmailProvider
│
│
│       class SendGridProvider(EmailProvider):
│           """SendGrid email provider"""
│
│           def __init__(
│               self,
│               api_key: str,
│               from_email: str,
│               from_name: str,
│               sandbox_mode: bool = False,
│               logger: ServiceLogger = None,
│           ):
│               self.api_key = api_key
│               self.from_email = from_email
│               self.from_name = from_name
│               self.sandbox_mode = sandbox_mode
│               self.logger = logger
│               self.base_url = "https://api.sendgrid.com/v3"
│
│           @property
│           def name(self) -> str:
│               return "sendgrid"
│
│           async def send(self, message: EmailMessage) -> str:
│               """Send email via SendGrid API"""
│               async with httpx.AsyncClient() as client:
│                   payload = {
│                       "personalizations": [{"to": [{"email": message.to}], "subject": message.subject}],
│                       "from": {
│                           "email": message.from_email or self.from_email,
│                           "name": message.from_name or self.from_name,
│                       },
│                       "content": [
│                           {"type": "text/plain", "value": message.text},
│                           {"type": "text/html", "value": message.html},
│                       ],
│                   }
│
│                   # Add sandbox mode for testing
│                   if self.sandbox_mode:
│                       payload["mail_settings"] = {"sandbox_mode": {"enable": True}}
│
│                   # Add custom metadata if provided
│                   if message.metadata:
│                       payload["custom_args"] = message.metadata
│
│                   response = await client.post(
│                       f"{self.base_url}/mail/send",
│                       json=payload,
│                       headers={
│                           "Authorization": f"Bearer {self.api_key}",
│                           "Content-Type": "application/json",
│                       },
│                   )
│
│                   if response.status_code not in (200, 202):
│                       error_data = response.json() if response.content else {}
│                       raise Exception(f"SendGrid API error: {response.status_code} - {error_data}")
│
│                   # Extract message ID from headers
│                   message_id = response.headers.get("X-Message-Id", "")
│
│                   if self.logger:
│                       self.logger.info(
│                           "Email sent via SendGrid",
│                           extra={
│                               "to": message.to,
│                               "message_id": message_id,
│                               "sandbox": self.sandbox_mode,
│                           },
│                       )
│
│                   return message_id
│
│           async def get_status(self, message_id: str) -> dict[str, Any]:
│               """Get message status from SendGrid"""
│               # Implementation would query SendGrid's Activity API
│               # For MVP, return basic status
│               return {"message_id": message_id, "status": "sent", "provider": self.name}
│       ```
│
├── repositories/
│   ├── __init__.py
│   └── notification_repository.py
│
│       ```py
│       # services/notification-service/src/repositories/notification_repository.py
│       from datetime import datetime, timedelta
│       from typing import Any
│       from uuid import UUID
│
│       from prisma import Prisma
│
│       from ..schemas.notification import NotificationOut, NotificationStats
│
│
│       class NotificationRepository:
│           """Repository for notification data access"""
│
│           def __init__(self, prisma: Prisma):
│               self.prisma = prisma
│
│           async def create(self, data: dict[str, Any]) -> NotificationOut:
│               """Create a new notification record"""
│               notification = await self.prisma.notification.create(data=data)
│               return NotificationOut.model_validate(notification)
│
│           async def find_by_id(self, notification_id: UUID) -> NotificationOut | None:
│               """Find notification by ID"""
│               notification = await self.prisma.notification.find_unique(where={"id": str(notification_id)})
│               return NotificationOut.model_validate(notification) if notification else None
│
│           async def find_by_idempotency_key(self, idempotency_key: str) -> NotificationOut | None:
│               """Find notification by idempotency key"""
│               notification = await self.prisma.notification.find_unique(where={"idempotency_key": idempotency_key})
│               return NotificationOut.model_validate(notification) if notification else None
│
│           async def find_many(
│               self, filters: dict[str, Any] = None, skip: int = 0, limit: int = 50, order_by: list[tuple] = None
│           ) -> list[NotificationOut]:
│               """Find multiple notifications with filters"""
│               where = filters or {}
│               order = {}
│
│               if order_by:
│                   for field, direction in order_by:
│                       order[field] = direction
│               else:
│                   order = {"created_at": "desc"}
│
│               notifications = await self.prisma.notification.find_many(where=where, skip=skip, take=limit, order=order)
│
│               return [NotificationOut.model_validate(n) for n in notifications]
│
│           async def count(self, filters: dict[str, Any] | None) -> int:
│               """Count notifications with filters"""
│               where = filters or {}
│               return await self.prisma.notification.count(where=where)
│
│           async def update(self, notification_id: UUID, data: dict[str, Any]) -> NotificationOut:
│               """Update notification"""
│               notification = await self.prisma.notification.update(where={"id": str(notification_id)}, data=data)
│               return NotificationOut.model_validate(notification)
│
│           async def get_stats(self) -> NotificationStats:
│               """Get notification statistics"""
│               # Get today's date range
│               today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
│               today_end = today_start + timedelta(days=1)
│
│               # Count by status today
│               sent_today = await self.prisma.notification.count(
│                   where={"status": "sent", "created_at": {"gte": today_start, "lt": today_end}}
│               )
│
│               failed_today = await self.prisma.notification.count(
│                   where={"status": "failed", "created_at": {"gte": today_start, "lt": today_end}}
│               )
│
│               pending_today = await self.prisma.notification.count(
│                   where={"status": "pending", "created_at": {"gte": today_start, "lt": today_end}}
│               )
│
│               # Get counts by template type
│               template_counts = await self.prisma.query_raw(
│                   """
│                   SELECT template_type, COUNT(*) as count
│                   FROM notifications
│                   WHERE created_at >= $1 AND created_at < $2
│                   GROUP BY template_type
│                   """,
│                   today_start,
│                   today_end,
│               )
│
│               by_template = {row["template_type"]: row["count"] for row in template_counts}
│
│               # Get counts by status
│               status_counts = await self.prisma.query_raw(
│                   """
│                   SELECT status, COUNT(*) as count
│                   FROM notifications
│                   WHERE created_at >= $1 AND created_at < $2
│                   GROUP BY status
│                   """,
│                   today_start,
│                   today_end,
│               )
│
│               by_status = {row["status"]: row["count"] for row in status_counts}
│
│               return NotificationStats(
│                   sent_today=sent_today,
│                   failed_today=failed_today,
│                   pending_today=pending_today,
│                   by_template=by_template,
│                   by_status=by_status,
│               )
│       ```
│
├── schemas/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/notification-service/src/schemas/__init__.py
│   │   from .notification import NotificationOut, NotificationStats
│   │
│   │   __all__ = ["NotificationOut", "NotificationStats"]
│   │   ```
│   │
│   ├── events.py
│   │
│   │   ```py
│   │   # services/notification-service/src/schemas/events.py
│   │   from datetime import datetime
│   │   from uuid import UUID
│   │
│   │   from pydantic import BaseModel, EmailStr
│   │
│   │
│   │   # Base event payload
│   │   class BaseEventPayload(BaseModel):
│   │       """Base class for all event payloads"""
│   │
│   │       merchant_id: UUID
│   │       platform_name: str
│   │       platform_shop_id: str
│   │       domain: str
│   │       correlation_id: str | None = None
│   │
│   │
│   │   # Merchant events
│   │   class MerchantCreatedPayload(BaseEventPayload):
│   │       """Payload for merchant.created event"""
│   │
│   │       email: EmailStr
│   │       shop_name: str
│   │       installed_at: datetime
│   │
│   │
│   │   # Catalog events
│   │   class CatalogSyncCompletedPayload(BaseEventPayload):
│   │       """Payload for catalog.sync.completed event"""
│   │
│   │       sync_id: UUID
│   │       total_items: int
│   │       status: str
│   │       first_sync: bool
│   │       has_changes: bool
│   │       added_count: int = 0
│   │       updated_count: int = 0
│   │
│   │
│   │   # Billing events
│   │   class BillingSubscriptionExpiredPayload(BaseEventPayload):
│   │       """Payload for billing.subscription.expired event"""
│   │
│   │       plan_name: str
│   │       expired_at: datetime
│   │
│   │
│   │   class BillingSubscriptionChangedPayload(BaseEventPayload):
│   │       """Payload for billing.subscription.changed event"""
│   │
│   │       old_plan: str | None
│   │       new_plan: str
│   │       changed_at: datetime
│   │
│   │
│   │   # Credit events
│   │   class CreditBalanceLowPayload(BaseEventPayload):
│   │       """Payload for credit.balance.low event"""
│   │
│   │       balance: int
│   │       threshold: int
│   │
│   │
│   │   class CreditBalanceDepletedPayload(BaseEventPayload):
│   │       """Payload for credit.balance.depleted event"""
│   │
│   │       depleted_at: datetime
│   │
│   │
│   │   # Published events
│   │   class EmailSentPayload(BaseModel):
│   │       """Payload for notification.email.sent event"""
│   │
│   │       notification_id: UUID
│   │       merchant_id: UUID
│   │       platform_name: str
│   │       platform_shop_id: str
│   │       domain: str
│   │       template_type: str
│   │       sent_at: datetime
│   │
│   │
│   │   class EmailFailedPayload(BaseModel):
│   │       """Payload for notification.email.failed event"""
│   │
│   │       notification_id: UUID
│   │       merchant_id: UUID
│   │       platform_name: str
│   │       platform_shop_id: str
│   │       domain: str
│   │       template_type: str
│   │       error: str
│   │       failed_at: datetime
│   │   ```
│   │
│   └── notification.py
│
│       ```py
│       # services/notification-service/src/schemas/notification.py
│       from datetime import datetime
│       from uuid import UUID
│
│       from pydantic import BaseModel, ConfigDict, Field
│
│
│       # Output DTOs
│       class NotificationOut(BaseModel):
│           """DTO for notification response"""
│
│           id: UUID
│           merchant_id: UUID
│           platform_name: str
│           platform_shop_id: str
│           domain: str
│           recipient_email: str
│           template_type: str
│           subject: str
│           status: str
│           provider: str | None = None
│           provider_message_id: str | None = None
│           error_message: str | None = None
│           retry_count: int
│           trigger_event: str
│           trigger_event_id: str | None = None
│           created_at: datetime
│           sent_at: datetime | None = None
│           failed_at: datetime | None = None
│
│           model_config = ConfigDict(from_attributes=True)
│
│
│       class NotificationStats(BaseModel):
│           """DTO for notification statistics"""
│
│           sent_today: int = 0
│           failed_today: int = 0
│           pending_today: int = 0
│           by_template: dict[str, int] = Field(default_factory=dict)
│           by_status: dict[str, int] = Field(default_factory=dict)
│       ```
│
├── services/
│   ├── __init__.py
│   ├── email_service.py
│   │
│   │   ```py
│   │   # services/notification-service/src/services/email_service.py
│   │   from typing import Any
│   │
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │   from ..providers.base import EmailMessage, EmailProvider
│   │
│   │
│   │   class EmailService:
│   │       """Service for sending emails through providers"""
│   │
│   │       def __init__(self, provider: EmailProvider, logger: ServiceLogger = None):
│   │           self.provider = provider
│   │           self.logger = logger
│   │
│   │       @property
│   │       def provider_name(self) -> str:
│   │           """Get current provider name"""
│   │           return self.provider.name
│   │
│   │       async def send(self, to: str, subject: str, html: str, text: str, metadata: dict[str, Any] | None = None) -> str:
│   │           """
│   │           Send email through configured provider
│   │
│   │           Returns:
│   │               Provider message ID
│   │
│   │           Raises:
│   │               Exception: On send failure
│   │           """
│   │           message = EmailMessage(to=to, subject=subject, html=html, text=text, metadata=metadata)
│   │
│   │           try:
│   │               message_id = await self.provider.send(message)
│   │
│   │               if self.logger:
│   │                   self.logger.info(
│   │                       "Email sent successfully",
│   │                       extra={"provider": self.provider_name, "to": to, "subject": subject, "message_id": message_id},
│   │                   )
│   │
│   │               return message_id
│   │
│   │           except Exception as e:
│   │               if self.logger:
│   │                   self.logger.error(
│   │                       f"Email send failed: {e!s}",
│   │                       extra={"provider": self.provider_name, "to": to, "subject": subject, "error": str(e)},
│   │                   )
│   │               raise
│   │
│   │       async def get_status(self, message_id: str) -> dict[str, Any]:
│   │           """Get message status from provider"""
│   │           return await self.provider.get_status(message_id)
│   │   ```
│   │
│   ├── notification_service.py
│   │
│   │   ```py
│   │   # services/notification-service/src/services/notification_service.py
│   │   from datetime import datetime
│   │   from typing import Any, ClassVar
│   │   from uuid import UUID
│   │
│   │   from shared.utils import generate_idempotency_key
│   │   from shared.utils.exceptions import NotFoundError
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │   from ..repositories.notification_repository import NotificationRepository
│   │   from ..schemas.notification import NotificationOut, NotificationStats
│   │   from .email_service import EmailService
│   │   from .template_service import TemplateService
│   │
│   │
│   │   class NotificationService:
│   │       """Core notification business logic"""
│   │
│   │       # Event to template mapping
│   │       EVENT_TEMPLATE_MAP: ClassVar[dict[str, str]] = {
│   │           "evt.merchant.created.v1": "welcome",
│   │           "evt.credit.balance.low.v1": "credit_warning",
│   │           "evt.credit.balance.depleted.v1": "zero_balance",
│   │       }
│   │
│   │       def __init__(
│   │           self,
│   │           repository: NotificationRepository,
│   │           template_service: TemplateService,
│   │           email_service: EmailService,
│   │           logger: ServiceLogger,
│   │           max_retries: int = 3,
│   │       ):
│   │           self.repository = repository
│   │           self.template_service = template_service
│   │           self.email_service = email_service
│   │           self.logger = logger
│   │           self.max_retries = max_retries
│   │
│   │       def determine_template_type(self, event_type: str, event_data: dict[str, Any]) -> str | None:
│   │           """Determine template type based on event"""
│   │           # Special handling for catalog sync
│   │           if event_type == "evt.catalog.sync.completed":
│   │               if event_data.get("first_sync"):
│   │                   return "registration_complete"
│   │               elif event_data.get("has_changes"):
│   │                   return "registration_update"
│   │               return None
│   │
│   │           # Standard mapping
│   │           return self.EVENT_TEMPLATE_MAP.get(event_type)
│   │
│   │       def generate_idempotency_key_for_event(self, event_type: str, event_data: dict[str, Any]) -> str:
│   │           """Generate idempotency key for an event"""
│   │           merchant_id = event_data.get("merchant_id", "unknown")
│   │           event_id = event_data.get("correlation_id", "unknown")
│   │
│   │           return generate_idempotency_key(
│   │               system="NOTIFICATION",
│   │               operation_type=event_type.replace(".", "_").upper(),
│   │               identifier=merchant_id,
│   │               extra=event_id,
│   │           )
│   │
│   │       async def process_event(
│   │           self, event_type: str, event_data: dict[str, Any], correlation_id: str
│   │       ) -> NotificationOut | None:
│   │           """
│   │           Process an event and send notification if needed
│   │
│   │           Returns:
│   │               NotificationOut if sent, None if skipped
│   │           """
│   │           # Generate idempotency key
│   │           idempotency_key = self.generate_idempotency_key_for_event(event_type, event_data)
│   │
│   │           # Check if already processed
│   │           existing = await self.repository.find_by_idempotency_key(idempotency_key)
│   │           if existing:
│   │               self.logger.info(
│   │                   "Notification already processed",
│   │                   extra={
│   │                       "idempotency_key": idempotency_key,
│   │                       "notification_id": str(existing.id),
│   │                       "correlation_id": correlation_id,
│   │                   },
│   │               )
│   │               return existing
│   │
│   │           # Determine template type
│   │           template_type = self.determine_template_type(event_type, event_data)
│   │           if not template_type:
│   │               self.logger.info(
│   │                   "No template for event",
│   │                   extra={"event_type": event_type, "correlation_id": correlation_id},
│   │               )
│   │               return None
│   │
│   │           # Extract recipient email
│   │           recipient_email = event_data.get("email")
│   │           if not recipient_email:
│   │               # Try to get from merchant service if needed
│   │               self.logger.warning(
│   │                   "No email in event data",
│   │                   extra={"event_type": event_type, "correlation_id": correlation_id},
│   │               )
│   │               return None
│   │
│   │           # Prepare template context
│   │           context = self._prepare_template_context(event_data)
│   │
│   │           # Render email
│   │           try:
│   │               subject, html_body, text_body = self.template_service.render_email(template_type, context)
│   │           except NotFoundError:
│   │               self.logger.error(
│   │                   f"Template not found: {template_type}",
│   │                   extra={"correlation_id": correlation_id},
│   │               )
│   │               # Store failed notification
│   │               return await self._store_failed_notification(
│   │                   event_type=event_type,
│   │                   event_data=event_data,
│   │                   template_type=template_type,
│   │                   recipient_email=recipient_email,
│   │                   error="Template not found",
│   │                   idempotency_key=idempotency_key,
│   │                   correlation_id=correlation_id,
│   │               )
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   f"Template rendering failed: {e!s}",
│   │                   extra={"correlation_id": correlation_id},
│   │               )
│   │               return await self._store_failed_notification(
│   │                   event_type=event_type,
│   │                   event_data=event_data,
│   │                   template_type=template_type,
│   │                   recipient_email=recipient_email,
│   │                   error=str(e),
│   │                   idempotency_key=idempotency_key,
│   │                   correlation_id=correlation_id,
│   │               )
│   │
│   │           # Send email
│   │           try:
│   │               provider_message_id = await self.email_service.send(
│   │                   to=recipient_email,
│   │                   subject=subject,
│   │                   html=html_body,
│   │                   text=text_body,
│   │                   metadata={
│   │                       "merchant_id": str(event_data.get("merchant_id")),
│   │                       "template_type": template_type,
│   │                       "correlation_id": correlation_id,
│   │                   },
│   │               )
│   │
│   │               # Store successful notification
│   │               notification = await self.repository.create(
│   │                   {
│   │                       "merchant_id": str(event_data.get("merchant_id")),
│   │                       "platform_name": event_data.get("platform_name"),
│   │                       "platform_shop_id": event_data.get("platform_shop_id"),
│   │                       "domain": event_data.get("domain"),
│   │                       "recipient_email": recipient_email,
│   │                       "template_type": template_type,
│   │                       "subject": subject,
│   │                       "status": "sent",
│   │                       "provider": self.email_service.provider_name,
│   │                       "provider_message_id": provider_message_id,
│   │                       "trigger_event": event_type,
│   │                       "trigger_event_id": correlation_id,
│   │                       "idempotency_key": idempotency_key,
│   │                       "template_variables": context,
│   │                       "sent_at": datetime.utcnow(),
│   │                   }
│   │               )
│   │
│   │               self.logger.info(
│   │                   "Notification sent successfully",
│   │                   extra={
│   │                       "notification_id": str(notification.id),
│   │                       "template_type": template_type,
│   │                       "correlation_id": correlation_id,
│   │                   },
│   │               )
│   │
│   │               return notification
│   │
│   │           except Exception as e:
│   │               self.logger.error(f"Email send failed: {e!s}", extra={"correlation_id": correlation_id})
│   │               return await self._store_failed_notification(
│   │                   event_type=event_type,
│   │                   event_data=event_data,
│   │                   template_type=template_type,
│   │                   recipient_email=recipient_email,
│   │                   error=str(e),
│   │                   idempotency_key=idempotency_key,
│   │                   correlation_id=correlation_id,
│   │               )
│   │
│   │       def _prepare_template_context(self, event_data: dict[str, Any]) -> dict[str, Any]:
│   │           """Prepare context for template rendering"""
│   │           context = {
│   │               "merchant_id": event_data.get("merchant_id"),
│   │               "platform_name": event_data.get("platform_name"),
│   │               "platform_shop_id": event_data.get("platform_shop_id"),
│   │               "domain": event_data.get("domain"),
│   │               "domain": event_data.get("domain"),  # Alias
│   │               "shop_name": event_data.get("shop_name", event_data.get("domain")),
│   │               "current_year": datetime.now().year,
│   │               "support_email": "support@glamyouup.com",
│   │               "app_url": "https://app.glamyouup.com",
│   │           }
│   │
│   │           # Add all event data
│   │           context.update(event_data)
│   │
│   │           return context
│   │
│   │       async def _store_failed_notification(
│   │           self,
│   │           event_type: str,
│   │           event_data: dict[str, Any],
│   │           template_type: str,
│   │           recipient_email: str,
│   │           error: str,
│   │           idempotency_key: str,
│   │           correlation_id: str,
│   │       ) -> NotificationOut:
│   │           """Store a failed notification record"""
│   │           notification = await self.repository.create(
│   │               {
│   │                   "merchant_id": str(event_data.get("merchant_id")),
│   │                   "platform_name": event_data.get("platform_name"),
│   │                   "platform_shop_id": event_data.get("platform_shop_id"),
│   │                   "domain": event_data.get("domain"),
│   │                   "recipient_email": recipient_email,
│   │                   "template_type": template_type,
│   │                   "subject": "",  # No subject for failed
│   │                   "status": "failed",
│   │                   "error_message": error,
│   │                   "trigger_event": event_type,
│   │                   "trigger_event_id": correlation_id,
│   │                   "idempotency_key": idempotency_key,
│   │                   "template_variables": event_data,
│   │                   "failed_at": datetime.utcnow(),
│   │               }
│   │           )
│   │
│   │           return notification
│   │
│   │       async def get_notification(self, notification_id: UUID) -> NotificationOut:
│   │           """Get notification by ID"""
│   │           notification = await self.repository.find_by_id(notification_id)
│   │           if not notification:
│   │               raise NotFoundError(
│   │                   f"Notification {notification_id} not found",
│   │                   resource="notification",
│   │                   resource_id=str(notification_id),
│   │               )
│   │           return notification
│   │
│   │       async def list_notifications(
│   │           self,
│   │           skip: int = 0,
│   │           limit: int = 50,
│   │           status: str | None = None,
│   │           merchant_id: UUID | None = None,
│   │       ) -> tuple[int, list[NotificationOut]]:
│   │           """List notifications with filtering"""
│   │           filters = {}
│   │           if status:
│   │               filters["status"] = status
│   │           if merchant_id:
│   │               filters["merchant_id"] = str(merchant_id)
│   │
│   │           total = await self.repository.count(filters)
│   │           notifications = await self.repository.find_many(
│   │               filters=filters, skip=skip, limit=limit, order_by=[("created_at", "desc")]
│   │           )
│   │
│   │           return total, notifications
│   │
│   │       async def get_stats(self) -> NotificationStats:
│   │           """Get notification statistics"""
│   │           return await self.repository.get_stats()
│   │   ```
│   │
│   └── template_service.py
│
│       ```py
│       # services/notification-service/src/services/template_service.py
│       from pathlib import Path
│       from typing import Any
│
│       from jinja2 import Environment, FileSystemLoader, TemplateNotFound
│
│       from shared.utils.exceptions import InternalError, NotFoundError
│       from shared.utils.logger import ServiceLogger
│
│
│       class TemplateService:
│           """Service for managing and rendering email templates"""
│
│           def __init__(self, template_path: str, cache_ttl: int = 300, logger: ServiceLogger | None = None):
│               self.template_path = Path(template_path)
│               self.cache_ttl = cache_ttl  # kept for compatibility; unused without caching
│               self.logger = logger
│
│               self.env = Environment(
│                   loader=FileSystemLoader(str(self.template_path)),
│                   autoescape=True,
│                   trim_blocks=True,
│                   lstrip_blocks=True,
│               )
│               self.env.filters["format_currency"] = self._format_currency
│               self.env.filters["format_date"] = self._format_date
│
│           @staticmethod
│           def _format_currency(value: float) -> str:
│               return f"${value:,.2f}"
│
│           @staticmethod
│           def _format_date(value: Any) -> str:
│               from datetime import datetime
│
│               if isinstance(value, str):
│                   value = datetime.fromisoformat(value)
│               if hasattr(value, "strftime"):
│                   return value.strftime("%B %d, %Y")
│               return str(value)
│
│           def get_template_path(self, template_type: str, filename: str) -> Path:
│               return self.template_path / template_type / filename
│
│           def template_exists(self, template_type: str) -> bool:
│               return (self.template_path / template_type).is_dir()
│
│           # ⬇️ no caching
│           def load_subject(self, template_type: str) -> str:
│               path = self.get_template_path(template_type, "subject.txt")
│               if not path.exists():
│                   raise NotFoundError(
│                       f"Subject template not found for {template_type}",
│                       resource="template",
│                       resource_id=f"{template_type}/subject.txt",
│                   )
│               return path.read_text(encoding="utf-8").strip()
│
│           def render_template(self, template_type: str, fmt: str, context: dict[str, Any]) -> str:
│               """
│               Render a template with context
│
│               Args:
│                   template_type: Template type (e.g., 'welcome')
│                   fmt: 'html' or 'text'
│                   context: Template variables
│               """
│               template_file = "body.html.j2" if fmt == "html" else "body.text.j2"
│               template_path = f"{template_type}/{template_file}"
│
│               try:
│                   template = self.env.get_template(template_path)
│                   if fmt == "html":
│                       context = {**context}  # avoid mutating caller's dict
│                       context["header"] = self._render_shared("header.html.j2", context)
│                       context["footer"] = self._render_shared("footer.html.j2", context)
│                   return template.render(**context)
│
│               except TemplateNotFound as e:
│                   raise NotFoundError(
│                       f"Template not found: {template_path}",
│                       resource="template",
│                       resource_id=template_path,
│                   ) from e
│               except Exception as e:
│                   raise InternalError(f"Template rendering failed: {e!s}", error_id=template_type) from e
│
│           def _render_shared(self, template_name: str, context: dict[str, Any]) -> str:
│               try:
│                   template = self.env.get_template(f"shared/{template_name}")
│                   return template.render(**context)
│               except TemplateNotFound:
│                   if self.logger:
│                       self.logger.warning(f"Shared template not found: {template_name}")
│                   return ""
│
│           def render_email(self, template_type: str, context: dict[str, Any]) -> tuple[str, str, str]:
│               if not self.template_exists(template_type):
│                   raise NotFoundError(
│                       f"Template type not found: {template_type}",
│                       resource="template",
│                       resource_id=template_type,
│                   )
│
│               subject = self.load_subject(template_type)
│               html_body = self.render_template(template_type, "html", context)
│               text_body = self.render_template(template_type, "text", context)
│               return subject, html_body, text_body
│       ```
│
├── templates/
│   ├── welcome/
│   │   ├── body.html
│   │   │
│   │   │   ```html
│   │   │   <!-- services/notification-service/templates/welcome/body.html.j2 -->
│   │   │   <!DOCTYPE html>
│   │   │   <html>
│   │   │   <head>
│   │   │       <meta charset="UTF-8">
│   │   │       <meta name="viewport" content="width=device-width, initial-scale=1.0">
│   │   │       <title>Welcome to Glam You Up</title>
│   │   │   </head>
│   │   │   <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
│   │   │       {{ header|safe }}
│   │   │
│   │   │       <div style="padding: 20px; max-width: 600px; margin: 0 auto;">
│   │   │           <h1 style="color: #FF6B6B;">Welcome to Glam You Up!</h1>
│   │   │
│   │   │           <p>Hi {{ shop_name }},</p>
│   │   │
│   │   │           <p>Thank you for installing Glam You Up on your {{ platform_name|title }} store!</p>
│   │   │
│   │   │           <p>We're excited to help you reduce returns and increase customer satisfaction with our AI-powered virtual try-on technology.</p>
│   │   │
│   │   │           <h2 style="color: #4ECDC4;">Getting Started</h2>
│   │   │
│   │   │           <ol>
│   │   │               <li><strong>Sync Your Catalog:</strong> Import your products to enable virtual try-on</li>
│   │   │               <li><strong>Choose Your Plan:</strong> Start with our free trial or select a plan</li>
│   │   │               <li><strong>Go Live:</strong> Your customers can start using virtual try-on immediately</li>
│   │   │           </ol>
│   │   │
│   │   │           <div style="text-align: center; margin: 30px 0;">
│   │   │               <a href="{{ app_url }}/dashboard"
│   │   │                  style="background-color: #FF6B6B; color: white; padding: 12px 30px;
│   │   │                         text-decoration: none; border-radius: 5px; display: inline-block;">
│   │   │                   Go to Dashboard
│   │   │               </a>
│   │   │           </div>
│   │   │
│   │   │           <p>If you have any questions, our support team is here to help at
│   │   │              <a href="mailto:{{ support_email }}">{{ support_email }}</a></p>
│   │   │
│   │   │           <p>Best regards,<br>The Glam You Up Team</p>
│   │   │       </div>
│   │   │
│   │   │       {{ footer|safe }}
│   │   │   </body>
│   │   │   </html>
│   │   │   ```
│   │   │
│   │   ├── body.text.j2
│   │   └── subject.txt
│   │
│   │       ```txt
│   │       # services/notification-service/templates/welcome/subject.txt
│   │       Welcome to Glam You Up - Let's Get Started!
│   │       ```
│   │
│   └── __init__.py
│
│       ```py
│       # ruff: noqa: RUF012
│       # services/notification-service/src/templates/email_templates.py
│       """Email templates for different notification types"""
│
│       from typing import Any
│
│
│       class EmailTemplates:
│           """Email template definitions with all required variables"""
│
│           # Base footer template used in all emails
│           FOOTER_TEMPLATE = """
│           <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
│               <div style="text-align: center; font-size: 12px; color: #666;">
│                   <p>
│                       <a href="{{ support_url }}" style="color: #666; text-decoration: none;">Contact Support</a> |
│                       <a href="{{ unsubscribe_url }}" style="color: #666; text-decoration: none;">Unsubscribe</a>
│                   </p>
│                   <p>&copy; {{ current_year }} {{ platform_name }}. All rights reserved.</p>
│               </div>
│           </div>
│           """
│
│           WELCOME = {
│               "subject": "Welcome to GlamYouUp! 🎉",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #f8f9fa; padding: 20px; text-align: center;">
│                       <h1 style="color: #333;">Welcome to GlamYouUp!</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi {{ shop_name }},</p>
│
│                       <p>Thank you for launching GlamYouUp on your store! We're excited to help you provide an amazing shopping experience for your customers.</p>
│
│                       <h2 style="color: #666;">Key Features Now Available:</h2>
│
│                       <div style="margin: 20px 0;">
│                           <h3 style="color: #333;">✨ Personal Style Analysis</h3>
│                           <p>Help customers discover their unique style profile with AI-powered analysis.</p>
│                       </div>
│
│                       <div style="margin: 20px 0;">
│                           <h3 style="color: #333;">👗 Best Style Fit Recommendation</h3>
│                           <p>Match customers with products that perfectly suit their style preferences.</p>
│                       </div>
│
│                       <div style="margin: 20px 0;">
│                           <h3 style="color: #333;">🤳 Proactive Tryon Analysis</h3>
│                           <p>Let customers virtually try on products before making a purchase.</p>
│                       </div>
│
│                       <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 30px 0;">
│                           <h3 style="color: #1976d2;">Next Steps:</h3>
│                           <ol style="color: #555;">
│                               <li>Complete product registration to enable AI features</li>
│                               <li>Customize your style preferences</li>
│                               <li>Start promoting virtual try-on to your customers</li>
│                           </ol>
│                       </div>
│
│                       <p>If you have any questions, don't hesitate to reach out to our support team!</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {"required": ["shop_name"], "optional": []},
│           }
│
│           REGISTRATION_FINISH = {
│               "subject": "Product Registration Complete! ✅",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #4caf50; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Registration Complete!</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Great news!</p>
│
│                       <p>We've successfully registered <strong>{{ product_count }}</strong> products from your store with our AI system.</p>
│
│                       <div style="background-color: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
│                           <h3 style="color: #2e7d32;">What This Means:</h3>
│                           <ul style="color: #555;">
│                               <li>Your products are now ready for AI-powered style analysis</li>
│                               <li>Customers can use virtual try-on features</li>
│                               <li>Personalized recommendations are active</li>
│                           </ul>
│                       </div>
│
│                       <p>Your customers can now enjoy the full GlamYouUp experience!</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {"required": ["product_count"], "optional": []},
│           }
│
│           REGISTRATION_SYNC = {
│               "subject": "Product Catalog Updated 🔄",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #2196f3; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Catalog Sync Complete</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi there,</p>
│
│                       <p>We've detected changes in your product catalog and automatically synced them with GlamYouUp.</p>
│
│                       <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
│                           <h3 style="color: #1976d2;">Sync Summary:</h3>
│                           <ul style="color: #555;">
│                               <li><strong>{{ added_count }}</strong> new products added</li>
│                               <li><strong>{{ updated_count }}</strong> products updated</li>
│                               {% if removed_count > 0 %}
│                               <li><strong>{{ removed_count }}</strong> products removed</li>
│                               {% endif %}
│                           </ul>
│                       </div>
│
│                       <p>The updated products are being processed by our AI system and will be ready for virtual try-on shortly.</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {
│                   "required": ["added_count", "updated_count"],
│                   "optional": ["removed_count"],
│               },
│           }
│
│           BILLING_EXPIRED = {
│               "subject": "Your GlamYouUp Subscription Has Expired ⚠️",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #ff9800; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Subscription Expired</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi there,</p>
│
│                       <p>Your GlamYouUp subscription ({{ plan_name }}) has expired.</p>
│
│                       <div style="background-color: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
│                           <h3 style="color: #e65100;">What This Means:</h3>
│                           <ul style="color: #555;">
│                               <li>Virtual try-on features are temporarily disabled</li>
│                               <li>AI style recommendations are paused</li>
│                               <li>Your product data is safely stored</li>
│                           </ul>
│                       </div>
│
│                       <div style="text-align: center; margin: 30px 0;">
│                           <a href="{{ renewal_link }}" style="background-color: #4caf50; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
│                               Renew Subscription
│                           </a>
│                       </div>
│
│                       <p>Renew your subscription to continue providing amazing experiences for your customers!</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {"required": ["plan_name", "renewal_link"], "optional": []},
│           }
│
│           BILLING_CHANGED = {
│               "subject": "Billing Plan Updated Successfully ✅",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #4caf50; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Plan Updated!</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi there,</p>
│
│                       <p>Your billing plan has been successfully updated to: <strong>{{ plan_name }}</strong></p>
│
│                       <div style="background-color: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
│                           <p>All GlamYouUp features are now active and ready to use!</p>
│                       </div>
│
│                       <p>Thank you for continuing to trust GlamYouUp for your virtual try-on needs.</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {"required": ["plan_name"], "optional": []},
│           }
│
│           BILLING_LOW_CREDITS = {
│               "subject": "Credit Balance Running Low ⚠️",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #ff9800; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Low Credit Balance</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi there,</p>
│
│                       <p>Your GlamYouUp credit balance is running low.</p>
│
│                       <div style="background-color: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
│                           <h3 style="color: #e65100;">Current Status:</h3>
│                           <ul style="color: #555;">
│                               <li>Current balance: <strong>${{ current_balance }}</strong></li>
│                               <li>Estimated days remaining: <strong>{{ days_remaining }} days</strong></li>
│                               <li>Expected depletion: <strong>{{ expected_depletion_date }}</strong></li>
│                           </ul>
│                       </div>
│
│                       <p>To avoid service interruption, please add credits or upgrade your plan.</p>
│
│                       <div style="text-align: center; margin: 30px 0;">
│                           <a href="{{ billing_link }}" style="background-color: #2196f3; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
│                               Add Credits
│                           </a>
│                       </div>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {
│                   "required": [
│                       "current_balance",
│                       "days_remaining",
│                       "expected_depletion_date",
│                       "billing_link",
│                   ],
│                   "optional": [],
│               },
│           }
│
│           BILLING_ZERO_BALANCE = {
│               "subject": "URGENT: Zero Balance - Service Deactivation in 16 Hours 🚨",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #f44336; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Zero Balance Alert</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi there,</p>
│
│                       <p><strong>Your GlamYouUp credit balance has reached $0.</strong></p>
│
│                       <div style="background-color: #ffebee; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #f44336;">
│                           <h3 style="color: #c62828;">⏰ IMPORTANT:</h3>
│                           <p style="color: #555; font-size: 16px;">
│                               GlamYouUp features will be automatically deactivated at:<br>
│                               <strong style="font-size: 18px;">{{ deactivation_time }}</strong>
│                           </p>
│                       </div>
│
│                       <p>To continue using GlamYouUp without interruption, please add credits immediately.</p>
│
│                       <div style="text-align: center; margin: 30px 0;">
│                           <a href="{{ billing_link }}" style="background-color: #f44336; color: white; padding: 15px 40px; text-decoration: none; border-radius: 5px; display: inline-block; font-size: 18px;">
│                               Add Credits Now
│                           </a>
│                       </div>
│
│                       <p>Don't let your customers miss out on the virtual try-on experience!</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {
│                   "required": ["deactivation_time", "billing_link"],
│                   "optional": [],
│               },
│           }
│
│           BILLING_DEACTIVATED = {
│               "subject": "GlamYouUp Features Deactivated 🔒",
│               "body": """
│               <html>
│               <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
│                   <div style="background-color: #757575; padding: 20px; text-align: center;">
│                       <h1 style="color: white;">Features Deactivated</h1>
│                   </div>
│
│                   <div style="padding: 30px;">
│                       <p>Hi there,</p>
│
│                       <p>GlamYouUp features have been deactivated for your store due to: <strong>{{ reason }}</strong></p>
│
│                       <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
│                           <h3 style="color: #424242;">Currently Disabled:</h3>
│                           <ul style="color: #555;">
│                               <li>Virtual try-on functionality</li>
│                               <li>AI style recommendations</li>
│                               <li>Product analysis features</li>
│                           </ul>
│                       </div>
│
│                       <p>Your product data and settings are safely stored and will be restored once you reactivate your account.</p>
│
│                       <div style="text-align: center; margin: 30px 0;">
│                           <a href="{{ reactivation_link }}" style="background-color: #4caf50; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">
│                               Reactivate Account
│                           </a>
│                       </div>
│
│                       <p>We'd love to have you back!</p>
│
│                       <p>Best regards,<br>The GlamYouUp Team</p>
│
│                       """
│               + FOOTER_TEMPLATE
│               + """
│                   </div>
│               </body>
│               </html>
│               """,
│               "variables": {"required": ["reason", "reactivation_link"], "optional": []},
│           }
│
│           @classmethod
│           def get_template(cls, notification_type: str) -> dict[str, Any]:
│               """Get template for notification type"""
│               templates = {
│                   "welcome": cls.WELCOME,
│                   "registration_finish": cls.REGISTRATION_FINISH,
│                   "registration_sync": cls.REGISTRATION_SYNC,
│                   "billing_expired": cls.BILLING_EXPIRED,
│                   "billing_changed": cls.BILLING_CHANGED,
│                   "billing_low_credits": cls.BILLING_LOW_CREDITS,
│                   "billing_zero_balance": cls.BILLING_ZERO_BALANCE,
│                   "billing_deactivated": cls.BILLING_DEACTIVATED,
│               }
│
│               return templates.get(
│                   notification_type,
│                   {
│                       "subject": "GlamYouUp Notification",
│                       "body": "<html><body><p>{{ content }}</p></body></html>",
│                       "variables": {"required": ["content"], "optional": []},
│                   },
│               )
│
│           @classmethod
│           def get_all_templates(cls) -> dict[str, dict[str, Any]]:
│               """Get all available templates"""
│               return {
│                   "welcome": cls.WELCOME,
│                   "registration_finish": cls.REGISTRATION_FINISH,
│                   "registration_sync": cls.REGISTRATION_SYNC,
│                   "billing_expired": cls.BILLING_EXPIRED,
│                   "billing_changed": cls.BILLING_CHANGED,
│                   "billing_low_credits": cls.BILLING_LOW_CREDITS,
│                   "billing_zero_balance": cls.BILLING_ZERO_BALANCE,
│                   "billing_deactivated": cls.BILLING_DEACTIVATED,
│               }
│
│           @classmethod
│           def get_template_info(cls, notification_type: str) -> dict[str, Any]:
│               """Get template information including variables"""
│               template = cls.get_template(notification_type)
│               return {
│                   "type": notification_type,
│                   "subject": template.get("subject", ""),
│                   "variables": template.get("variables", {"required": [], "optional": []}),
│                   "has_body": bool(template.get("body")),
│               }
│
│           @classmethod
│           def validate_variables(cls, notification_type: str, provided_variables: dict[str, Any]) -> dict[str, Any]:
│               """Validate that all required variables are provided"""
│               template = cls.get_template(notification_type)
│               required_vars = template.get("variables", {}).get("required", [])
│               optional_vars = template.get("variables", {}).get("optional", [])
│
│               missing_required = [var for var in required_vars if var not in provided_variables]
│               unused_variables = [
│                   var
│                   for var in provided_variables
│                   if var not in required_vars + optional_vars + ["unsubscribe_token", "merchant_id", "merchant_domain"]
│               ]
│
│               return {
│                   "is_valid": len(missing_required) == 0,
│                   "missing_required": missing_required,
│                   "unused_variables": unused_variables,
│               }
│       ```
│
├── __init__.py
├── config.py
│
│   ```py
│   # services/notification-service/src/config.py
│   import os
│   from functools import lru_cache
│   from typing import Literal
│
│   from pydantic import BaseModel, ConfigDict, Field, model_validator
│
│   from shared.utils import ConfigurationError, load_root_env
│
│
│   class ServiceConfig(BaseModel):
│       """Notification service configuration"""
│
│       model_config = ConfigDict(
│           extra="ignore",
│           populate_by_name=True,
│       )
│
│       # Service identification
│       service_name: str = "notification-service"
│       service_version: str = "1.0.0"
│       service_description: str = "Event-driven email notification service"
│       debug: bool = Field(default=False, alias="DEBUG")
│
│       # Required environment variables
│       environment: str = Field(..., alias="APP_ENV")
│       api_external_port: int = Field(..., alias="NOTIFICATION_API_EXTERNAL_PORT")
│       database_enabled: bool = Field(True, alias="NOTIFICATION_DB_ENABLED")
│
│       # Required secrets
│       database_url: str = Field(..., alias="DATABASE_URL")
│       client_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
│       internal_jwt_secret: str = Field(..., alias="INTERNAL_JWT_SECRET")
│
│       # API configuration
│       api_host: str = "0.0.0.0"
│
│       # Email provider configuration
│       email_provider: Literal["sendgrid", "mailhog"] = Field("mailhog", alias="NOTIFICATION_EMAIL_PROVIDER")
│
│       # SendGrid settings
│       sendgrid_api_key: str = Field(default="", alias="SENDGRID_API_KEY")
│       sendgrid_from_email: str = Field(default="noreply@glamyouup.com", alias="SENDGRID_FROM_EMAIL")
│       sendgrid_from_name: str = Field(default="Glam You Up", alias="SENDGRID_FROM_NAME")
│       sendgrid_sandbox_mode: bool = Field(False, alias="SENDGRID_SANDBOX_MODE")
│
│       # Mailhog settings
│       mailhog_smtp_host: str = Field(default="localhost", alias="MAILHOG_SMTP_HOST")
│       mailhog_smtp_port: int = Field(default=1025, alias="MAILHOG_SMTP_PORT")
│
│       # Template settings
│       template_path: str = Field(default="/app/templates", alias="NOTIFICATION_TEMPLATE_PATH")
│       template_cache_ttl: int = Field(default=300, alias="NOTIFICATION_CACHE_TTL")
│
│       # Retry settings
│       max_retries: int = Field(default=3, alias="NOTIFICATION_MAX_RETRIES")
│       retry_delay: int = Field(default=60, alias="NOTIFICATION_RETRY_DELAY")
│
│       # Logging
│       logging_level: str = "INFO"
│       logging_format: str = "json"
│
│       @property
│       def nats_url(self) -> str:
│           """NATS URL for event system"""
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "nats://nats:4222"
│           return "nats://localhost:4222"
│
│       @property
│       def api_port(self) -> int:
│           """Port based on environment"""
│           in_container = os.path.exists("/.dockerenv")
│           return 8000 if in_container else self.api_external_port
│
│       @property
│       def is_production(self) -> bool:
│           """Check if running in production"""
│           return self.environment == "production"
│
│       @model_validator(mode="after")
│       def validate_config(self):
│           if self.database_enabled and not self.database_url:
│               raise ValueError("DATABASE_URL required when database is enabled")
│
│           if self.email_provider == "sendgrid" and not self.sendgrid_api_key:
│               raise ValueError("SENDGRID_API_KEY required when using SendGrid provider")
│
│           # Use local template path in development
│           if not os.path.exists("/.dockerenv") and self.environment == "local":
│               import pathlib
│
│               self.template_path = str(pathlib.Path(__file__).parent.parent / "templates")
│
│           return self
│
│
│   @lru_cache
│   def get_service_config() -> ServiceConfig:
│       """Load configuration once"""
│       try:
│           load_root_env()  # From shared package
│           return ServiceConfig(**os.environ)  # type: ignore[arg-type]
│       except Exception as e:
│           raise ConfigurationError(f"Failed to load config: {e}", config_key="notification-service") from e
│   ```
│
├── dependencies.py
│
│   ```py
│   # services/notification-service/src/dependencies.py
│   from typing import Annotated
│
│   from fastapi import Depends, HTTPException, Request
│
│   from shared.api.dependencies import ClientAuthDep, LoggerDep, PaginationDep, PlatformContextDep, RequestContextDep
│
│   from .config import ServiceConfig
│   from .lifecycle import ServiceLifecycle
│   from .services.notification_service import NotificationService
│
│   # Re-export shared dependencies
│   __all__ = [
│       "ClientAuthDep",
│       "ConfigDep",
│       "LifecycleDep",
│       "LoggerDep",
│       "NotificationServiceDep",
│       "PaginationDep",
│       "PlatformContextDep",
│       "RequestContextDep",
│   ]
│
│
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       """Get service lifecycle from app state"""
│       return request.app.state.lifecycle
│
│
│   def get_config(request: Request) -> ServiceConfig:
│       """Get service config from app state"""
│       return request.app.state.config
│
│
│   # Type aliases
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
│
│
│   # Service dependencies
│   def get_notification_service(lifecycle: LifecycleDep) -> NotificationService:
│       """Get notification service"""
│       if not lifecycle.notification_service:
│           raise HTTPException(500, "Notification service not initialized")
│       return lifecycle.notification_service
│
│
│   NotificationServiceDep = Annotated[NotificationService, Depends(get_notification_service)]
│   ```
│
├── exceptions.py
│
│   ```py
│   # File: services/notification-service/src/exceptions.py
│   """
│   Notification service exceptions using shared error classes.
│
│   All exceptions are re-exported from shared.errors for consistency
│   across the platform.
│   """
│
│   from shared.utils.exceptions import (
│       ConfigurationError,
│       ConflictError,
│       DomainError,
│       ForbiddenError,
│       GlamBaseError,
│       InfrastructureError,
│       InternalError,
│       NotFoundError,
│       RateLimitExceededError,
│       RequestTimeoutError,
│       ServiceUnavailableError,
│       UnauthorizedError,
│       ValidationError,
│   )
│
│   __all__ = [
│       "ConfigurationError",
│       "ConflictError",
│       "DomainError",
│       "ForbiddenError",
│       "GlamBaseError",
│       "InfrastructureError",
│       "InternalError",
│       "NotFoundError",
│       "RateLimitExceededError",
│       "RequestTimeoutError",
│       "ServiceUnavailableError",
│       "UnauthorizedError",
│       "ValidationError",
│   ]
│   ```
│
├── lifecycle.py
│
│   ```py
│   # services/notification-service/src/lifecycle.py
│   import asyncio
│
│   from prisma import Prisma  # type: ignore[attr-defined]
│
│   from shared.messaging.jetstream_client import JetStreamClient
│   from shared.utils.logger import ServiceLogger
│
│   from .config import ServiceConfig
│   from .events.listeners import (
│       CatalogSyncCompletedListener,
│       CreditBalanceDepletedListener,
│       CreditBalanceLowListener,
│       MerchantCreatedListener,
│   )
│   from .events.publishers import NotificationEventPublisher
│   from .providers.mailhog_provider import MailhogProvider
│   from .providers.sendgrid_provider import SendGridProvider
│   from .repositories.notification_repository import NotificationRepository
│   from .services.email_service import EmailService
│   from .services.notification_service import NotificationService
│   from .services.template_service import TemplateService
│
│
│   class ServiceLifecycle:
│       """Manages all service components lifecycle"""
│
│       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│
│           # Connections
│           self.messaging_client: JetStreamClient | None = None
│           self.prisma: Prisma | None = None
│           self._db_connected = False
│
│           # Services
│           self.notification_service: NotificationService | None = None
│           self.template_service: TemplateService | None = None
│           self.email_service: EmailService | None = None
│
│           # Event handling
│           self.event_publisher: NotificationEventPublisher | None = None
│           self._listeners: list = []
│           self._tasks: list[asyncio.Task] = []
│
│       async def startup(self) -> None:
│           """Initialize all components in correct order"""
│           try:
│               self.logger.info("Starting notification service components...")
│
│               # 1. Messaging
│               await self._init_messaging()
│
│               # 2. Database
│               await self._init_database()
│
│               # 3. Services
│               self._init_services()
│
│               # 4. Event listeners
│               await self._init_listeners()
│
│               self.logger.info("Notification service started successfully")
│
│           except Exception:
│               self.logger.critical("Service startup failed", exc_info=True)
│               await self.shutdown()
│               raise
│
│       async def shutdown(self) -> None:
│           """Graceful shutdown in reverse order"""
│           self.logger.info("Shutting down notification service")
│
│           # Cancel tasks
│           for task in self._tasks:
│               task.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│
│           # Stop listeners
│           for listener in self._listeners:
│               try:
│                   await listener.stop()
│               except Exception:
│                   self.logger.error("Listener stop failed", exc_info=True)
│
│           # Close messaging
│           if self.messaging_client:
│               try:
│                   await self.messaging_client.close()
│               except Exception:
│                   self.logger.error("Messaging close failed", exc_info=True)
│
│           # Disconnect database
│           if self.prisma and self._db_connected:
│               try:
│                   await self.prisma.disconnect()
│               except Exception:
│                   self.logger.error("Prisma disconnect failed", exc_info=True)
│
│           self.logger.info("Notification service shutdown complete")
│
│       async def _init_messaging(self) -> None:
│           """Initialize NATS/JetStream"""
│           self.messaging_client = JetStreamClient(self.logger)
│           await self.messaging_client.connect([self.config.nats_url])
│           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.>", "cmd.>"])
│
│           # Initialize publisher
│           self.event_publisher = NotificationEventPublisher(self.messaging_client, self.logger)
│
│           self.logger.info("Messaging initialized")
│
│       async def _init_database(self) -> None:
│           """Initialize Prisma client"""
│           if not self.config.database_enabled:
│               self.logger.info("Database disabled")
│               return
│
│           self.prisma = Prisma()
│           try:
│               await self.prisma.connect()
│               self._db_connected = True
│               self.logger.info("Database connected")
│           except Exception as e:
│               self.logger.error(f"Database connection failed: {e}")
│               raise
│
│       def _init_services(self) -> None:
│           """Initialize business services"""
│           # Initialize template service
│           self.template_service = TemplateService(
│               template_path=self.config.template_path,
│               cache_ttl=self.config.template_cache_ttl,
│               logger=self.logger,
│           )
│
│           # Initialize email provider
│           if self.config.email_provider == "sendgrid":
│               provider = SendGridProvider(
│                   api_key=self.config.sendgrid_api_key,
│                   from_email=self.config.sendgrid_from_email,
│                   from_name=self.config.sendgrid_from_name,
│                   sandbox_mode=self.config.sendgrid_sandbox_mode,
│                   logger=self.logger,
│               )
│           else:
│               provider = MailhogProvider(
│                   smtp_host=self.config.mailhog_smtp_host,
│                   smtp_port=self.config.mailhog_smtp_port,
│                   logger=self.logger,
│               )
│
│           # Initialize email service
│           self.email_service = EmailService(provider=provider, logger=self.logger)
│
│           # Initialize notification service
│           if self._db_connected:
│               repository = NotificationRepository(self.prisma)
│               self.notification_service = NotificationService(
│                   repository=repository,
│                   template_service=self.template_service,
│                   email_service=self.email_service,
│                   logger=self.logger,
│                   max_retries=self.config.max_retries,
│               )
│
│           self.logger.info("Services initialized")
│
│       async def _init_listeners(self) -> None:
│           """Initialize event listeners"""
│           if not self.messaging_client or not self.notification_service:
│               self.logger.warning("Skipping listeners - dependencies not ready")
│               return
│
│           # Create listeners for ALL event types
│           listeners = [
│               MerchantCreatedListener(
│                   self.messaging_client, self.notification_service, self.event_publisher, self.logger
│               ),
│               CatalogSyncCompletedListener(
│                   self.messaging_client, self.notification_service, self.event_publisher, self.logger
│               ),
│               CreditBalanceLowListener(
│                   self.messaging_client, self.notification_service, self.event_publisher, self.logger
│               ),
│               CreditBalanceDepletedListener(
│                   self.messaging_client, self.notification_service, self.event_publisher, self.logger
│               ),
│           ]
│
│           # Start all listeners
│           for listener in listeners:
│               await listener.start()
│               self._listeners.append(listener)
│
│           self.logger.info(f"Started {len(listeners)} event listeners")
│   ```
│
└── main.py

    ```py
    # services/notification-service/src/main.py
    from contextlib import asynccontextmanager

    from fastapi import FastAPI

    from shared.api import create_health_router, setup_middleware
    from shared.utils import create_logger

    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    # Create singletons at module level
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)


    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Lifespan management for startup/shutdown"""
        # Store in app state for dependencies
        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger  # REQUIRED for middleware

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()


    def create_application() -> FastAPI:
        """Create FastAPI app with shared package integration"""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            description=config.service_description,
            lifespan=lifespan,
        )

        # Setup shared middleware (handles ALL errors)
        setup_middleware(app, service_name=config.service_name)

        # Add health check from shared package
        app.include_router(create_health_router(config.service_name))

        # Add notification routes
        from .api.v1 import notifications

        app.include_router(notifications.router)

        return app


    app = create_application()

    if __name__ == "__main__":
        import uvicorn

        uvicorn.run("src.main:app", host=config.api_host, port=config.api_port, reload=config.debug)
    ```

tests/
├── unit/
├── __init__.py
└── conftest.py
.python-version
Dockerfile

```
# ──────────────────────────────────────────────────────────────
# 🛠  Stage 1  ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim AS builder

# Base toolchain
RUN apt-get update -qq && apt-get install -y --no-install-recommends \
        curl ca-certificates build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install --no-cache-dir poetry==1.7.1
ENV POETRY_VIRTUALENVS_CREATE=false \
    POETRY_NO_INTERACTION=1

WORKDIR /app

# ---- 1️⃣  Copy shared lib -----------------------------------------------------
COPY shared /shared
RUN pip install --no-cache-dir -e /shared

# Make shared importable
ENV PYTHONPATH="/shared:/app"

# ---- 2️⃣  Service deps --------------------------------------------------------
COPY services/notification-service/pyproject.toml \
     services/notification-service/poetry.lock* /app/
RUN poetry install --no-root --no-ansi \
    && rm -rf ~/.cache/pypoetry ~/.cache/pip

# ---- 3️⃣  Copy service source -------------------------------------------------
COPY services/notification-service /app


# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app       /app
COPY --from=builder /shared    /shared

ENV PYTHONPATH="/shared:/app"
WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run with optimal settings for notification service
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "2"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
# services/notification-service/pyproject.toml
[tool.poetry]
name = "notification-service"
version = "1.0.0"
description = "Event-driven email notification service"
authors = ["GLAM Team <team@glamyouup.com>"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109"
uvicorn = {extras = ["standard"], version = "^0.24.0"}
prisma = "^0.11.0"
pydantic = {extras = ["email"], version = "^2.11.7"}
jinja2 = "^3.1.2"
shared = {path = "../../shared", develop = true}

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
ruff = "^0.1.9"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
```


================================================================================
Output includes file contents
================================================================================
