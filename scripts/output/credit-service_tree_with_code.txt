================================================================================
Directory Structure: /home/bellabe/glam-app/services/credit-service
================================================================================

credit-service/
.ruff_cache/
├── 0.1.9/
│   ├── 10538977516910357227
│   ├── 10639304823462590335
│   ├── 301340098857820437
│   ├── 6219543602255698162
│   ├── 7892117512583068703
│   └── 923419679920791648
├── .gitignore
└── CACHEDIR.TAG
prisma/
├── migrations/
│   ├── 20250816151707_desktop_pgt_1_cqb/
│   │   └── migration.sql
│   │
│   │       ```sql
│   │       -- CreateTable
│   │       CREATE TABLE "credit_accounts" (
│   │           "id" UUID NOT NULL,
│   │           "merchant_id" UUID NOT NULL,
│   │           "platform_name" TEXT NOT NULL,
│   │           "platform_id" TEXT NOT NULL,
│   │           "platform_domain" TEXT NOT NULL,
│   │           "balance" INTEGER NOT NULL DEFAULT 0,
│   │           "total_granted" INTEGER NOT NULL DEFAULT 0,
│   │           "total_consumed" INTEGER NOT NULL DEFAULT 0,
│   │           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updated_at" TIMESTAMPTZ(3) NOT NULL,
│   │
│   │           CONSTRAINT "credit_accounts_pkey" PRIMARY KEY ("id")
│   │       );
│   │
│   │       -- CreateTable
│   │       CREATE TABLE "credit_transactions" (
│   │           "id" UUID NOT NULL,
│   │           "account_id" UUID NOT NULL,
│   │           "merchant_id" UUID NOT NULL,
│   │           "amount" INTEGER NOT NULL,
│   │           "operation" TEXT NOT NULL,
│   │           "balance_before" INTEGER NOT NULL,
│   │           "balance_after" INTEGER NOT NULL,
│   │           "reference_type" TEXT NOT NULL,
│   │           "reference_id" TEXT NOT NULL,
│   │           "description" TEXT,
│   │           "metadata" JSONB,
│   │           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │
│   │           CONSTRAINT "credit_transactions_pkey" PRIMARY KEY ("id")
│   │       );
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "credit_accounts_merchant_id_key" ON "credit_accounts"("merchant_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_accounts_merchant_id_idx" ON "credit_accounts"("merchant_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_accounts_platform_domain_idx" ON "credit_accounts"("platform_domain");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_accounts_platform_name_platform_id_idx" ON "credit_accounts"("platform_name", "platform_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_transactions_merchant_id_created_at_idx" ON "credit_transactions"("merchant_id", "created_at");
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "credit_transactions_reference_type_reference_id_key" ON "credit_transactions"("reference_type", "reference_id");
│   │       ```
│   │
│   └── migration_lock.toml
│
│       ```toml
│       # Please do not edit this file manually
│       # It should be added in your version-control system (i.e. Git)
│       provider = "postgresql"
│       ```
│
└── schema.prisma
src/
├── api/
│   └── v1/
│       └── credits.py
│
│           ```py
│           # services/credit-service/src/api/v1/credits.py
│           from uuid import UUID
│
│           from fastapi import APIRouter, Request
│
│           from shared.api import ApiResponse, paginated_response, success_response
│           from shared.api.dependencies import (
│               ClientAuthDep,
│               PaginationDep,
│               PlatformContextDep,
│               RequestContextDep,
│           )
│           from shared.api.validation import validate_shop_context
│
│           from ...dependencies import CreditServiceDep, LoggerDep
│           from ...schemas.credit import CreditBalanceOut, TransactionListOut
│
│           router = APIRouter(prefix="/api", tags=["Credits"])
│
│
│           @router.get(
│               "/credits",
│               response_model=ApiResponse[CreditBalanceOut],
│               summary="Get credit balance",
│               description="Get current credit balance with platform context",
│           )
│           async def get_credits(
│               svc: CreditServiceDep,
│               ctx: RequestContextDep,
│               auth: ClientAuthDep,
│               platform: PlatformContextDep,
│               logger: LoggerDep,
│           ):
│               """
│               Get credit balance for authenticated merchant.
│               Returns balance with platform context.
│               """
│
│               # Validate shop context
│               validate_shop_context(
│                   client_auth=auth,
│                   platform_ctx=platform,
│                   logger=logger,
│                   expected_scope="bff:call",  # Only BFF can call
│               )
│
│               # Get balance - service raises NotFoundError if missing
│               balance = await svc.get_balance(
│                   merchant_id=UUID(auth.shop),
│                   shop_domain=platform.domain,
│                   correlation_id=ctx.correlation_id,
│               )
│
│               return success_response(data=balance, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│
│
│           @router.get(
│               "/credits/transactions",
│               response_model=ApiResponse[list[TransactionListOut]],
│               summary="Get transaction history",
│               description="Get paginated credit transaction history",
│           )
│           async def get_transactions(
│               svc: CreditServiceDep,
│               ctx: RequestContextDep,
│               auth: ClientAuthDep,
│               platform: PlatformContextDep,
│               pagination: PaginationDep,
│               request: Request,
│               logger: LoggerDep,
│           ):
│               """
│               Get credit transaction history for authenticated merchant.
│               Returns paginated list of transactions.
│               """
│
│               # Validate shop context
│               validate_shop_context(
│                   client_auth=auth,
│                   platform_ctx=platform,
│                   logger=logger,
│                   expected_scope="bff:call",
│               )
│
│               # Get transactions
│               total, transactions = await svc.get_transactions(
│                   merchant_id=UUID(auth.shop),
│                   page=pagination.page,
│                   limit=pagination.limit,
│                   correlation_id=ctx.correlation_id,
│               )
│
│               # Return paginated response
│               return paginated_response(
│                   data=transactions,
│                   page=pagination.page,
│                   limit=pagination.limit,
│                   total=total,
│                   base_url=str(request.url.path),
│                   request_id=ctx.request_id,
│                   correlation_id=ctx.correlation_id,
│               )
│           ```
│
├── events/
│   ├── listeners.py
│   │
│   │   ```py
│   │   # services/credit-service/src/events/listeners.py
│   │   from shared.api.correlation import set_correlation_context
│   │   from shared.messaging.listener import Listener
│   │   from shared.utils.exceptions import ValidationError
│   │
│   │   from ..schemas.events import (
│   │       CreditsPurchasedPayload,
│   │       MatchCompletedPayload,
│   │       MerchantCreatedPayload,
│   │       TrialStartedPayload,
│   │   )
│   │
│   │
│   │   class MerchantCreatedListener(Listener):
│   │       """Listen for merchant creation"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.merchant.created.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "credit-service-merchant-handler"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "credit-service"
│   │
│   │       def __init__(self, js_client, service, publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.service = service
│   │           self.publisher = publisher
│   │
│   │       async def on_message(self, data: dict) -> None:
│   │           """Process merchant created event"""
│   │           # Set correlation context from event
│   │           correlation_id = data.get("correlation_id", "unknown")
│   │           set_correlation_context(correlation_id)
│   │
│   │           try:
│   │               payload = MerchantCreatedPayload(**data)
│   │               await self.service.handle_merchant_created(payload, correlation_id)
│   │               self.logger.info(f"Credit account created for merchant {payload.merchant_id}")
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid merchant event: {e}")
│   │               return  # ACK to drop invalid message
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to create credit account: {e}")
│   │               raise  # NACK for retry
│   │
│   │
│   │   class TrialStartedListener(Listener):
│   │       """Listen for trial started events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.billing.trial.started.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "credit-service-trial-handler"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "credit-service"
│   │
│   │       def __init__(self, js_client, service, publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.service = service
│   │           self.publisher = publisher
│   │
│   │       async def on_message(self, data: dict) -> None:
│   │           """Process trial started event"""
│   │           correlation_id = data.get("correlation_id", "unknown")
│   │           set_correlation_context(correlation_id)
│   │
│   │           try:
│   │               payload = TrialStartedPayload(**data)
│   │               result = await self.service.handle_trial_started(payload, correlation_id)
│   │
│   │               # Publish granted event
│   │               await self.publisher.credits_granted(result)
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid trial event: {e}")
│   │               return  # ACK
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to grant trial credits: {e}")
│   │               raise  # NACK
│   │
│   │
│   │   class CreditsPurchasedListener(Listener):
│   │       """Listen for credit purchase events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.billing.credits.purchased.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "credit-service-purchase-handler"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "credit-service"
│   │
│   │       def __init__(self, js_client, service, publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.service = service
│   │           self.publisher = publisher
│   │
│   │       async def on_message(self, data: dict) -> None:
│   │           """Process credits purchased event"""
│   │           correlation_id = data.get("correlation_id", "unknown")
│   │           set_correlation_context(correlation_id)
│   │
│   │           try:
│   │               payload = CreditsPurchasedPayload(**data)
│   │               result = await self.service.handle_credits_purchased(payload, correlation_id)
│   │
│   │               # Publish granted event
│   │               await self.publisher.credits_granted(result)
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid purchase event: {e}")
│   │               return  # ACK
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to add purchased credits: {e}")
│   │               raise  # NACK
│   │
│   │
│   │   class MatchCompletedListener(Listener):
│   │       """Listen for AI match completion"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.ai.match.completed.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "credit-service-match-handler"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "credit-service"
│   │
│   │       def __init__(self, js_client, service, publisher, logger):
│   │           super().__init__(js_client, logger)
│   │           self.service = service
│   │           self.publisher = publisher
│   │
│   │       async def on_message(self, data: dict) -> None:
│   │           """Process match completed event"""
│   │           correlation_id = data.get("correlation_id", "unknown")
│   │           set_correlation_context(correlation_id)
│   │
│   │           try:
│   │               payload = MatchCompletedPayload(**data)
│   │               result = await self.service.handle_match_completed(payload, correlation_id)
│   │
│   │               # Publish appropriate events based on result
│   │               if result.get("insufficient"):
│   │                   await self.publisher.credits_insufficient(result)
│   │               else:
│   │                   await self.publisher.credits_consumed(result)
│   │
│   │                   if result.get("low_balance"):
│   │                       await self.publisher.credits_low_balance(result)
│   │
│   │                   if result.get("exhausted"):
│   │                       await self.publisher.credits_exhausted(result)
│   │
│   │           except ValidationError as e:
│   │               self.logger.error(f"Invalid match event: {e}")
│   │               return  # ACK
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to consume credit: {e}")
│   │               raise  # NACK
│   │   ```
│   │
│   └── publishers.py
│
│       ```py
│       # services/credit-service/src/events/publishers.py
│       from shared.api.correlation import get_correlation_context
│       from shared.messaging.publisher import Publisher
│
│       from ..schemas.events import (
│           CreditsConsumedPayload,
│           CreditsExhaustedPayload,
│           CreditsGrantedPayload,
│           CreditsInsufficientPayload,
│           CreditsLowBalancePayload,
│       )
│
│
│       class CreditEventPublisher(Publisher):
│           """Publish credit events"""
│
│           @property
│           def service_name(self) -> str:
│               return "credit-service"
│
│           async def credits_granted(self, data: dict) -> str:
│               """Publish credits granted event"""
│               payload = CreditsGrantedPayload(
│                   merchant_id=data["merchant_id"],
│                   amount=data["amount"],
│                   balance=data["balance"],
│                   reference_type=data["reference_type"],
│                   reference_id=data["reference_id"],
│                   platform_name=data["platform_name"],
│               )
│
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.credits.granted.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│               )
│
│           async def credits_consumed(self, data: dict) -> str:
│               """Publish credits consumed event"""
│               payload = CreditsConsumedPayload(
│                   merchant_id=data["merchant_id"],
│                   amount=data["amount"],
│                   balance=data["balance"],
│                   reference_type=data["reference_type"],
│                   reference_id=data["reference_id"],
│                   platform_name=data["platform_name"],
│               )
│
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.credits.consumed.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│               )
│
│           async def credits_insufficient(self, data: dict) -> str:
│               """Publish insufficient credits event"""
│               payload = CreditsInsufficientPayload(
│                   merchant_id=data["merchant_id"],
│                   attempted_amount=data["attempted_amount"],
│                   balance=data["balance"],
│                   platform_name=data["platform_name"],
│               )
│
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.credits.insufficient.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│               )
│
│           async def credits_low_balance(self, data: dict) -> str:
│               """Publish low balance warning"""
│               payload = CreditsLowBalancePayload(
│                   merchant_id=data["merchant_id"],
│                   balance=data["balance"],
│                   threshold=data["threshold"],
│                   platform_name=data["platform_name"],
│               )
│
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.credits.low_balance.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│               )
│
│           async def credits_exhausted(self, data: dict) -> str:
│               """Publish credits exhausted event"""
│               payload = CreditsExhaustedPayload(merchant_id=data["merchant_id"], platform_name=data["platform_name"])
│
│               correlation_id = get_correlation_context() or "unknown"
│
│               return await self.publish_event(
│                   subject="evt.credits.exhausted.v1",
│                   data=payload.model_dump(mode="json"),
│                   correlation_id=correlation_id,
│               )
│       ```
│
├── repositories/
│   └── credit_repository.py
│
│       ```py
│       # services/credit-service/src/repositories/credit_repository.py
│       from uuid import UUID
│
│       from prisma import Prisma  # type: ignore[attr-defined]
│       from prisma.errors import UniqueViolationError
│
│       from shared.utils.exceptions import NotFoundError
│
│
│       class CreditRepository:
│           """Repository for credit operations using Prisma"""
│
│           def __init__(self, prisma: Prisma):
│               self.prisma = prisma
│
│           async def create_account(
│               self,
│               merchant_id: UUID,
│               platform_name: str,
│               platform_shop_id: str,
│               shop_domain: str,
│           ) -> dict:
│               """Create credit account with platform context"""
│               try:
│                   account = await self.prisma.creditaccount.create(
│                       data={
│                           "merchant_id": str(merchant_id),
│                           "platform_name": platform_name,
│                           "platform_shop_id": platform_shop_id,
│                           "shop_domain": shop_domain,
│                           "balance": 0,
│                           "total_granted": 0,
│                           "total_consumed": 0,
│                       }
│                   )
│                   return account
│               except UniqueViolationError:
│                   # Account already exists
│                   existing = await self.find_by_merchant_id(merchant_id)
│                   if existing:
│                       return existing
│                   raise
│
│           async def find_by_merchant_id(self, merchant_id: UUID) -> dict | None:
│               """Find credit account by merchant ID"""
│               account = await self.prisma.creditaccount.find_unique(where={"merchant_id": str(merchant_id)})
│               return account
│
│           async def find_by_shop_domain(self, shop_domain: str) -> dict | None:
│               """Find credit account by platform domain"""
│               account = await self.prisma.creditaccount.find_first(where={"shop_domain": shop_domain})
│               return account
│
│           async def update_balance(
│               self,
│               merchant_id: UUID,
│               amount: int,
│               operation: str,  # 'credit' or 'debit'
│               reference_type: str,
│               reference_id: str,
│               description: str | None = None,
│               metadata: dict | None = None,
│           ) -> tuple[dict, dict]:
│               """
│               Update balance with transaction record.
│               Returns (account, transaction) tuple.
│               Uses transaction to ensure consistency.
│               """
│               async with self.prisma.tx() as tx:
│                   # Get current account with lock
│                   account = await tx.creditaccount.find_unique(where={"merchant_id": str(merchant_id)})
│
│                   if not account:
│                       raise NotFoundError(
│                           message=f"Credit account not found for merchant {merchant_id}",
│                           resource="credit_account",
│                           resource_id=str(merchant_id),
│                       )
│
│                   # Calculate new balance
│                   balance_before = account.balance
│                   if operation == "credit":
│                       balance_after = balance_before + amount
│                       total_granted = account.total_granted + amount
│                       total_consumed = account.total_consumed
│                   else:  # debit
│                       balance_after = max(0, balance_before - amount)  # Never negative
│                       actual_debit = balance_before - balance_after
│                       total_granted = account.total_granted
│                       total_consumed = account.total_consumed + actual_debit
│
│                   # Check for existing transaction (idempotency)
│                   existing_tx = await tx.credittransaction.find_unique(
│                       where={
│                           "reference_type_reference_id": {
│                               "reference_type": reference_type,
│                               "reference_id": reference_id,
│                           }
│                       }
│                   )
│
│                   if existing_tx:
│                       # Return existing without modification
│                       return account, existing_tx
│
│                   # Create transaction record
│                   transaction = await tx.credittransaction.create(
│                       data={
│                           "account_id": account.id,
│                           "merchant_id": str(merchant_id),
│                           "amount": amount,
│                           "operation": operation,
│                           "balance_before": balance_before,
│                           "balance_after": balance_after,
│                           "reference_type": reference_type,
│                           "reference_id": reference_id,
│                           "description": description,
│                           "metadata": metadata,
│                       }
│                   )
│
│                   # Update account balance
│                   account = await tx.creditaccount.update(
│                       where={"merchant_id": str(merchant_id)},
│                       data={
│                           "balance": balance_after,
│                           "total_granted": total_granted,
│                           "total_consumed": total_consumed,
│                       },
│                   )
│
│                   return account, transaction
│
│           async def get_transactions(self, merchant_id: UUID, skip: int = 0, take: int = 50) -> tuple[int, list[dict]]:
│               """Get transaction history with pagination"""
│
│               # Count total
│               total = await self.prisma.credittransaction.count(where={"merchant_id": str(merchant_id)})
│
│               # Get page
│               transactions = await self.prisma.credittransaction.find_many(
│                   where={"merchant_id": str(merchant_id)},
│                   order_by={"created_at": "desc"},
│                   skip=skip,
│                   take=take,
│               )
│
│               return total, transactions
│       ```
│
├── schemas/
│   ├── credit.py
│   │
│   │   ```py
│   │   # services/credit-service/src/schemas/credit.py
│   │   from datetime import datetime
│   │   from uuid import UUID
│   │
│   │   from pydantic import BaseModel, ConfigDict, Field
│   │
│   │
│   │   # Output DTOs
│   │   class CreditBalanceOut(BaseModel):
│   │       """Credit balance response"""
│   │
│   │       balance: int = Field(..., description="Current credit balance")
│   │       total_granted: int = Field(..., description="Total credits ever granted")
│   │       total_consumed: int = Field(..., description="Total credits ever consumed")
│   │       platform_name: str = Field(..., description="Platform name (shopify, etc)")
│   │       shop_domain: str = Field(..., description="Platform domain")
│   │
│   │       model_config = ConfigDict(from_attributes=True)
│   │
│   │
│   │   class CreditTransactionOut(BaseModel):
│   │       """Credit transaction history item"""
│   │
│   │       id: UUID
│   │       amount: int
│   │       operation: str  # 'credit' or 'debit'
│   │       balance_before: int
│   │       balance_after: int
│   │       reference_type: str
│   │       reference_id: str
│   │       description: str | None = None
│   │       metadata: dict | None = None
│   │       created_at: datetime
│   │
│   │       model_config = ConfigDict(from_attributes=True)
│   │
│   │
│   │   class TransactionListOut(BaseModel):
│   │       """Paginated transaction list"""
│   │
│   │       transactions: list[CreditTransactionOut]
│   │       total: int
│   │       page: int
│   │       limit: int
│   │   ```
│   │
│   └── events.py
│
│       ```py
│       # services/credit-service/src/schemas/events.py
│       from datetime import datetime
│       from uuid import UUID
│
│       from pydantic import BaseModel
│
│
│       # Event payloads consumed
│       class MerchantCreatedPayload(BaseModel):
│           """Merchant created event from merchant service"""
│
│           merchant_id: UUID
│           platform: str  # 'shopify', 'woocommerce', etc
│           shop_domain: str
│           shop_gid: str  # Platform-specific ID
│
│
│       class TrialStartedPayload(BaseModel):
│           """Trial started event from billing service"""
│
│           merchant_id: UUID
│           ends_at: datetime
│
│
│       class CreditsPurchasedPayload(BaseModel):
│           """Credits purchased event from billing service"""
│
│           merchant_id: UUID
│           credits: int
│           purchase_id: str
│
│
│       class MatchCompletedPayload(BaseModel):
│           """Match completed event from recommendation service"""
│
│           merchant_id: UUID
│           match_id: str
│           shopper_id: str
│           matched_items_count: int
│
│
│       # Event payloads published
│       class CreditsGrantedPayload(BaseModel):
│           """Credits granted event"""
│
│           merchant_id: UUID
│           amount: int
│           balance: int
│           reference_type: str
│           reference_id: str
│           platform_name: str
│
│
│       class CreditsConsumedPayload(BaseModel):
│           """Credits consumed event"""
│
│           merchant_id: UUID
│           amount: int
│           balance: int
│           reference_type: str
│           reference_id: str
│           platform_name: str
│
│
│       class CreditsInsufficientPayload(BaseModel):
│           """Credits insufficient event"""
│
│           merchant_id: UUID
│           attempted_amount: int
│           balance: int
│           platform_name: str
│
│
│       class CreditsLowBalancePayload(BaseModel):
│           """Low balance warning event"""
│
│           merchant_id: UUID
│           balance: int
│           threshold: int
│           platform_name: str
│
│
│       class CreditsExhaustedPayload(BaseModel):
│           """Credits exhausted event"""
│
│           merchant_id: UUID
│           platform_name: str
│       ```
│
├── services/
│   └── credit_service.py
│
│       ```py
│       # services/credit-service/src/services/credit_service.py
│       from uuid import UUID
│
│       from shared.utils import generate_idempotency_key
│       from shared.utils.exceptions import NotFoundError
│       from shared.utils.logger import ServiceLogger
│
│       from ..repositories.credit_repository import CreditRepository
│       from ..schemas.credit import CreditBalanceOut, CreditTransactionOut
│       from ..schemas.events import (
│           CreditsPurchasedPayload,
│           MatchCompletedPayload,
│           MerchantCreatedPayload,
│           TrialStartedPayload,
│       )
│
│
│       class CreditService:
│           """Credit business logic service"""
│
│           def __init__(self, repository: CreditRepository, config, logger: ServiceLogger):
│               self.repository = repository
│               self.config = config
│               self.logger = logger
│
│           # Read operations (for API)
│
│           async def get_balance(self, merchant_id: UUID, shop_domain: str, correlation_id: str) -> CreditBalanceOut:
│               """Get credit balance with platform context"""
│
│               # Find by merchant_id
│               account = await self.repository.find_by_merchant_id(merchant_id)
│
│               if not account:
│                   # Also try by domain for backwards compatibility
│                   account = await self.repository.find_by_shop_domain(shop_domain)
│
│               if not account:
│                   raise NotFoundError(
│                       message="Credit account not found",
│                       resource="credit_account",
│                       resource_id=str(merchant_id),
│                   )
│
│               # Verify domain matches
│               if account.shop_domain != shop_domain:
│                   self.logger.warning(
│                       "Platform domain mismatch in credit lookup",
│                       extra={
│                           "correlation_id": correlation_id,
│                           "merchant_id": str(merchant_id),
│                           "expected_domain": shop_domain,
│                           "account_domain": account.shop_domain,
│                       },
│                   )
│
│               return CreditBalanceOut(
│                   balance=account.balance,
│                   total_granted=account.total_granted,
│                   total_consumed=account.total_consumed,
│                   platform_name=account.platform_name,
│                   shop_domain=account.shop_domain,
│               )
│
│           async def get_transactions(
│               self, merchant_id: UUID, page: int, limit: int, correlation_id: str
│           ) -> tuple[int, list[CreditTransactionOut]]:
│               """Get transaction history"""
│
│               # Check account exists
│               account = await self.repository.find_by_merchant_id(merchant_id)
│               if not account:
│                   raise NotFoundError(
│                       message="Credit account not found",
│                       resource="credit_account",
│                       resource_id=str(merchant_id),
│                   )
│
│               skip = (page - 1) * limit
│               total, transactions = await self.repository.get_transactions(merchant_id, skip, limit)
│
│               return total, [CreditTransactionOut.model_validate(tx) for tx in transactions]
│
│           # Event handlers (write operations)
│
│           async def handle_merchant_created(self, event: MerchantCreatedPayload, correlation_id: str) -> dict:
│               """Create credit account for new merchant"""
│
│               self.logger.info(
│                   "Creating credit account for new merchant",
│                   extra={
│                       "correlation_id": correlation_id,
│                       "merchant_id": str(event.merchant_id),
│                       "platform": event.platform,
│                       "shop_domain": event.shop_domain,
│                   },
│               )
│
│               account = await self.repository.create_account(
│                   merchant_id=event.merchant_id,
│                   platform_name=event.platform,
│                   platform_shop_id=event.shop_gid,
│                   shop_domain=event.shop_domain,
│               )
│
│               return {
│                   "merchant_id": event.merchant_id,
│                   "platform_name": account.platform_name,
│                   "balance": account.balance,
│               }
│
│           async def handle_trial_started(self, event: TrialStartedPayload, correlation_id: str) -> dict:
│               """Grant trial credits"""
│
│               self.logger.info(
│                   "Granting trial credits",
│                   extra={
│                       "correlation_id": correlation_id,
│                       "merchant_id": str(event.merchant_id),
│                       "credits": self.config.trial_credits,
│                   },
│               )
│
│               # Generate idempotency key
│               reference_id = generate_idempotency_key("TRIAL", "GRANT", event.merchant_id)
│
│               account, transaction = await self.repository.update_balance(
│                   merchant_id=event.merchant_id,
│                   amount=self.config.trial_credits,
│                   operation="credit",
│                   reference_type="trial",
│                   reference_id=reference_id,
│                   description="Trial credits granted",
│               )
│
│               return {
│                   "merchant_id": event.merchant_id,
│                   "amount": self.config.trial_credits,
│                   "balance": account.balance,
│                   "reference_type": "trial",
│                   "reference_id": reference_id,
│                   "platform_name": account.platform_name,
│               }
│
│           async def handle_credits_purchased(self, event: CreditsPurchasedPayload, correlation_id: str) -> dict:
│               """Add purchased credits"""
│
│               self.logger.info(
│                   "Adding purchased credits",
│                   extra={
│                       "correlation_id": correlation_id,
│                       "merchant_id": str(event.merchant_id),
│                       "credits": event.credits,
│                       "purchase_id": event.purchase_id,
│                   },
│               )
│
│               account, transaction = await self.repository.update_balance(
│                   merchant_id=event.merchant_id,
│                   amount=event.credits,
│                   operation="credit",
│                   reference_type="purchase",
│                   reference_id=event.purchase_id,
│                   description=f"Purchased {event.credits} credits",
│               )
│
│               return {
│                   "merchant_id": event.merchant_id,
│                   "amount": event.credits,
│                   "balance": account.balance,
│                   "reference_type": "purchase",
│                   "reference_id": event.purchase_id,
│                   "platform_name": account.platform_name,
│               }
│
│           async def handle_match_completed(self, event: MatchCompletedPayload, correlation_id: str) -> dict:
│               """Consume credit for match"""
│
│               self.logger.info(
│                   "Consuming credit for match",
│                   extra={
│                       "correlation_id": correlation_id,
│                       "merchant_id": str(event.merchant_id),
│                       "match_id": event.match_id,
│                   },
│               )
│
│               # Check balance before consuming
│               account = await self.repository.find_by_merchant_id(event.merchant_id)
│               if not account:
│                   self.logger.error(
│                       "No credit account for merchant",
│                       extra={
│                           "correlation_id": correlation_id,
│                           "merchant_id": str(event.merchant_id),
│                       },
│                   )
│                   raise NotFoundError(
│                       message="Credit account not found",
│                       resource="credit_account",
│                       resource_id=str(event.merchant_id),
│                   )
│
│               if account.balance <= 0:
│                   # Insufficient credits
│                   return {
│                       "merchant_id": event.merchant_id,
│                       "insufficient": True,
│                       "attempted_amount": 1,
│                       "balance": 0,
│                       "platform_name": account.platform_name,
│                   }
│
│               # Consume credit
│               account, transaction = await self.repository.update_balance(
│                   merchant_id=event.merchant_id,
│                   amount=1,
│                   operation="debit",
│                   reference_type="match",
│                   reference_id=event.match_id,
│                   description=f"Match for shopper {event.shopper_id}",
│                   metadata={
│                       "shopper_id": event.shopper_id,
│                       "matched_items_count": event.matched_items_count,
│                   },
│               )
│
│               result = {
│                   "merchant_id": event.merchant_id,
│                   "amount": 1,
│                   "balance": account.balance,
│                   "reference_type": "match",
│                   "reference_id": event.match_id,
│                   "platform_name": account.platform_name,
│               }
│
│               # Check for low balance
│               if account.balance < self.config.low_balance_threshold:
│                   result["low_balance"] = True
│                   result["threshold"] = self.config.low_balance_threshold
│
│               # Check for exhausted
│               if account.balance == 0:
│                   result["exhausted"] = True
│
│               return result
│       ```
│
├── __init__.py
├── config.py
│
│   ```py
│   # services/credit-service/src/config.py
│   import os
│   from functools import lru_cache
│
│   from pydantic import BaseModel, ConfigDict, Field, model_validator
│
│   from shared.utils import ConfigurationError, load_root_env
│
│
│   class ServiceConfig(BaseModel):
│       """Credit service configuration"""
│
│       model_config = ConfigDict(
│           extra="ignore",
│           populate_by_name=True,
│       )
│
│       # Service identification
│       service_name: str = "credit-service"
│       service_version: str = "1.0.0"
│       service_description: str = "Credit balance accounting service"
│       debug: bool = Field(default=False, alias="DEBUG")
│
│       # Environment
│       environment: str = Field(..., alias="APP_ENV")
│       api_external_port: int = Field(..., alias="CREDIT_API_EXTERNAL_PORT")
│       database_enabled: bool = Field(default=True, alias="CREDIT_DB_ENABLED")
│
│       # Required secrets
│       database_url: str = Field(..., alias="DATABASE_URL")
│       client_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
│       internal_jwt_secret: str = Field(..., alias="INTERNAL_JWT_SECRET")
│
│       # API configuration
│       api_host: str = "0.0.0.0"
│
│       # Business rules
│       trial_credits: int = 500
│       low_balance_threshold: int = 100
│
│       # Logging
│       logging_level: str = "INFO"
│       logging_format: str = "json"
│
│       @property
│       def nats_url(self) -> str:
│           """NATS URL for event system"""
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "nats://nats:4222"
│           return "nats://localhost:4222"
│
│       @property
│       def api_port(self) -> int:
│           """Port based on environment"""
│           in_container = os.path.exists("/.dockerenv")
│           return 8000 if in_container else self.api_external_port
│
│       @model_validator(mode="after")
│       def validate_config(self):
│           if self.database_enabled and not self.database_url:
│               raise ValueError("DATABASE_URL required when database is enabled")
│           return self
│
│
│   @lru_cache
│   def get_service_config() -> ServiceConfig:
│       """Load configuration once"""
│       try:
│           load_root_env()
│           return ServiceConfig(**os.environ)  # type: ignore[arg-type]
│       except Exception as e:
│           raise ConfigurationError(f"Failed to load config: {e}", config_key="credit-service") from e
│   ```
│
├── dependencies.py
│
│   ```py
│   # services/credit-service/src/dependencies.py
│   from typing import Annotated
│
│   from fastapi import Depends, HTTPException, Request
│
│   from shared.api.dependencies import (
│       ClientAuthDep,
│       LoggerDep,
│       PaginationDep,
│       PlatformContextDep,
│       RequestContextDep,
│   )
│
│   from .config import ServiceConfig
│   from .lifecycle import ServiceLifecycle
│   from .services.credit_service import CreditService
│
│   # Re-export shared dependencies
│   __all__ = [
│       "ClientAuthDep",
│       "ConfigDep",
│       "CreditServiceDep",
│       "LifecycleDep",
│       "LoggerDep",
│       "PaginationDep",
│       "PlatformContextDep",
│       "RequestContextDep",
│   ]
│
│
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       """Get service lifecycle from app state"""
│       return request.app.state.lifecycle
│
│
│   def get_config(request: Request):
│       """Get service config from app state"""
│       return request.app.state.config
│
│
│   # Type aliases
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
│
│
│   # Service dependencies
│   def get_credit_service(lifecycle: LifecycleDep) -> CreditService:
│       """Get credit service"""
│       if not lifecycle.credit_service:
│           raise HTTPException(500, "Credit service not initialized")
│       return lifecycle.credit_service
│
│
│   CreditServiceDep = Annotated[CreditService, Depends(get_credit_service)]
│   ```
│
├── exceptions.py
│
│   ```py
│   # File: services/credits/src/exceptions.py
│
│   from shared.utils.exceptions import DomainError
│
│
│   class CreditAccountNotFoundError(DomainError):
│       """Credit account not found"""
│
│       code = "CREDIT_ACCOUNT_NOT_FOUND"
│       status = 404
│
│       def __init__(self, merchant_id: str):
│           super().__init__(
│               message=f"Credit account not found for merchant {merchant_id}",
│               details={"merchant_id": merchant_id},
│           )
│
│
│   class InsufficientCreditsError(DomainError):
│       """Insufficient credits for operation"""
│
│       code = "INSUFFICIENT_CREDITS"
│       status = 400
│
│       def __init__(self, merchant_id: str, balance: int, required: int):
│           super().__init__(
│               message=f"Insufficient credits. Balance: {balance}, Required: {required}",
│               details={
│                   "merchant_id": merchant_id,
│                   "current_balance": balance,
│                   "required_amount": required,
│               },
│           )
│
│
│   class DuplicateTransactionError(DomainError):
│       """Duplicate transaction attempted"""
│
│       code = "DUPLICATE_TRANSACTION"
│       status = 409
│
│       def __init__(self, reference_type: str, reference_id: str):
│           super().__init__(
│               message=f"Transaction already processed: {reference_type}:{reference_id}",
│               details={"reference_type": reference_type, "reference_id": reference_id},
│           )
│   ```
│
├── lifecycle.py
│
│   ```py
│   # services/credit-service/src/lifecycle.py
│   import asyncio
│
│   from prisma import Prisma  # type: ignore[attr-defined]
│
│   from shared.messaging.jetstream_client import JetStreamClient
│   from shared.utils.logger import ServiceLogger
│
│   from .config import ServiceConfig
│   from .events.listeners import (
│       CreditsPurchasedListener,
│       MatchCompletedListener,
│       MerchantCreatedListener,
│       TrialStartedListener,
│   )
│   from .events.publishers import CreditEventPublisher
│   from .repositories.credit_repository import CreditRepository
│   from .services.credit_service import CreditService
│
│
│   class ServiceLifecycle:
│       """Manages all service components lifecycle"""
│
│       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│
│           # Connections
│           self.messaging_client: JetStreamClient | None = None
│           self.prisma: Prisma | None = None
│           self._db_connected = False
│
│           # Components
│           self.event_publisher: CreditEventPublisher | None = None
│           self.credit_repo: CreditRepository | None = None
│           self.credit_service: CreditService | None = None
│
│           # Listeners
│           self._listeners: list = []
│           self._tasks: list[asyncio.Task] = []
│
│       async def startup(self) -> None:
│           """Initialize all components in correct order"""
│           try:
│               self.logger.info("Starting credit service components...")
│
│               # 1. Messaging
│               await self._init_messaging()
│
│               # 2. Database
│               await self._init_database()
│
│               # 3. Repositories
│               self._init_repositories()
│
│               # 4. Services
│               self._init_services()
│
│               # 5. Event listeners
│               await self._init_listeners()
│
│               self.logger.info("Credit service started successfully")
│
│           except Exception:
│               self.logger.critical("Service startup failed", exc_info=True)
│               await self.shutdown()
│               raise
│
│       async def shutdown(self) -> None:
│           """Graceful shutdown in reverse order"""
│           self.logger.info("Shutting down credit service")
│
│           # Cancel tasks
│           for task in self._tasks:
│               task.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│
│           # Stop listeners
│           for listener in self._listeners:
│               try:
│                   await listener.stop()
│               except Exception:
│                   self.logger.error("Listener stop failed", exc_info=True)
│
│           # Close messaging
│           if self.messaging_client:
│               try:
│                   await self.messaging_client.close()
│               except Exception:
│                   self.logger.error("Messaging close failed", exc_info=True)
│
│           # Disconnect database
│           if self.prisma and self._db_connected:
│               try:
│                   await self.prisma.disconnect()
│               except Exception:
│                   self.logger.error("Prisma disconnect failed", exc_info=True)
│
│           self.logger.info("Credit service shutdown complete")
│
│       async def _init_messaging(self) -> None:
│           """Initialize NATS/JetStream"""
│           self.messaging_client = JetStreamClient(self.logger)
│           await self.messaging_client.connect([self.config.nats_url])
│           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.>", "cmd.>"])
│
│           # Initialize publisher
│           self.event_publisher = CreditEventPublisher(jetstream_client=self.messaging_client, logger=self.logger)
│
│           self.logger.info("Messaging client and publisher initialized")
│
│       async def _init_database(self) -> None:
│           """Initialize Prisma client"""
│           if not self.config.database_enabled:
│               self.logger.info("Database disabled")
│               return
│
│           self.prisma = Prisma()
│           try:
│               await self.prisma.connect()
│               self._db_connected = True
│               self.logger.info("Prisma connected")
│           except Exception as e:
│               self.logger.error(f"Prisma connect failed: {e}", exc_info=True)
│               raise
│
│       def _init_repositories(self) -> None:
│           """Initialize repositories"""
│           if not self._db_connected:
│               self.logger.warning("Database not connected")
│               return
│
│           self.credit_repo = CreditRepository(self.prisma)
│           self.logger.info("Credit repository initialized")
│
│       def _init_services(self) -> None:
│           """Initialize business services"""
│           if not self.credit_repo:
│               raise RuntimeError("Credit repository not initialized")
│
│           self.credit_service = CreditService(repository=self.credit_repo, config=self.config, logger=self.logger)
│           self.logger.info("Credit service initialized")
│
│       async def _init_listeners(self) -> None:
│           """Initialize and start event listeners"""
│           if not self.messaging_client or not self.credit_service:
│               raise RuntimeError("Dependencies not ready")
│
│           # Create listeners
│           listeners = [
│               MerchantCreatedListener(
│                   js_client=self.messaging_client,
│                   service=self.credit_service,
│                   publisher=self.event_publisher,
│                   logger=self.logger,
│               ),
│               TrialStartedListener(
│                   js_client=self.messaging_client,
│                   service=self.credit_service,
│                   publisher=self.event_publisher,
│                   logger=self.logger,
│               ),
│               CreditsPurchasedListener(
│                   js_client=self.messaging_client,
│                   service=self.credit_service,
│                   publisher=self.event_publisher,
│                   logger=self.logger,
│               ),
│               MatchCompletedListener(
│                   js_client=self.messaging_client,
│                   service=self.credit_service,
│                   publisher=self.event_publisher,
│                   logger=self.logger,
│               ),
│           ]
│
│           # Start all listeners
│           for listener in listeners:
│               await listener.start()
│               self._listeners.append(listener)
│
│           self.logger.info(f"Started {len(listeners)} event listeners")
│   ```
│
└── main.py

    ```py
    # services/credit-service/src/main.py
    from contextlib import asynccontextmanager

    from fastapi import FastAPI

    from shared.api import create_health_router, setup_middleware
    from shared.utils import create_logger

    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    # Create singletons at module level
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)


    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Lifespan management for startup/shutdown"""
        # Store in app state for dependencies
        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger  # REQUIRED for middleware

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()


    def create_application() -> FastAPI:
        """Create FastAPI app with shared package integration"""

        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            description=config.service_description,
            lifespan=lifespan,
        )

        # Setup shared middleware (handles ALL errors)
        setup_middleware(app, service_name=config.service_name)

        # Add health check from shared package
        app.include_router(create_health_router(config.service_name))

        # Add credit API routes
        from .api.v1 import credits

        app.include_router(credits.router)

        return app


    app = create_application()

    if __name__ == "__main__":
        import uvicorn

        uvicorn.run("src.main:app", host=config.api_host, port=config.api_port, reload=config.debug)
    ```

tests/
├── unit/
│   └── __init__.py
├── __init__.py
└── conftest.py

    ```py
    import os

    import pytest
    import pytest_asyncio
    import uuid7
    from httpx import AsyncClient
    from prisma import Prisma
    from testcontainers.postgres import PostgresContainer
    from testcontainers.redis import RedisContainer

    from shared.api.correlation import set_correlation_context


    @pytest.fixture(scope="session", autouse=True)
    def setup_test_config():
        """Set up test configuration"""
        os.environ["ENVIRONMENT"] = "test"
        os.environ["CREDIT_DB_PASSWORD"] = "test_password"
        os.environ["CREDIT_ADMIN_TOKEN"] = "test_admin_token"


    @pytest.fixture(scope="session")
    def anyio_backend():
        return "asyncio"


    @pytest_asyncio.fixture(scope="session")
    async def postgres_container():
        """PostgreSQL test container"""
        with PostgresContainer("postgres:15-alpine") as postgres:
            db_url = postgres.get_connection_url()
            db_url = db_url.replace("psycopg2", "asyncpg")
            os.environ["DATABASE_URL"] = db_url
            yield postgres


    @pytest_asyncio.fixture(scope="session")
    async def redis_container():
        """Redis test container"""
        with RedisContainer("redis:7-alpine") as redis:
            os.environ["REDIS_URL"] = redis.get_connection_url()
            yield redis


    @pytest_asyncio.fixture
    async def prisma_client(postgres_container):
        """Test Prisma client"""
        client = Prisma()
        await client.connect()

        # Run migrations for tests
        import subprocess

        subprocess.run(["prisma", "db", "push", "--skip-generate"], check=True)

        yield client

        # Cleanup
        await client.disconnect()


    @pytest_asyncio.fixture
    async def client(prisma_client, redis_container):
        """Test client with correlation context"""
        from src.main import app

        app.state.test_mode = True

        async with AsyncClient(app=app, base_url="http://test") as ac:
            yield ac


    @pytest.fixture
    def correlation_context():
        """Set up correlation context for tests"""
        correlation_id = str(uuid7.uuid7())
        set_correlation_context(correlation_id)
        return {"correlation_id": correlation_id}
    ```

.python-version
Dockerfile

```
# ──────────────────────────────────────────────────────────────
# 📦  Stage 1 ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim AS builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry
RUN poetry config virtualenvs.create false

# ---- 1️⃣  Install shared package dependencies
COPY shared /shared
WORKDIR /shared
RUN poetry install --no-dev

# ---- 2️⃣  Install service dependencies
WORKDIR /app
COPY services/credit-service/pyproject.toml services/credit-service/poetry.lock* ./
RUN poetry install --no-dev --no-interaction --no-ansi

# ---- 3️⃣  Copy Prisma schema and generate client
COPY services/credit-service/prisma ./prisma
RUN prisma generate

# ---- 4️⃣  Copy service code
COPY services/credit-service /app

# ---- 5️⃣  Copy config
COPY config /app/config

# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app /app
COPY --from=builder /shared /shared

ENV PYTHONPATH="/shared:/app"
ENV DOCKER_CONTAINER=1

WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run migrations and start server
CMD ["sh", "-c", "prisma migrate deploy && uvicorn src.main:app --host 0.0.0.0 --port 8000"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
[tool.poetry]
name = "credit-service"
version = "1.0.0"
description = "Credit balance accounting service"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
uvicorn = {extras = ["standard"], version = "^0.24.0"}
prisma = "^0.11.0"
pydantic = "^2.5.0"
shared = {path = "../../shared", develop = true}
fastapi = "^0.109.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
ruff = "^0.1.9"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```


================================================================================
Output includes file contents
================================================================================
