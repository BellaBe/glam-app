================================================================================
Directory Structure: /home/bellabe/glam-app/services/merchant-service
================================================================================

merchant-service/
logs/
prisma/
â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ 20250814041744_desktop_pgt_1_cqb/
â”‚   â”‚   â””â”€â”€ migration.sql
â”‚   â”‚
â”‚   â”‚       ```sql
â”‚   â”‚       -- CreateEnum
â”‚   â”‚       CREATE TYPE "MerchantStatus" AS ENUM ('PENDING', 'ACTIVE', 'PAUSED', 'SUSPENDED', 'UNINSTALLED');
â”‚   â”‚
â”‚   â”‚       -- CreateTable
â”‚   â”‚       CREATE TABLE "merchants" (
â”‚   â”‚           "id" UUID NOT NULL,
â”‚   â”‚           "platform_name" TEXT NOT NULL,
â”‚   â”‚           "platform_shop_id" TEXT NOT NULL,
â”‚   â”‚           "shop_domain" TEXT NOT NULL,
â”‚   â”‚           "name" TEXT NOT NULL,
â”‚   â”‚           "email" TEXT NOT NULL,
â”‚   â”‚           "primary_domain" TEXT,
â”‚   â”‚           "currency" TEXT NOT NULL DEFAULT 'USD',
â”‚   â”‚           "country" TEXT,
â”‚   â”‚           "platform_version" TEXT NOT NULL,
â”‚   â”‚           "scopes" TEXT,
â”‚   â”‚           "status" "MerchantStatus" NOT NULL DEFAULT 'PENDING',
â”‚   â”‚           "status_changed_at" TIMESTAMP(3),
â”‚   â”‚           "installed_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
â”‚   â”‚           "uninstalled_at" TIMESTAMP(3),
â”‚   â”‚           "last_sync_at" TIMESTAMP(3),
â”‚   â”‚           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
â”‚   â”‚           "updated_at" TIMESTAMPTZ(3) NOT NULL,
â”‚   â”‚
â”‚   â”‚           CONSTRAINT "merchants_pkey" PRIMARY KEY ("id")
â”‚   â”‚       );
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE INDEX "merchants_platform_shop_id_shop_domain_idx" ON "merchants"("platform_shop_id", "shop_domain");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE INDEX "merchants_shop_domain_idx" ON "merchants"("shop_domain");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE INDEX "merchants_status_idx" ON "merchants"("status");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE UNIQUE INDEX "merchants_platform_name_platform_shop_id_key" ON "merchants"("platform_name", "platform_shop_id");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE UNIQUE INDEX "merchants_platform_name_shop_domain_key" ON "merchants"("platform_name", "shop_domain");
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â””â”€â”€ migration_lock.toml
â”‚
â”‚       ```toml
â”‚       # Please do not edit this file manually
â”‚       # It should be added in your version-control system (i.e. Git)
â”‚       provider = "postgresql"
â”‚       ```
â”‚
â””â”€â”€ schema.prisma
src/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   ```py
â”‚   â”‚   â”‚   # services/merchant-service/src/api/v1/__init__.py
â”‚   â”‚   â”‚   from fastapi import APIRouter
â”‚   â”‚   â”‚   from .merchants import merchants_router
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   v1_router = APIRouter(prefix="/v1")
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   v1_router.include_router(merchants_router, tags=["merchants"])
â”‚   â”‚   â”‚   ```
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ merchants.py
â”‚   â”‚
â”‚   â”‚       ```py
â”‚   â”‚       # services/merchant-service/src/api/v1/merchants.py
â”‚   â”‚       from fastapi import APIRouter, status, HTTPException
â”‚   â”‚       from shared.api import ApiResponse, success_response
â”‚   â”‚       from shared.api.validation import validate_shop_context
â”‚   â”‚       from shared.api.dependencies import (
â”‚   â”‚           RequestContextDep,
â”‚   â”‚           ClientAuthDep,
â”‚   â”‚           PlatformContextDep,
â”‚   â”‚           LoggerDep
â”‚   â”‚       )
â”‚   â”‚       from ...dependencies import MerchantServiceDep
â”‚   â”‚       from ...schemas import MerchantSyncIn, MerchantSyncOut, MerchantSelfOut
â”‚   â”‚       from ...exceptions import MerchantNotFoundError
â”‚   â”‚
â”‚   â”‚       merchants_router = APIRouter(prefix="/merchants", tags=["merchants"])
â”‚   â”‚
â”‚   â”‚       @merchants_router.post(
â”‚   â”‚           "/sync",
â”‚   â”‚           response_model=ApiResponse[MerchantSyncOut],
â”‚   â”‚           status_code=status.HTTP_200_OK,
â”‚   â”‚           summary="Sync merchant from OAuth flow",
â”‚   â”‚           description="Create or update merchant after OAuth completion. Used in afterAuth hooks."
â”‚   â”‚       )
â”‚   â”‚       async def sync_merchant(
â”‚   â”‚           body: MerchantSyncIn,
â”‚   â”‚           service: MerchantServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           client_auth: ClientAuthDep,
â”‚   â”‚           platform_ctx: PlatformContextDep,
â”‚   â”‚           logger: LoggerDep,
â”‚   â”‚       ):
â”‚   â”‚           """Sync merchant after OAuth completion."""
â”‚   â”‚           validate_shop_context(
â”‚   â”‚                   client_auth=client_auth,
â”‚   â”‚                   platform_ctx=platform_ctx,
â”‚   â”‚                   logger=logger,
â”‚   â”‚                   body_platform=body.platform_name,
â”‚   â”‚                   body_domain=body.shop_domain
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           logger.set_request_context(
â”‚   â”‚               platform=platform_ctx.platform,
â”‚   â”‚               domain=platform_ctx.domain,
â”‚   â”‚               platform_shop_id=body.platform_shop_id
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           logger.info("Starting merchant sync")
â”‚   â”‚
â”‚   â”‚           try:
â”‚   â”‚               result = await service.sync_merchant(body, ctx)
â”‚   â”‚
â”‚   â”‚               logger.info(
â”‚   â”‚                   "Merchant synced successfully",
â”‚   â”‚                   extra={
â”‚   â”‚                       "merchant_id": result.merchant_id,
â”‚   â”‚                       "operation": "create" if result.created else "update"
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               return success_response(
â”‚   â”‚                   result,
â”‚   â”‚                   ctx.request_id,
â”‚   â”‚                   ctx.correlation_id
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           except Exception as e:
â”‚   â”‚               logger.error(
â”‚   â”‚                   "Merchant sync failed",
â”‚   â”‚                   extra={
â”‚   â”‚                       "error_type": type(e).__name__,
â”‚   â”‚                       "error_message": str(e)
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚               raise
â”‚   â”‚
â”‚   â”‚       @merchants_router.get(
â”‚   â”‚           "/self",
â”‚   â”‚           response_model=ApiResponse[MerchantSelfOut],
â”‚   â”‚           status_code=status.HTTP_200_OK,
â”‚   â”‚           summary="Get current merchant",
â”‚   â”‚           description="Get current merchant using platform context from headers"
â”‚   â”‚       )
â”‚   â”‚       async def get_current_merchant(
â”‚   â”‚           service: MerchantServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           client_auth: ClientAuthDep,
â”‚   â”‚           platform_ctx: PlatformContextDep,
â”‚   â”‚           logger: LoggerDep,
â”‚   â”‚       ):
â”‚   â”‚           """Get current merchant using platform context from headers."""
â”‚   â”‚
â”‚   â”‚           # Security validation
â”‚   â”‚           if client_auth.shop != platform_ctx.domain:
â”‚   â”‚               logger.warning(
â”‚   â”‚                   "Shop domain mismatch between JWT and headers",
â”‚   â”‚                   extra={
â”‚   â”‚                       "jwt_shop": client_auth.shop,
â”‚   â”‚                       "header_domain": platform_ctx.domain
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚               raise HTTPException(
â”‚   â”‚                   status_code=status.HTTP_401_UNAUTHORIZED,
â”‚   â”‚                   detail={
â”‚   â”‚                       "code": "SHOP_DOMAIN_MISMATCH",
â”‚   â”‚                       "message": "Shop domain mismatch between JWT and headers",
â”‚   â”‚                       "details": {
â”‚   â”‚                           "jwt_shop": client_auth.shop,
â”‚   â”‚                           "header_domain": platform_ctx.domain
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           logger.set_request_context(
â”‚   â”‚               platform=platform_ctx.platform,
â”‚   â”‚               domain=platform_ctx.domain
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           logger.info("Getting current merchant")
â”‚   â”‚
â”‚   â”‚           try:
â”‚   â”‚               merchant = await service.get_merchant_by_domain(
â”‚   â”‚                   shop_domain=platform_ctx.domain,
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               logger.info(
â”‚   â”‚                   "Current merchant retrieved successfully",
â”‚   â”‚                   extra={"merchant_id": merchant.id}
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               return success_response(
â”‚   â”‚                   merchant,
â”‚   â”‚                   ctx.request_id,
â”‚   â”‚                   ctx.correlation_id
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           except MerchantNotFoundError:
â”‚   â”‚               logger.warning("Current merchant not found")
â”‚   â”‚
â”‚   â”‚               raise HTTPException(
â”‚   â”‚                   status_code=status.HTTP_404_NOT_FOUND,
â”‚   â”‚                   detail={
â”‚   â”‚                       "code": "MERCHANT_NOT_FOUND",
â”‚   â”‚                       "message": "Merchant not found for current shop",
â”‚   â”‚                       "details": {
â”‚   â”‚                           "platform": platform_ctx.platform,
â”‚   â”‚                           "domain": platform_ctx.domain
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â””â”€â”€ __init__.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/api/__init__.py
â”‚       from fastapi import APIRouter
â”‚       from .v1 import v1_router
â”‚
â”‚       api_router = APIRouter(prefix="/api")
â”‚
â”‚       # Include v1 routes
â”‚       api_router.include_router(v1_router)
â”‚       ```
â”‚
â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ listeners.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   from typing import Dict
â”‚   â”‚   from shared.messaging.listener import Listener
â”‚   â”‚   from shared.messaging.jetstream_client import JetStreamClient
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚   from ..services.merchant_service import MerchantService
â”‚   â”‚   from ..events.publishers import MerchantEventPublisher
â”‚   â”‚
â”‚   â”‚   class AppUninstalledListener(Listener):
â”‚   â”‚       """Listener for app uninstalled webhook events"""
â”‚   â”‚
â”‚   â”‚       @property
â”‚   â”‚       def subject(self) -> str:
â”‚   â”‚           return "evt.webhook.app.uninstalled.v1"
â”‚   â”‚
â”‚   â”‚       @property
â”‚   â”‚       def queue_group(self) -> str:
â”‚   â”‚           return "merchant-uninstall"
â”‚   â”‚
â”‚   â”‚       @property
â”‚   â”‚       def service_name(self) -> str:
â”‚   â”‚           return "merchant-service"
â”‚   â”‚
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           js_client: JetStreamClient,
â”‚   â”‚           service: MerchantService,
â”‚   â”‚           logger: ServiceLogger
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(js_client, logger)
â”‚   â”‚           self.service = service
â”‚   â”‚
â”‚   â”‚       async def on_message(self, data: Dict) -> None:
â”‚   â”‚           """Handle app uninstalled event"""
â”‚   â”‚           try:
â”‚   â”‚               shop_domain = data.get("shop_domain")
â”‚   â”‚               uninstall_reason = data.get("uninstall_reason")
â”‚   â”‚
â”‚   â”‚               if not shop_domain:
â”‚   â”‚                   self.logger.error("Missing shop_domain in uninstall event", extra={"data": data})
â”‚   â”‚                   return
â”‚   â”‚
â”‚   â”‚               self.logger.info(
â”‚   â”‚                   f"Processing app uninstall for {shop_domain}",
â”‚   â”‚                   extra={
â”‚   â”‚                       "shop_domain": shop_domain,
â”‚   â”‚                       "uninstall_reason": uninstall_reason
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               await self.service.handle_app_uninstalled(shop_domain, uninstall_reason)
â”‚   â”‚
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.logger.error(
â”‚   â”‚                   f"Failed to process app uninstall: {e}",
â”‚   â”‚                   exc_info=True,
â”‚   â”‚                   extra={"data": data}
â”‚   â”‚               )
â”‚   â”‚               raise  # NACK for retry
â”‚   â”‚
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ publishers.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/events/publishers.py
â”‚       from datetime import datetime, timezone
â”‚       from shared.messaging.publisher import Publisher
â”‚       from ..schemas.merchant import MerchantSyncedPayload, MerchantStatusUpdatedPayload
â”‚       from prisma.enums import MerchantStatus
â”‚
â”‚       class MerchantEventPublisher(Publisher):
â”‚           """Publisher for merchant domain events"""
â”‚
â”‚           @property
â”‚           def service_name(self) -> str:
â”‚               return "merchant-service"
â”‚
â”‚           async def publish_merchant_created(
â”‚               self,
â”‚               correlation_id: str,
â”‚               merchant_id: str,
â”‚               platform_name: str,
â”‚               platform_shop_id: str,
â”‚               shop_domain: str,
â”‚               name: str,
â”‚               email: str,
â”‚               installed_at: datetime
â”‚           ) -> str:
â”‚               """Publish evt.merchant.installed event"""
â”‚
â”‚               self.logger.info(
â”‚                   "Publishing merchant installed event",
â”‚                   extra={
â”‚                       "correlation_id": correlation_id,
â”‚                       "merchant_id": merchant_id,
â”‚                       "shop_domain": shop_domain
â”‚                   }
â”‚               )
â”‚
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.installed.v1",
â”‚                   data={
â”‚                       "merchant_id": merchant_id,
â”‚                       "platform_name": platform_name,
â”‚                       "platform_shop_id": platform_shop_id,
â”‚                       "shop_domain": shop_domain,
â”‚                       "name": name,
â”‚                       "email": email,
â”‚                       "installed_at": installed_at.isoformat()
â”‚                   },
â”‚                   correlation_id=correlation_id
â”‚               )
â”‚
â”‚           async def publish_merchant_reinstalled(
â”‚               self,
â”‚               correlation_id: str,
â”‚               merchant_id: str,
â”‚               platform_shop_id: str,
â”‚               shop_domain: str,
â”‚               name: str,
â”‚               email: str
â”‚           ) -> str:
â”‚               """Publish evt.merchant.reinstalled event"""
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.reinstalled.v1",
â”‚                   data={
â”‚                       "merchant_id": merchant_id,
â”‚                       "platform_shop_id": platform_shop_id,
â”‚                       "shop_domain": shop_domain,
â”‚                       "name": name,
â”‚                       "email": email,
â”‚                       "reinstalled_at": datetime.utcnow().isoformat()
â”‚                   },
â”‚                   correlation_id=correlation_id
â”‚               )
â”‚
â”‚           async def publish_merchant_synced(
â”‚               self,
â”‚               correlation_id: str,
â”‚               payload: MerchantSyncedPayload
â”‚           ) -> str:
â”‚               """Publish evt.merchant.synced event"""
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.synced.v1",
â”‚                   data=payload.model_dump(),
â”‚                   correlation_id=correlation_id
â”‚               )
â”‚
â”‚           async def publish_status_changed(
â”‚               self,
â”‚               correlation_id: str,  # REQUIRED
â”‚               old_status: MerchantStatus,
â”‚               payload: MerchantStatusUpdatedPayload
â”‚           ) -> str:
â”‚               """Publish evt.merchant.status.changed event"""
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.status.changed.v1",
â”‚                   data={
â”‚                       **payload.model_dump(),
â”‚                       "old_status": old_status.value,
â”‚                       "changed_at": datetime.now(timezone.utc).isoformat()
â”‚                   },
â”‚                   correlation_id=correlation_id
â”‚               )
â”‚       ```
â”‚
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   # services/merchant-service/src/repositories/__init__.py
â”‚   â”‚   """Repository package for merchant service"""
â”‚   â”‚
â”‚   â”‚   from .merchant_repository import MerchantRepository
â”‚   â”‚
â”‚   â”‚   __all__ = [
â”‚   â”‚       "MerchantRepository",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ merchant_repository.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/repositories/merchant_repository.py
â”‚       from typing import Optional
â”‚       from datetime import datetime, timezone
â”‚       from prisma import Prisma
â”‚       from prisma.models import Merchant
â”‚       from prisma.enums import MerchantStatus
â”‚       from ..schemas.merchant import MerchantSyncIn
â”‚
â”‚
â”‚       class MerchantRepository:
â”‚           """Repository for Merchant operations using Prisma"""
â”‚
â”‚           def __init__(self, prisma: Prisma):
â”‚               self.prisma = prisma
â”‚
â”‚           async def find_by_platform_shop_identity(
â”‚               self,
â”‚               platform_name: str,
â”‚               shop_domain: str,
â”‚               platform_shop_id: Optional[str] = None
â”‚           ) -> Optional[Merchant]:
â”‚               """Find merchant by platform identity"""
â”‚               conditions = [
â”‚                   {"platform_name": platform_name, "shop_domain": shop_domain.lower()}
â”‚               ]
â”‚               if platform_shop_id:
â”‚                   conditions.append({"platform_name": platform_name, "platform_shop_id": platform_shop_id})
â”‚
â”‚               return await self.prisma.merchant.find_first(
â”‚                   where={"OR": conditions}
â”‚               )
â”‚
â”‚           async def find_by_shop_domain(self, shop_domain: str) -> Optional[Merchant]:
â”‚               """Find merchant by platform domain"""
â”‚               return await self.prisma.merchant.find_first(
â”‚                   where={"shop_domain": shop_domain.lower()}
â”‚               )
â”‚
â”‚           async def create(self, data: MerchantSyncIn) -> Merchant:
â”‚               """Create new merchant"""
â”‚               return await self.prisma.merchant.create(
â”‚                   data={
â”‚                       "platform_name": data.platform_name.lower(),
â”‚                       "platform_shop_id": data.platform_shop_id,
â”‚                       "shop_domain": data.shop_domain.lower(),  # myshopify domain
â”‚                       "name": data.shop_name,
â”‚                       "email": data.email,
â”‚                       "primary_domain": data.primary_domain_host,  # could be custom domain
â”‚                       "currency": data.currency,
â”‚                       "country": data.country,
â”‚                       "platform_version": data.platform_version,
â”‚                       "scopes": data.scopes,
â”‚                       "status": MerchantStatus.PENDING,
â”‚                       "installed_at": datetime.now(timezone.utc),
â”‚                       "last_sync_at": datetime.now(timezone.utc)
â”‚                   }
â”‚               )
â”‚
â”‚           async def update_for_sync(self, merchant_id: str, data: MerchantSyncIn) -> Merchant:
â”‚               """Update merchant on sync (reinstall or resync)"""
â”‚               return await self.prisma.merchant.update(
â”‚                   where={"id": merchant_id},
â”‚                   data={
â”‚                       "name": data.shop_name,
â”‚                       "email": data.email,
â”‚                       "primary_domain": data.primary_domain_host,
â”‚                       "currency": data.currency,
â”‚                       "country": data.country,
â”‚                       "platform_version": data.platform_version,
â”‚                       "scopes": data.scopes,
â”‚                       "last_sync_at": datetime.utcnow(),
â”‚                       "uninstalled_at": None  # Clear if reinstalling
â”‚                   }
â”‚               )
â”‚
â”‚           async def update_status(
â”‚               self,
â”‚               merchant_id: str,
â”‚               new_status: MerchantStatus
â”‚           ) -> Merchant:
â”‚               """Update merchant status"""
â”‚               update_data = {
â”‚                   "status": new_status,
â”‚                   "status_changed_at": datetime.utcnow()
â”‚               }
â”‚
â”‚               # Set uninstalled_at if uninstalling
â”‚               if new_status == MerchantStatus.UNINSTALLED:
â”‚                   update_data["uninstalled_at"] = datetime.utcnow()
â”‚
â”‚               return await self.prisma.merchant.update(
â”‚                   where={"id": merchant_id},
â”‚                   data=update_data
â”‚               )
â”‚       ```
â”‚
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   from .merchant import (
â”‚   â”‚       MerchantSyncIn,
â”‚   â”‚       MerchantSyncOut,
â”‚   â”‚       MerchantSelfOut,
â”‚   â”‚       MerchantSyncedPayload,
â”‚   â”‚       MerchantStatusUpdatedPayload
â”‚   â”‚   )
â”‚   â”‚
â”‚   â”‚   __all__ = [
â”‚   â”‚       "MerchantSyncIn",
â”‚   â”‚       "MerchantSyncOut",
â”‚   â”‚       "MerchantSelfOut",
â”‚   â”‚       "MerchantSyncedPayload",
â”‚   â”‚       "MerchantStatusUpdatedPayload"
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ merchant.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/schemas/merchant.py
â”‚       from pydantic import BaseModel, Field, EmailStr
â”‚       from prisma.enums import MerchantStatus
â”‚
â”‚       # ---------- INPUT DTOs ----------
â”‚       class MerchantSyncIn(BaseModel):
â”‚           """Input DTO for syncing merchant"""
â”‚           platform_name: str = Field(..., description="Platform name (e.g., Shopify)")
â”‚           platform_shop_id: str = Field(..., description="Shopify Global ID (e.g., gid://shopify/Shop/123)")
â”‚           shop_domain: str = Field(..., description="Shop domain (e.g., myshopify.com)")
â”‚           shop_name: str = Field(..., description="Shop display name")
â”‚           email: EmailStr = Field(None, description="Shop contact email")
â”‚           primary_domain_host: str = Field(..., description="Primary domain of the shop")
â”‚           currency: str = Field(..., description="Shop currency (e.g., USD)")
â”‚           country: str = Field(..., description="Shop country code (e.g., US)")
â”‚           platform_version: str = Field(..., description="Shopify API version (e.g., 2025-01)")
â”‚           scopes: str = Field(..., description="OAuth scopes granted by the shop")
â”‚
â”‚       class MerchantSyncOut(BaseModel):
â”‚           """Output DTO for merchant sync result"""
â”‚           created: bool = Field(..., description="Indicates if the merchant was newly created")
â”‚           merchant_id: str = Field(..., description="Unique identifier of the merchant")
â”‚
â”‚       class MerchantSelfOut(BaseModel):
â”‚           """Output DTO for self merchant"""
â”‚           id: str
â”‚           platform_shop_id: str
â”‚           shop_domain: str
â”‚           shop_name: str
â”‚           status: MerchantStatus
â”‚
â”‚       # ---------- EVENT PAYLOADS ----------
â”‚       class MerchantSyncedPayload(BaseModel):
â”‚           """Payload for evt.merchant.synced"""
â”‚           merchant_id: str
â”‚           platform_name: str
â”‚           platform_shop_id: str
â”‚           shop_domain: str
â”‚           contact_email: EmailStr
â”‚           name: str
â”‚           status: MerchantStatus
â”‚
â”‚       class MerchantStatusUpdatedPayload(BaseModel):
â”‚           """Payload for evt.merchant.status_updated"""
â”‚           merchant_id: str
â”‚           platform_shop_id: str
â”‚           shop_domain: str
â”‚           status: MerchantStatus
â”‚
â”‚       ```
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   # services/merchant-service/src/services/__init__.py
â”‚   â”‚   """Service package for merchant service"""
â”‚   â”‚
â”‚   â”‚   from .merchant_service import MerchantService
â”‚   â”‚
â”‚   â”‚   __all__ = [
â”‚   â”‚       "MerchantService",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ merchant_service.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/services/merchant_service.py
â”‚       from shared.utils.logger import ServiceLogger
â”‚       from ..repositories.merchant_repository import MerchantRepository
â”‚       from ..schemas.merchant import (
â”‚           MerchantSyncIn, MerchantSyncOut, MerchantSelfOut,
â”‚           MerchantSyncedPayload, MerchantStatusUpdatedPayload
â”‚       )
â”‚       from ..events.publishers import MerchantEventPublisher
â”‚       from ..exceptions import MerchantNotFoundError, InvalidStatusTransitionError
â”‚       from prisma.enums import MerchantStatus
â”‚
â”‚
â”‚       # Status transition rules
â”‚       STATUS_TRANSITIONS = {
â”‚           MerchantStatus.PENDING: [
â”‚               MerchantStatus.ACTIVE,
â”‚               MerchantStatus.UNINSTALLED
â”‚           ],
â”‚           MerchantStatus.ACTIVE: [
â”‚               MerchantStatus.PAUSED,
â”‚               MerchantStatus.SUSPENDED,
â”‚               MerchantStatus.UNINSTALLED
â”‚           ],
â”‚           MerchantStatus.PAUSED: [
â”‚               MerchantStatus.ACTIVE,
â”‚               MerchantStatus.SUSPENDED,
â”‚               MerchantStatus.UNINSTALLED
â”‚           ],
â”‚           MerchantStatus.SUSPENDED: [
â”‚               MerchantStatus.ACTIVE,
â”‚               MerchantStatus.PAUSED,
â”‚               MerchantStatus.UNINSTALLED
â”‚           ],
â”‚           MerchantStatus.UNINSTALLED: [
â”‚               MerchantStatus.PENDING
â”‚           ]
â”‚       }
â”‚
â”‚       class MerchantService:
â”‚           """Business logic for merchant operations"""
â”‚
â”‚           def __init__(
â”‚               self,
â”‚               repository: MerchantRepository,
â”‚               publisher: MerchantEventPublisher,
â”‚               logger: ServiceLogger
â”‚           ):
â”‚               self.repository = repository
â”‚               self.publisher = publisher
â”‚               self.logger = logger
â”‚
â”‚           async def sync_merchant(self, data: MerchantSyncIn, ctx) -> MerchantSyncOut:
â”‚               """Sync merchant from OAuth flow"""
â”‚
â”‚               self.logger.info(
â”‚                   f"Syncing merchant: {data.shop_domain}",
â”‚                   extra={
â”‚                       "correlation_id": ctx.correlation_id,
â”‚                       "shop_domain": data.shop_domain,
â”‚                       "platform_shop_id": data.platform_shop_id
â”‚                   }
â”‚               )
â”‚
â”‚               # Find existing merchant
â”‚               existing = await self.repository.find_by_platform_shop_identity(
â”‚                   platform_name=data.platform_name,
â”‚                   shop_domain=data.shop_domain,
â”‚                   platform_shop_id=data.platform_shop_id
â”‚               )
â”‚
â”‚               if existing:
â”‚                   # Update existing merchant
â”‚                   merchant = await self.repository.update_for_sync(existing.id, data)
â”‚                   created = False
â”‚
â”‚                   # If merchant was uninstalled, set back to PENDING
â”‚                   if merchant.status == MerchantStatus.UNINSTALLED:
â”‚                       merchant = await self.repository.update_status(
â”‚                           merchant.id,
â”‚                           MerchantStatus.PENDING
â”‚                       )
â”‚
â”‚                       # Publish reinstalled event
â”‚                       await self.publisher.publish_merchant_reinstalled(
â”‚                           correlation_id=ctx.correlation_id,
â”‚                           merchant_id=merchant.id,
â”‚                           platform_shop_id=merchant.platform_shop_id,
â”‚                           shop_domain=merchant.shop_domain,
â”‚                           name=merchant.name,
â”‚                           email=merchant.email
â”‚                       )
â”‚               else:
â”‚                   # Create new merchant
â”‚                   merchant = await self.repository.create(data)
â”‚                   created = True
â”‚
â”‚                   self.logger.info(
â”‚                       f"Created new merchant: {merchant.shop_domain}",
â”‚                       extra={
â”‚                           "merchant_id": merchant.id,
â”‚                           "shop_domain": merchant.shop_domain
â”‚                       }
â”‚                   )
â”‚
â”‚                   # Publish installed event
â”‚                   await self.publisher.publish_merchant_created(
â”‚                       correlation_id=ctx.correlation_id,
â”‚                       merchant_id=merchant.id,
â”‚                       platform_name=merchant.platform_name,
â”‚                       platform_shop_id=merchant.platform_shop_id,
â”‚                       shop_domain=merchant.shop_domain,
â”‚                       name=merchant.name,
â”‚                       email=merchant.email,
â”‚                       installed_at=merchant.installed_at
â”‚                   )
â”‚
â”‚               # Always publish synced event
â”‚               synced_payload = MerchantSyncedPayload(
â”‚                   merchant_id=merchant.id,
â”‚                   platform_name=merchant.platform_name,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   contact_email=merchant.email,
â”‚                   name=merchant.name,
â”‚                   status=merchant.status
â”‚               )
â”‚
â”‚               await self.publisher.publish_merchant_synced(
â”‚                   correlation_id=ctx.correlation_id,
â”‚                   payload=synced_payload
â”‚               )
â”‚
â”‚               return MerchantSyncOut(
â”‚                   created=created,
â”‚                   merchant_id=merchant.id
â”‚               )
â”‚
â”‚           async def get_merchant_by_domain(self, shop_domain: str) -> MerchantSelfOut:
â”‚               """Get merchant by platform domain"""
â”‚               merchant = await self.repository.find_by_shop_domain(shop_domain)
â”‚               if not merchant:
â”‚                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
â”‚
â”‚               return MerchantSelfOut(
â”‚                   id=merchant.id,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   shop_name=merchant.name,
â”‚                   status=merchant.status
â”‚               )
â”‚
â”‚           async def update_merchant_status(
â”‚               self,
â”‚               shop_domain: str,
â”‚               new_status: MerchantStatus
â”‚           ) -> None:
â”‚               """Update merchant status (called by event listeners)"""
â”‚
â”‚               merchant = await self.repository.find_by_shop_domain(shop_domain)
â”‚               if not merchant:
â”‚                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
â”‚
â”‚               old_status = merchant.status
â”‚
â”‚               # Validate transition
â”‚               if new_status not in STATUS_TRANSITIONS.get(old_status, []):
â”‚                   self.logger.warning(
â”‚                       f"Invalid status transition from {old_status} to {new_status}",
â”‚                       extra={
â”‚                           "merchant_id": merchant.id,
â”‚                           "shop_domain": shop_domain
â”‚                       }
â”‚                   )
â”‚                   raise InvalidStatusTransitionError(
â”‚                       f"Invalid status transition from {old_status} to {new_status}"
â”‚                   )
â”‚
â”‚               # Update status
â”‚               updated_merchant = await self.repository.update_status(merchant.id, new_status)
â”‚
â”‚               # Publish status changed event
â”‚               status_payload = MerchantStatusUpdatedPayload(
â”‚                   merchant_id=merchant.id,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   status=new_status
â”‚               )
â”‚
â”‚
â”‚
â”‚               await self.publisher.publish_status_changed(
â”‚                   correlation_id=merchant.correlation_id,  # TODO: set a propper ctx Assuming this is available in the context
â”‚                   old_status=old_status,
â”‚                   payload=status_payload
â”‚               )
â”‚       ```
â”‚
â”œâ”€â”€ __init__.py
â”œâ”€â”€ config.py
â”‚
â”‚   ```py
â”‚   import os
â”‚   from functools import lru_cache
â”‚   from typing import Optional
â”‚   from pydantic import BaseModel, Field, ConfigDict, model_validator
â”‚   from shared.utils.config_loader import merged_config, flatten_config
â”‚   from shared.utils.exceptions import ConfigurationError
â”‚
â”‚   class ServiceConfig(BaseModel):
â”‚       """Service configuration from YAML + environment"""
â”‚       model_config = ConfigDict(populate_by_name=True, extra="ignore")
â”‚
â”‚       # Service Identity
â”‚       service_name: str = Field(..., alias="service.name")
â”‚       service_version: str = Field(..., alias="service.version")
â”‚       service_description: str = Field(..., alias="service.description")
â”‚       debug: bool = Field(..., alias="service.debug")
â”‚
â”‚       # Environment - from env
â”‚       environment: str = Field(..., alias="APP_ENV")
â”‚
â”‚       # API Configuration
â”‚       api_host: str = Field(..., alias="api.host")
â”‚       api_external_port: int = Field(..., alias="MERCHANT_API_EXTERNAL_PORT")
â”‚       api_cors_origins: list[str] = Field(..., alias="api.cors_origins")
â”‚
â”‚       # Database
â”‚       database_enabled: bool = Field(..., alias="MERCHANT_DB_ENABLED")
â”‚       database_url: str = Field(..., alias="DATABASE_URL")
â”‚
â”‚       # Logging
â”‚       logging_level: str = Field(..., alias="logging.level")
â”‚       logging_format: str = Field(..., alias="logging.format")
â”‚       logging_file_path: str = Field(..., alias="logging.file_path")
â”‚
â”‚       # Monitoring
â”‚       monitoring_metrics_enabled: bool = Field(..., alias="monitoring.metrics_enabled")
â”‚       monitoring_tracing_enabled: bool = Field(..., alias="monitoring.tracing_enabled")
â”‚
â”‚       # Rate limiting
â”‚       rate_limiting_enabled: bool = Field(..., alias="rate_limiting.enabled")
â”‚       rate_limiting_window_seconds: int = Field(..., alias="rate_limiting.window_seconds")
â”‚
â”‚       # Internal Authentication
â”‚       internal_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
â”‚
â”‚       # Computed properties
â”‚       @property
â”‚       def nats_url(self) -> str:
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           if in_container or self.environment in ["development", "production"]:
â”‚               return "nats://nats:4222"
â”‚           return "nats://localhost:4222"
â”‚
â”‚       @property
â”‚       def redis_url(self) -> str:
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           if in_container or self.environment in ["development", "production"]:
â”‚               return "redis://redis:6379"
â”‚           return "redis://localhost:6379"
â”‚
â”‚       @property
â”‚       def api_port(self) -> int:
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           return 8000 if in_container else self.api_external_port
â”‚
â”‚       @model_validator(mode="after")
â”‚       def _require_db_url_when_enabled(self):
â”‚           if self.database_enabled and not self.database_url:
â”‚               raise ValueError("database_enabled=true requires DATABASE_URL")
â”‚           return self
â”‚
â”‚
â”‚   @lru_cache
â”‚   def get_service_config() -> ServiceConfig:
â”‚       """Load and cache service configuration"""
â”‚       try:
â”‚           # Load YAML + all env vars
â”‚           cfg_dict = merged_config("merchant-service")
â”‚           flattened = flatten_config(cfg_dict)
â”‚           return ServiceConfig(**flattened)
â”‚
â”‚       except Exception as e:
â”‚           print(f"âŒ Configuration error: {e}")
â”‚           raise ConfigurationError(
â”‚               f"Failed to load service configuration: {e}",
â”‚               config_key="merchant-service",
â”‚               expected_value="valid config"
â”‚           )
â”‚   ```
â”‚
â”œâ”€â”€ dependencies.py
â”‚
â”‚   ```py
â”‚   from typing import Annotated
â”‚   from fastapi import Depends, Request, HTTPException, status
â”‚   from shared.api.dependencies import (
â”‚       RequestIdDep, PaginationDep, CorrelationIdDep, RequestContextDep
â”‚   )
â”‚   from .lifecycle import ServiceLifecycle
â”‚   from .config import ServiceConfig
â”‚   from .services import MerchantService
â”‚
â”‚   __all__ = [
â”‚       "CorrelationIdDep",
â”‚       "PaginationDep",
â”‚       "RequestIdDep",
â”‚       "RequestContextDep",
â”‚       "LifecycleDep",
â”‚       "ConfigDep",
â”‚       "MerchantServiceDep",
â”‚   ]
â”‚
â”‚   # Core dependencies
â”‚   def get_lifecycle(request: Request) -> ServiceLifecycle:
â”‚       lc = getattr(request.app.state, "lifecycle", None)
â”‚       if lc is None:
â”‚           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Lifecycle not initialized")
â”‚       return lc
â”‚
â”‚   def get_config(request: Request) -> ServiceConfig:
â”‚       cfg = getattr(request.app.state, "config", None)
â”‚       if cfg is None:
â”‚           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Config not initialized")
â”‚       return cfg
â”‚
â”‚   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
â”‚   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
â”‚
â”‚   def get_merchant_service(lifecycle: LifecycleDep) -> MerchantService:
â”‚       svc = lifecycle.merchant_service
â”‚       if svc is None:
â”‚           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "MerchantService not initialized")
â”‚       return svc
â”‚
â”‚   MerchantServiceDep = Annotated[MerchantService, Depends(get_merchant_service)]
â”‚   ```
â”‚
â”œâ”€â”€ exceptions.py
â”‚
â”‚   ```py
â”‚   from shared.utils.exceptions import (
â”‚       NotFoundError, ValidationError, ConflictError,
â”‚       DomainError
â”‚   )
â”‚
â”‚   class MerchantNotFoundError(NotFoundError):
â”‚       """Raised when merchant is not found"""
â”‚       def __init__(self, message: str = "Merchant not found"):
â”‚           super().__init__(message=message, resource="merchant")
â”‚
â”‚   class InvalidDomainError(ValidationError):
â”‚       """Raised when shop domain is invalid"""
â”‚       def __init__(self, message: str = "Invalid shop domain format"):
â”‚           super().__init__(message=message, field="shop_domain")
â”‚
â”‚   class ConsentViolationError(ConflictError):
â”‚       """Raised when trying to violate consent rules"""
â”‚       def __init__(self, message: str = "Cannot unset required consent"):
â”‚           super().__init__(message=message, conflicting_resource="consent")
â”‚
â”‚   class InvalidStatusTransitionError(DomainError):
â”‚       """Raised when status transition is invalid"""
â”‚       def __init__(self, message: str):
â”‚           super().__init__(message=message, code="INVALID_STATUS_TRANSITION")
â”‚
â”‚   ```
â”‚
â”œâ”€â”€ lifecycle.py
â”‚
â”‚   ```py
â”‚   # services/merchant-service/src/lifecycle.py
â”‚   from typing import Optional, List, Dict, Any
â”‚   import asyncio
â”‚   from prisma import Prisma
â”‚   from shared.messaging.jetstream_client import JetStreamClient
â”‚   from shared.utils.logger import ServiceLogger
â”‚   from .config import ServiceConfig
â”‚   from .repositories import MerchantRepository
â”‚   from .services.merchant_service import MerchantService
â”‚   from .events.publishers import MerchantEventPublisher
â”‚
â”‚   class ServiceLifecycle:
â”‚       """Manages service lifecycle and dependencies"""
â”‚
â”‚       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
â”‚           self.config = config
â”‚           self.logger = logger
â”‚
â”‚           # External connections
â”‚           self.messaging_client: Optional[JetStreamClient] = None
â”‚           self.prisma: Optional[Prisma] = None
â”‚           self._db_connected: bool = False
â”‚
â”‚           # Publisher / listeners
â”‚           self.event_publisher: Optional[MerchantEventPublisher] = None
â”‚           self._listeners: list = []
â”‚
â”‚           # Repositories / mappers / services
â”‚           self.merchant_repo: Optional[MerchantRepository] = None
â”‚           self.merchant_service: Optional[MerchantService] = None
â”‚
â”‚           # Tasks
â”‚           self._tasks: List[asyncio.Task] = []
â”‚           self._shutdown_event = asyncio.Event()
â”‚
â”‚       async def startup(self) -> None:
â”‚           try:
â”‚               self.logger.info("Starting service components...")
â”‚               await self._init_messaging()
â”‚               await self._init_database()
â”‚               self._init_repositories()
â”‚               self._init_local_services()
â”‚               await self._init_listeners()
â”‚               self.logger.info("%s started successfully", self.config.service_name)
â”‚           except Exception:
â”‚               self.logger.critical("Service failed to start", exc_info=True)
â”‚               await self.shutdown()
â”‚               raise
â”‚
â”‚       async def shutdown(self) -> None:
â”‚           """Graceful shutdown of all components"""
â”‚           self.logger.info("Shutting down %s", self.config.service_name)
â”‚
â”‚           for t in self._tasks:
â”‚               t.cancel()
â”‚           if self._tasks:
â”‚               await asyncio.gather(*self._tasks, return_exceptions=True)
â”‚
â”‚           for lst in self._listeners:
â”‚               try:
â”‚                   await lst.stop()
â”‚               except Exception:
â”‚                   self.logger.critical("Listener stop failed")
â”‚
â”‚           if self.messaging_client:
â”‚               try:
â”‚                   await self.messaging_client.close()
â”‚               except Exception:
â”‚                   self.logger.critical("Messaging client close failed")
â”‚
â”‚           if self.prisma and self._db_connected:
â”‚               try:
â”‚                   await self.prisma.disconnect()
â”‚               except Exception:
â”‚                   self.logger.critical("Prisma disconnect failed")
â”‚
â”‚           self.logger.info("%s shutdown complete", self.config.service_name)
â”‚
â”‚       async def _init_messaging(self) -> None:
â”‚           self.messaging_client = JetStreamClient(self.logger)
â”‚           await self.messaging_client.connect([self.config.nats_url])
â”‚           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.>", "cmd.>"])
â”‚
â”‚           # Initialize publisher now (you require it in _init_listeners)
â”‚           self.event_publisher = MerchantEventPublisher(
â”‚               jetstream_client=self.messaging_client,
â”‚               logger=self.logger
â”‚           )
â”‚           self.logger.info("Messaging client and publisher initialized")
â”‚
â”‚       async def _init_database(self) -> None:
â”‚           """Initialize Prisma client if database is enabled."""
â”‚           if not self.config.database_enabled:
â”‚               self.logger.info("Database disabled; skipping Prisma initialization")
â”‚               return
â”‚
â”‚           # Prisma reads DATABASE_URL from the environment; no args needed
â”‚           self.prisma = Prisma()
â”‚
â”‚           if not self.prisma:
â”‚               raise RuntimeError("Prisma client not initialized")
â”‚
â”‚           try:
â”‚               await self.prisma.connect()
â”‚               self._db_connected = True
â”‚               self.logger.info("Prisma connected")
â”‚           except Exception as e:
â”‚               # Be explicit; this usually means DATABASE_URL is missing/invalid or client not generated
â”‚               self.logger.error("Prisma connect failed: %s", e, exc_info=True)
â”‚               raise
â”‚
â”‚       # ---------------------------------------------------------------- repos
â”‚       def _init_repositories(self) -> None:
â”‚           if self.config.database_enabled:
â”‚               if not (self.prisma and self._db_connected):
â”‚                   raise RuntimeError("Prisma client not initialized/connected")
â”‚               self.merchant_repo = MerchantRepository(self.prisma)
â”‚               self.logger.info("Merchant repository initialized")
â”‚           else:
â”‚               self.merchant_repo = None  # service must handle db-disabled mode
â”‚
â”‚       # ---------------------------------------------------------- local services
â”‚       def _init_local_services(self) -> None:
â”‚
â”‚           if not self.merchant_repo or not self.event_publisher:
â”‚               raise RuntimeError("Merchant repository not initialized")
â”‚
â”‚           self.merchant_service = MerchantService(
â”‚               repository=self.merchant_repo,
â”‚               publisher=self.event_publisher,
â”‚               logger=self.logger
â”‚
â”‚           )
â”‚
â”‚       # -------------------------------------------------------------- listeners
â”‚       async def _init_listeners(self) -> None:
â”‚           if not self.messaging_client or not self.merchant_service or not self.event_publisher:
â”‚               raise RuntimeError("Messaging or service layer not ready")
â”‚
â”‚           # Initialize and start subscribers here when you add them
â”‚           # await some_listener.start()
â”‚           # self._listeners.append(some_listener)
â”‚
â”‚       # ================================================= convenience helpers
â”‚       def add_task(self, coro) -> asyncio.Task:
â”‚           t = asyncio.create_task(coro)
â”‚           self._tasks.append(t)
â”‚           return t
â”‚
â”‚       async def wait_for_shutdown(self) -> None:
â”‚           await self._shutdown_event.wait()
â”‚
â”‚       def signal_shutdown(self) -> None:
â”‚           self._shutdown_event.set()
â”‚   ```
â”‚
â””â”€â”€ main.py

    ```py
    from contextlib import asynccontextmanager
    from fastapi import FastAPI
    from shared.api import setup_middleware, setup_debug_handlers, setup_debug_middleware
    from shared.api.health import create_health_router
    from shared.utils.logger import create_logger
    from .config import get_service_config
    from .lifecycle import ServiceLifecycle
    from .api import api_router

    # Global singletons
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)

    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """FastAPI lifespan adapter"""
        logger.info(f"Starting {config.service_name}", extra={
            "service_name": config.service_name,
            "version": config.service_version,
            "environment": config.environment,
            "api_host": config.api_host,
            "api_port": config.api_port,
        })

        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()

    def create_application() -> FastAPI:
        """Create and configure the FastAPI application."""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            lifespan=lifespan,
            description=config.service_description,
            docs_url="/docs",
            redoc_url="/redoc",
            exception_handlers={}  # Use shared middleware for exception handling
        )

        if config.debug:
            logger.info("ðŸš¨ Debug mode enabled - adding debug handlers")
            setup_debug_handlers(app)
            setup_debug_middleware(app)

        setup_middleware(
            app,
            service_name=config.service_name,
            enable_metrics=config.monitoring_metrics_enabled,
            metrics_path="/metrics"
        )

        # Include routers
        app.include_router(create_health_router(config.service_name))
        app.include_router(api_router)


        return app

    app = create_application()

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(
            "src.main:app",
            host=config.api_host,
            port=config.api_port,
            reload=config.debug,
            workers=1
        )

    ```

tests/
â””â”€â”€ __init__.py
.env.example
.pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files

  - repo: https://github.com/psf/black
    rev: 23.11.0
    hooks:
      - id: black
        args: [--line-length=100]

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: [--profile=black, --line-length=100]

  - repo: https://github.com/pycqa/flake8
    rev: 6.1.0
    hooks:
      - id: flake8
        args: [--max-line-length=100, --extend-ignore=E203,W503]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.7.1
    hooks:
      - id: mypy
        args: [--strict, --ignore-missing-imports]

  # Custom hooks for ID management
  - repo: local
    hooks:
      - id: check-uuid4-usage
        name: Check for manual uuid4() usage
        entry: bash -c 'if grep -r "uuid4()" --include="*.py" --exclude-dir=tests .; then echo "Use uuid7() instead of uuid4() for event IDs"; exit 1; fi'
        language: system
        pass_filenames: false

```

.python-version
__init__.py
docker-compose.yml

```yml
version: '3.8'

services:
  merchant-service:
    build: .
    ports:
      - "8113:8000"
      - "9090:9090"  # Metrics
    environment:
      - DATABASE_URL=postgresql://merchant:password@postgres:5432/merchant_db
      - REDIS_URL=redis://redis:6379
      - NATS_URL=nats://nats:4222
      - BACKEND_API_KEY=test-api-key
      - LOG_LEVEL=INFO
      - DEBUG=false
      - DOCKER_CONTAINER=1
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      nats:
        condition: service_started
    volumes:
      - ./src:/app/src  # Hot reload
      - ./config:/app/config  # Mount config
    networks:
      - merchant-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: merchant_db
      POSTGRES_USER: merchant
      POSTGRES_PASSWORD: password
    ports:
      - "5413:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - merchant-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U merchant -d merchant_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6313:6379"
    volumes:
      - redis_data:/data
    networks:
      - merchant-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nats:
    image: nats:2.10-alpine
    ports:
      - "4213:4222"
      - "8213:8222"  # HTTP monitoring
    command: [
      "nats-server",
      "--jetstream",
      "--store_dir=/data",
      "--http_port=8222"
    ]
    volumes:
      - nats_data:/data
    networks:
      - merchant-network

volumes:
  postgres_data:
  redis_data:
  nats_data:

networks:
  merchant-network:
    driver: bridge

```

Dockerfile

```
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ðŸ“¦  Stage 1 â”€ Builder
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FROM python:3.11-slim AS builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry
RUN poetry config virtualenvs.create false

# ---- 1ï¸âƒ£  Install shared package dependencies
COPY shared /shared
WORKDIR /shared
RUN poetry install --no-dev

# ---- 2ï¸âƒ£  Install service dependencies
WORKDIR /app
COPY services/merchant-service/pyproject.toml services/merchant-service/poetry.lock* ./
RUN poetry install --no-dev --no-interaction --no-ansi

# ---- 3ï¸âƒ£  Copy Prisma schema and generate client
COPY services/merchant-service/prisma ./prisma
RUN prisma generate

# ---- 4ï¸âƒ£  Copy service code
COPY services/merchant-service /app

# ---- 5ï¸âƒ£  Copy config
COPY config /app/config

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ðŸ“¦  Stage 2 â”€ Runtime
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app /app
COPY --from=builder /shared /shared

ENV PYTHONPATH="/shared:/app"
ENV DOCKER_CONTAINER=1

WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run migrations and start server
CMD ["sh", "-c", "prisma migrate deploy && uvicorn src.main:app --host 0.0.0.0 --port 8000"]

```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
# services/merchant-service/pyproject.toml
[tool.poetry]
name = "merchant-service"
version = "1.0.0"
description = "Merchant identity and consent management service"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
email-validator = "^2.1.0"
prisma = "^0.15.0"
nats-py = "^2.6.0"
redis = "^5.0.1"
python-multipart = "^0.0.6"
httpx = "^0.25.2"
python-dotenv = "^1.0.0"
prometheus-client = "^0.19.0"
uuid7 = "^0.1.0"
shared = { path = "../../shared", develop = true }

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
isort = "^5.12.0"
flake8 = "^6.1.0"
mypy = "^1.7.1"
pre-commit = "^3.6.0"

[tool.poetry.group.test.dependencies]
httpx = "^0.25.2"
pytest-mock = "^3.12.0"
testcontainers = "^3.7.1"

[tool.pytest.ini_options]
minversion = "7.0"
addopts = "-ra -q --strict-markers --strict-config"
testpaths = ["tests"]
pythonpath = ["src"]
asyncio_mode = "auto"
markers = [
    "unit: Unit tests",
    "integration: Integration tests",
    "e2e: End-to-end tests"
]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.mypy]
python_version = "3.11"
strict = true
ignore_missing_imports = true

[tool.coverage.run]
source = ["src"]
omit = ["tests/*", "*/migrations/*", "*/__init__.py"]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

README.md

```md
# Merchant Service

Merchant identity and consent management service for the GLAM platform.

## Overview

The Merchant Service manages:
- Merchant identity and installation lifecycle
- Consent settings (data access, auto-sync, TOS)
- OAuth sync after Shopify installation
- Activity tracking for analytics
- Status management (PENDING, ACTIVE, SUSPENDED, DEACTIVATED)

## Port Configuration

- Internal Port: 8013 (container)
- External Port: 8113 (local development)
- Database Port: 5413
- Redis Port: 6313
- NATS Port: 4213

## Setup

1. Install dependencies:
```bash
poetry install
```

2. Set up environment:
```bash
cp .env.example .env
# Edit .env with your secrets
```

3. Generate Prisma client:
```bash
prisma generate
```

4. Run migrations:
```bash
prisma migrate dev
```

5. Start service:
```bash
```


================================================================================
Output includes file contents
================================================================================
