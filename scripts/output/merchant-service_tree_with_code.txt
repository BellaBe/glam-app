================================================================================
Directory Structure: /home/bellabe/glam-app/services/merchant-service
================================================================================

merchant-service/
logs/
prisma/
├── migrations/
│   ├── 20250803094605_init/
│   │   └── migration.sql
│   │       
│   │       ```sql
│   │       -- CreateEnum
│   │       CREATE TYPE "MerchantStatus" AS ENUM ('PENDING', 'ONBOARDING', 'TRIAL', 'ACTIVE', 'SUSPENDED', 'DEACTIVATED');
│   │       
│   │       -- CreateTable
│   │       CREATE TABLE "merchants" (
│   │           "id" TEXT NOT NULL,
│   │           "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updatedAt" TIMESTAMP(3) NOT NULL,
│   │           "shop_id" TEXT NOT NULL,
│   │           "shop_domain" TEXT NOT NULL,
│   │           "shop_name" TEXT NOT NULL,
│   │           "shop_url" TEXT,
│   │           "shopify_access_token" TEXT NOT NULL,
│   │           "platform_api_version" TEXT NOT NULL DEFAULT '2024-01',
│   │           "email" TEXT NOT NULL,
│   │           "phone" TEXT,
│   │           "timezone" TEXT NOT NULL DEFAULT 'UTC',
│   │           "country" TEXT,
│   │           "currency" TEXT NOT NULL DEFAULT 'USD',
│   │           "language" TEXT NOT NULL DEFAULT 'en',
│   │           "plan_name" TEXT,
│   │           "platform" TEXT NOT NULL DEFAULT 'shopify',
│   │           "onboarding_completed" BOOLEAN NOT NULL DEFAULT false,
│   │           "onboarding_step" TEXT,
│   │       
│   │           CONSTRAINT "merchants_pkey" PRIMARY KEY ("id")
│   │       );
│   │       
│   │       -- CreateTable
│   │       CREATE TABLE "merchant_statuses" (
│   │           "id" TEXT NOT NULL,
│   │           "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updatedAt" TIMESTAMP(3) NOT NULL,
│   │           "merchant_id" TEXT NOT NULL,
│   │           "status" "MerchantStatus" NOT NULL,
│   │           "previous_status" "MerchantStatus",
│   │           "status_reason" TEXT,
│   │           "changed_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "activated_at" TIMESTAMP(3),
│   │           "suspended_at" TIMESTAMP(3),
│   │           "deactivated_at" TIMESTAMP(3),
│   │           "last_activity_at" TIMESTAMP(3),
│   │           "status_history" JSONB NOT NULL DEFAULT '[]',
│   │       
│   │           CONSTRAINT "merchant_statuses_pkey" PRIMARY KEY ("id")
│   │       );
│   │       
│   │       -- CreateTable
│   │       CREATE TABLE "merchant_configurations" (
│   │           "id" TEXT NOT NULL,
│   │           "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updatedAt" TIMESTAMP(3) NOT NULL,
│   │           "merchant_id" TEXT NOT NULL,
│   │           "terms_accepted" BOOLEAN NOT NULL DEFAULT false,
│   │           "terms_accepted_at" TIMESTAMP(3),
│   │           "terms_version" TEXT,
│   │           "privacy_accepted" BOOLEAN NOT NULL DEFAULT false,
│   │           "privacy_accepted_at" TIMESTAMP(3),
│   │           "privacy_version" TEXT,
│   │           "widget_enabled" BOOLEAN NOT NULL DEFAULT true,
│   │           "widget_position" TEXT NOT NULL DEFAULT 'bottom-right',
│   │           "widget_theme" TEXT NOT NULL DEFAULT 'light',
│   │           "widget_language" TEXT NOT NULL DEFAULT 'auto',
│   │           "widget_configuration" JSONB NOT NULL DEFAULT '{}',
│   │           "api_rate_limits" JSONB NOT NULL DEFAULT '{}',
│   │           "webhook_configuration" JSONB NOT NULL DEFAULT '{}',
│   │           "integration_settings" JSONB NOT NULL DEFAULT '{}',
│   │           "custom_css" TEXT,
│   │           "custom_branding" JSONB NOT NULL DEFAULT '{}',
│   │           "custom_messages" JSONB NOT NULL DEFAULT '{}',
│   │           "is_marketable" BOOLEAN NOT NULL DEFAULT true,
│   │       
│   │           CONSTRAINT "merchant_configurations_pkey" PRIMARY KEY ("id")
│   │       );
│   │       
│   │       -- CreateTable
│   │       CREATE TABLE "installation_records" (
│   │           "id" TEXT NOT NULL,
│   │           "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updatedAt" TIMESTAMP(3) NOT NULL,
│   │           "merchant_id" TEXT NOT NULL,
│   │           "platform" TEXT NOT NULL DEFAULT 'shopify',
│   │           "installed_at" TIMESTAMP(3) NOT NULL,
│   │           "uninstalled_at" TIMESTAMP(3),
│   │           "install_channel" TEXT,
│   │           "installed_by" TEXT,
│   │           "installation_ip" TEXT,
│   │           "app_version" TEXT,
│   │           "platform_api_version" TEXT,
│   │           "permissions_granted" JSONB NOT NULL DEFAULT '[]',
│   │           "callbacks_configured" JSONB NOT NULL DEFAULT '[]',
│   │           "referral_code" TEXT,
│   │           "utm" JSONB NOT NULL DEFAULT '{}',
│   │           "platform_metadata" JSONB NOT NULL DEFAULT '{}',
│   │           "uninstall_reason" TEXT,
│   │           "uninstall_method" TEXT,
│   │           "uninstall_feedback" JSONB NOT NULL DEFAULT '{}',
│   │       
│   │           CONSTRAINT "installation_records_pkey" PRIMARY KEY ("id")
│   │       );
│   │       
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "merchants_shop_id_key" ON "merchants"("shop_id");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "merchants_shop_id_idx" ON "merchants"("shop_id");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "merchants_shop_domain_idx" ON "merchants"("shop_domain");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "merchants_email_idx" ON "merchants"("email");
│   │       
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "merchant_statuses_merchant_id_key" ON "merchant_statuses"("merchant_id");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "merchant_statuses_status_idx" ON "merchant_statuses"("status");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "merchant_statuses_merchant_id_idx" ON "merchant_statuses"("merchant_id");
│   │       
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "merchant_configurations_merchant_id_key" ON "merchant_configurations"("merchant_id");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "merchant_configurations_merchant_id_idx" ON "merchant_configurations"("merchant_id");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "installation_records_merchant_id_platform_idx" ON "installation_records"("merchant_id", "platform");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "installation_records_platform_installed_at_idx" ON "installation_records"("platform", "installed_at");
│   │       
│   │       -- CreateIndex
│   │       CREATE INDEX "installation_records_merchant_id_idx" ON "installation_records"("merchant_id");
│   │       
│   │       -- AddForeignKey
│   │       ALTER TABLE "merchant_statuses" ADD CONSTRAINT "merchant_statuses_merchant_id_fkey" FOREIGN KEY ("merchant_id") REFERENCES "merchants"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
│   │       
│   │       -- AddForeignKey
│   │       ALTER TABLE "merchant_configurations" ADD CONSTRAINT "merchant_configurations_merchant_id_fkey" FOREIGN KEY ("merchant_id") REFERENCES "merchants"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
│   │       
│   │       -- AddForeignKey
│   │       ALTER TABLE "installation_records" ADD CONSTRAINT "installation_records_merchant_id_fkey" FOREIGN KEY ("merchant_id") REFERENCES "merchants"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
│   │       ```
│   │       
│   └── migration_lock.toml
│       
│       ```toml
│       # Please do not edit this file manually
│       # It should be added in your version-control system (i.e. Git)
│       provider = "postgresql"
│       ```
│       
└── schema.prisma
src/
├── api/
│   ├── v1/
│   │   ├── __init__.py
│   │   │   
│   │   │   ```py
│   │   │   # src/api/v1/__init__.py
│   │   │   from fastapi import APIRouter
│   │   │   from .merchants import merchants_router
│   │   │   
│   │   │   v1_router = APIRouter(prefix="/v1")
│   │   │   
│   │   │   # Include merchant routes
│   │   │   v1_router.include_router(merchants_router, tags=["merchants"])
│   │   │   ```
│   │   │   
│   │   └── merchants.py
│   │       
│   │       ```py
│   │       from fastapi import APIRouter, status, HTTPException, Header, Request
│   │       from typing import Optional
│   │       
│   │       from shared.api import ApiResponse, success_response, error_response
│   │       from shared.api.dependencies import RequestContextDep, ClientIpDep, AuthDep, ShopDomainDep
│   │       from ...dependencies import MerchantServiceDep
│   │       from ...schemas.merchant import (
│   │           MerchantSyncIn, MerchantOut, MerchantSettingsUpdate,
│   │           MerchantSettingsOut, MerchantSyncOut, MerchantActivity
│   │       )
│   │       from ...exceptions import (
│   │           MerchantNotFoundError, 
│   │           InvalidDomainError, 
│   │           ConsentViolationError
│   │           )
│   │       
│   │       merchants_router = APIRouter(prefix="/merchants")
│   │       
│   │       @merchants_router.post(
│   │           "/sync",
│   │           response_model=ApiResponse[MerchantSyncOut],
│   │           status_code=status.HTTP_200_OK,
│   │           summary="Sync merchant from OAuth flow",
│   │       )
│   │       @merchants_router.post("/sync")
│   │       async def sync_merchant(
│   │           service: MerchantServiceDep,
│   │           ctx: RequestContextDep,
│   │           shop_domain_header: ShopDomainDep,
│   │           body: MerchantSyncIn,
│   │       ):
│   │           """Sync merchant after OAuth completion"""
│   │           try:
│   │               # Business logic validation
│   │               if body.myshopify_domain.lower() != shop_domain_header.lower():
│   │                   # Use error_response for business logic errors
│   │                   return error_response(
│   │                       code="SHOP_DOMAIN_MISMATCH",
│   │                       message="Shop domain mismatch between request body and header",
│   │                       details={
│   │                           "body_shop": body.shop_domain,
│   │                           "header_shop": shop_domain_header
│   │                       },\
│   │                       request_id=ctx.request_id,
│   │                       correlation_id=ctx.correlation_id
│   │                   )
│   │               
│   │               result = await service.sync_merchant(body, ctx)
│   │               return success_response(
│   │                   result,
│   │                   ctx.request_id,
│   │                   ctx.correlation_id
│   │               )
│   │           
│   │           
│   │           except InvalidDomainError as e:
│   │               # Business logic error - use error_response
│   │               return error_response(
│   │                   code="INVALID_DOMAIN",
│   │                   message=str(e),
│   │                   request_id=ctx.request_id,
│   │                   correlation_id=ctx.correlation_id
│   │               )
│   │           
│   │           except MerchantNotFoundError as e:
│   │               return error_response(
│   │                   code="MERCHANT_NOT_FOUND", 
│   │                   message=str(e),
│   │                   request_id=ctx.request_id,
│   │                   correlation_id=ctx.correlation_id
│   │               )
│   │           
│   │           except Exception as e:
│   │               # Log unexpected errors
│   │               # logger.exception(f"Unexpected error in sync_merchant")
│   │               print(f"Unexpected error in sync_merchant: {e}")  # For debugging
│   │               
│   │               # Return error response for unexpected errors
│   │               return error_response(
│   │                   code="SYNC_FAILED",
│   │                   message="Failed to sync merchant",
│   │                   details={"error": str(e)},
│   │                   request_id=ctx.request_id,
│   │                   correlation_id=ctx.correlation_id
│   │               )
│   │       
│   │       @merchants_router.get(
│   │           "/self/{platform_domain}",
│   │           response_model=ApiResponse[MerchantOut],
│   │           summary="Get current merchant info",
│   │       )
│   │       async def get_merchant_self(
│   │           service: MerchantServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: AuthDep,
│   │           platform_domain: ShopDomainDep 
│   │       ):
│   │           """Get current merchant information"""
│   │           try:
│   │               merchant = await service.get_merchant_by_domain(platform_domain)
│   │               return success_response(
│   │                   merchant,
│   │                   ctx.request_id,
│   │                   ctx.correlation_id
│   │               )
│   │           except MerchantNotFoundError:
│   │               raise HTTPException(404, "Merchant not found")
│   │       
│   │       @merchants_router.get(
│   │           "/self/settings",
│   │           response_model=ApiResponse[MerchantSettingsOut],
│   │           summary="Get current merchant settings",
│   │       )
│   │       async def get_merchant_settings(
│   │           service: MerchantServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: AuthDep,
│   │           shop_domain: ShopDomainDep
│   │       ):
│   │           """Get current merchant settings"""
│   │           try:
│   │               settings = await service.get_settings(shop_domain)
│   │               return success_response(
│   │                   settings,
│   │                   ctx.request_id,
│   │                   ctx.correlation_id
│   │               )
│   │           except MerchantNotFoundError:
│   │               raise HTTPException(404, "Merchant not found")
│   │       
│   │       @merchants_router.put(
│   │           "/self/settings",
│   │           response_model=ApiResponse[MerchantSettingsOut],
│   │           summary="Update merchant settings",
│   │       )
│   │       async def update_merchant_settings(
│   │           service: MerchantServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: AuthDep,
│   │           shop_domain: ShopDomainDep,
│   │           client_ip: ClientIpDep,
│   │           body: MerchantSettingsUpdate,
│   │           request: Request
│   │       ):
│   │           """Update merchant settings"""
│   │           try:
│   │               user_agent = request.headers.get("user-agent")
│   │               settings = await service.update_settings(
│   │                   shop_domain,
│   │                   body,
│   │                   ip=client_ip,
│   │                   user_agent=user_agent
│   │               )
│   │               return success_response(
│   │                   settings,
│   │                   ctx.request_id,
│   │                   ctx.correlation_id
│   │               )
│   │           except MerchantNotFoundError:
│   │               raise HTTPException(404, "Merchant not found")
│   │           except ConsentViolationError as e:
│   │               return error_response(
│   │                   code="CONSENT_VIOLATION",
│   │                   message=str(e),
│   │                   # status=409,
│   │                   request_id=ctx.request_id,
│   │                   correlation_id=ctx.correlation_id
│   │               )
│   │       
│   │       @merchants_router.post(
│   │           "/self/activity",
│   │           status_code=status.HTTP_204_NO_CONTENT,
│   │           summary="Record merchant activity",
│   │       )
│   │       async def record_merchant_activity(
│   │           service: MerchantServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: AuthDep,
│   │           shop_domain: ShopDomainDep,
│   │           body: MerchantActivity
│   │       ):
│   │           """Record merchant activity for analytics"""
│   │           try:
│   │               await service.record_activity(shop_domain, body)
│   │           except MerchantNotFoundError:
│   │               raise HTTPException(404, "Merchant not found")
│   │       
│   │       ```
│   │       
│   └── __init__.py
│       
│       ```py
│       # src/api/__init__.py
│       from fastapi import APIRouter
│       from .v1 import v1_router
│       
│       api_router = APIRouter(prefix="/api")
│       
│       # Include v1 routes
│       api_router.include_router(v1_router)
│       ```
│       
├── events/
│   ├── __init__.py
│   ├── listeners.py
│   │   
│   │   ```py
│   │   from typing import Dict
│   │   from shared.messaging.listener import Listener
│   │   from shared.messaging.jetstream_client import JetStreamClient
│   │   from shared.utils.logger import ServiceLogger
│   │   from ..services.merchant_service import MerchantService
│   │   from ..events.publishers import MerchantEventPublisher
│   │   
│   │   class AppUninstalledListener(Listener):
│   │       """Listener for app uninstalled webhook events"""
│   │       
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.webhook.app.uninstalled.v1"
│   │       
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "merchant-uninstall"
│   │       
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "merchant-service"
│   │       
│   │       def __init__(
│   │           self,
│   │           js_client: JetStreamClient,
│   │           service: MerchantService,
│   │           logger: ServiceLogger
│   │       ):
│   │           super().__init__(js_client, logger)
│   │           self.service = service
│   │       
│   │       async def on_message(self, data: Dict) -> None:
│   │           """Handle app uninstalled event"""
│   │           try:
│   │               shop_domain = data.get("shop_domain")
│   │               uninstall_reason = data.get("uninstall_reason")
│   │               
│   │               if not shop_domain:
│   │                   self.logger.error("Missing shop_domain in uninstall event", extra={"data": data})
│   │                   return
│   │               
│   │               self.logger.info(
│   │                   f"Processing app uninstall for {shop_domain}",
│   │                   extra={
│   │                       "shop_domain": shop_domain,
│   │                       "uninstall_reason": uninstall_reason
│   │                   }
│   │               )
│   │               
│   │               await self.service.handle_app_uninstalled(shop_domain, uninstall_reason)
│   │               
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   f"Failed to process app uninstall: {e}",
│   │                   exc_info=True,
│   │                   extra={"data": data}
│   │               )
│   │               raise  # NACK for retry
│   │   
│   │   ```
│   │   
│   ├── publishers.py
│   │   
│   │   ```py
│   │   from datetime import datetime
│   │   from typing import Optional, Dict, Any
│   │   from shared.messaging.publisher import Publisher
│   │   from shared.messaging.subjects import Subjects
│   │   from shared.api.correlation import get_correlation_context
│   │   from uuid import uuid4
│   │   from prisma.enums import MerchantStatus
│   │   
│   │   class MerchantEventPublisher(Publisher):
│   │       """Publisher for merchant domain events"""
│   │       
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "merchant-service"
│   │       
│   │       async def publish_merchant_created(
│   │           self,
│   │           merchant_id: str,
│   │           shop_gid: str,
│   │           shop_domain: str,
│   │           shop_name: Optional[str],
│   │           email: Optional[str],
│   │           timezone: str,
│   │           currency: str,
│   │           platform: str,
│   │           installed_at: datetime,
│   │           install_source: Optional[str]
│   │       ) -> str:
│   │           """Publish evt.merchant.created event"""
│   │           return await self.publish_event(
│   │               subject="evt.merchant.created.v1",
│   │               data={
│   │                   "merchant_id": merchant_id,
│   │                   "shop_gid": shop_gid,
│   │                   "shop_domain": shop_domain,
│   │                   "shop_name": shop_name,
│   │                   "email": email,
│   │                   "timezone": timezone,
│   │                   "currency": currency,
│   │                   "platform": platform,
│   │                   "installed_at": installed_at.isoformat(),
│   │                   "install_source": install_source
│   │               }
│   │           )
│   │       
│   │       async def publish_merchant_synced(
│   │           self,
│   │           merchant_id: str,
│   │           shop_gid: str,
│   │           shop_domain: str,
│   │           first_install: bool,
│   │           last_auth_at: datetime,
│   │           scopes: str
│   │       ) -> str:
│   │           """Publish evt.merchant.synced event"""
│   │           return await self.publish_event(
│   │               subject="evt.merchant.synced.v1",
│   │               data={
│   │                   "merchant_id": merchant_id,
│   │                   "shop_gid": shop_gid,
│   │                   "shop_domain": shop_domain,
│   │                   "first_install": first_install,
│   │                   "last_auth_at": last_auth_at.isoformat(),
│   │                   "scopes": scopes
│   │               }
│   │           )
│   │       
│   │       async def publish_settings_updated(
│   │           self,
│   │           merchant_id: str,
│   │           shop_gid: str,
│   │           shop_domain: str,
│   │           changes: Dict[str, bool],
│   │           updated_at: datetime
│   │       ) -> str:
│   │           """Publish evt.merchant.settings.updated event"""
│   │           return await self.publish_event(
│   │               subject="evt.merchant.settings.updated.v1",
│   │               data={
│   │                   "merchant_id": merchant_id,
│   │                   "shop_gid": shop_gid,
│   │                   "shop_domain": shop_domain,
│   │                   "changes": changes,
│   │                   "updated_at": updated_at.isoformat()
│   │               }
│   │           )
│   │       
│   │       async def publish_status_changed(
│   │           self,
│   │           merchant_id: str,
│   │           shop_gid: str,
│   │           old_status: MerchantStatus,
│   │           new_status: MerchantStatus,
│   │           reason: str,
│   │           changed_at: datetime
│   │       ) -> str:
│   │           """Publish evt.merchant.status.changed event"""
│   │           return await self.publish_event(
│   │               subject="evt.merchant.status.changed.v1",
│   │               data={
│   │                   "merchant_id": merchant_id,
│   │                   "shop_gid": shop_gid,
│   │                   "old_status": old_status.value,
│   │                   "new_status": new_status.value,
│   │                   "reason": reason,
│   │                   "changed_at": changed_at.isoformat()
│   │               }
│   │           )
│   │       
│   │       async def publish_merchant_uninstalled(
│   │           self,
│   │           merchant_id: str,
│   │           shop_gid: str,
│   │           shop_domain: str,
│   │           uninstalled_at: datetime,
│   │           uninstall_reason: Optional[str]
│   │       ) -> str:
│   │           """Publish evt.merchant.uninstalled event"""
│   │           return await self.publish_event(
│   │               subject="evt.merchant.uninstalled.v1",
│   │               data={
│   │                   "merchant_id": merchant_id,
│   │                   "shop_gid": shop_gid,
│   │                   "shop_domain": shop_domain,
│   │                   "uninstalled_at": uninstalled_at.isoformat(),
│   │                   "uninstall_reason": uninstall_reason
│   │               }
│   │           )
│   │       
│   │       async def publish_activity_recorded(
│   │           self,
│   │           merchant_id: str,
│   │           shop_gid: str,
│   │           activity_type: str,
│   │           activity_name: str,
│   │           activity_data: Optional[Dict[str, Any]],
│   │           timestamp: datetime
│   │       ) -> str:
│   │           """Publish evt.merchant.activity.recorded event"""
│   │           return await self.publish_event(
│   │               subject="evt.merchant.activity.recorded.v1",
│   │               data={
│   │                   "merchant_id": merchant_id,
│   │                   "shop_gid": shop_gid,
│   │                   "activity_type": activity_type,
│   │                   "activity_name": activity_name,
│   │                   "activity_data": activity_data,
│   │                   "timestamp": timestamp.isoformat()
│   │               }
│   │           )
│   │   
│   │   ```
│   │   
│   ├── subscribers.py
│   │   
│   │   ```py
│   │   # services/merchant-service/src/events/subscribers.py
│   │   from shared.events import DomainEventSubscriber
│   │   from ..models.enums import MerchantStatusEnum
│   │   
│   │   
│   │   class WebhookAppInstalledSubscriber(DomainEventSubscriber):
│   │       """Subscribe to app installation events from webhook service"""
│   │   
│   │       stream_name = "WEBHOOK"
│   │       subject = "evt.webhook.app.installed"
│   │       subject = "evt.webhook.app.installed"
│   │       durable_name = "merchant-app-installed"
│   │   
│   │       async def on_event(self, event: dict, headers: dict):
│   │           """Handle app installation from Shopify"""
│   │           service = self.get_dependency("merchant_service")
│   │           logger = self.get_dependency("logger")
│   │   
│   │           payload = event["payload"]
│   │           correlation_id = event.get("correlation_id")
│   │   
│   │           logger.info(
│   │               "Processing app installation event",
│   │               extra={
│   │                   "subject": self.subject,
│   │                   "correlation_id": correlation_id,
│   │                   "shop_id": payload.get("shop_id"),
│   │               },
│   │           )
│   │   
│   │           # Process with service
│   │           await service.handle_app_installed(payload, correlation_id)
│   │   
│   │   
│   │   class BillingSubscriptionActivatedSubscriber(DomainEventSubscriber):
│   │       """Subscribe to subscription activation from billing service"""
│   │   
│   │       stream_name = "BILLING"
│   │       subject = "evt.billing.subscription.activated"
│   │       subject = "evt.billing.subscription.activated"
│   │       durable_name = "merchant-subscription-activated"
│   │   
│   │       async def on_event(self, event: dict, headers: dict):
│   │           """Handle subscription activation"""
│   │           service = self.get_dependency("merchant_service")
│   │           logger = self.get_dependency("logger")
│   │   
│   │           payload = event["payload"]
│   │           merchant_id = payload["merchant_id"]
│   │   
│   │           logger.info(
│   │               "Processing subscription activation",
│   │               extra={"subject": self.subject, "merchant_id": merchant_id},
│   │           )
│   │   
│   │           await service.update_merchant_status(
│   │               merchant_id, MerchantStatusEnum.ACTIVE, "subscription_activated"
│   │           )
│   │   ```
│   │   
│   └── types.py
│       
│       ```py
│       # services/merchant-service/src/events/types.py
│       class MerchantEvents:
│           """Event type constants"""
│           MERCHANT_CREATED = "evt.merchant.created"
│           MERCHANT_ACTIVATED = "evt.merchant.activated"
│           MERCHANT_SUSPENDED = "evt.merchant.suspended"
│           MERCHANT_DEACTIVATED = "evt.merchant.deactivated"
│           STATUS_CHANGED = "evt.merchant.status.changed"
│           CONFIG_UPDATED = "evt.merchant.config.updated"
│           ACTIVITY_RECORDED = "evt.merchant.activity.recorded"
│           ONBOARDING_STARTED = "evt.merchant.onboarding.started"
│           ONBOARDING_COMPLETED = "evt.merchant.onboarding.completed"
│       ```
│       
├── repositories/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/merchant-service/src/repositories/__init__.py
│   │   """Repository package for merchant service"""
│   │   
│   │   from .merchant_repository import MerchantRepository
│   │   
│   │   __all__ = [
│   │       "MerchantRepository",
│   │   ]
│   │   ```
│   │   
│   └── merchant_repository.py
│       
│       ```py
│       from typing import Optional, List
│       from uuid import UUID
│       from datetime import datetime
│       from prisma import Prisma
│       from prisma.models import Merchant, MerchantSettings, MerchantConsent, IdempotencyKey
│       from prisma.enums import MerchantStatus, ConsentType
│       from ..schemas.merchant import MerchantSyncIn, MerchantSettingsUpdate
│       
│       class MerchantRepository:
│           """Repository for Merchant operations using Prisma"""
│           
│           def __init__(self, prisma: Prisma):
│               self.prisma = prisma
│           
│           async def find_by_domain(self, shop_domain: str) -> Optional[Merchant]:
│               """Find merchant by shop domain"""
│               return await self.prisma.merchant.find_unique(
│                   where={"shop_domain": shop_domain.lower()}
│               )
│           
│           async def find_by_gid(self, shop_gid: str) -> Optional[Merchant]:
│               """Find merchant by shop GID"""
│               return await self.prisma.merchant.find_unique(
│                   where={"shop_gid": shop_gid}
│               )
│           
│           async def find_by_domain_or_gid(self, shop_domain: str, shop_gid: str) -> Optional[Merchant]:
│               """Find merchant by domain or GID"""
│               merchant = await self.prisma.merchant.find_first(
│                   where={
│                       "OR": [
│                           {"shop_domain": shop_domain.lower()},
│                           {"shop_gid": shop_gid}
│                       ]
│                   }
│               )
│               print(f"Found merchant: {merchant}")
│               return merchant
│           
│           async def create(self, data: MerchantSyncIn) -> Merchant:
│               """Create new merchant"""
│               merchant = await self.prisma.merchant.create(
│                   data={
│                       "shop_domain": data.shop_domain.lower(),
│                       "shop_gid": data.shop_gid,
│                       "shop_name": data.shop_name,
│                       "email": data.email,
│                       "timezone": data.timezone or "UTC",
│                       "currency": data.currency or "USD",
│                       "platform": "shopify",
│                       "platform_api_version": data.platform_api_version or "2024-01",
│                       "installed_at": datetime.utcnow(),
│                       "last_auth_at": data.auth_at,
│                       "app_version": data.app_version,
│                       "scopes": data.scopes,
│                       "install_source": data.install_source or "app_store",
│                       "status": MerchantStatus.PENDING
│                   }
│               )
│               
│               # Create default settings
│               await self.prisma.merchantsettings.create(
│                   data={
│                       "merchant_id": merchant.id,
│                       "data_access": False,
│                       "auto_sync": False,
│                       "tos": False
│                   }
│               )
│               
│               return merchant
│           
│           async def update(self, merchant_id: str, data: dict) -> Merchant:
│               """Update merchant"""
│               return await self.prisma.merchant.update(
│                   where={"id": merchant_id},
│                   data=data
│               )
│           
│           async def update_for_reinstall(self, merchant_id: str, data: MerchantSyncIn) -> Merchant:
│               """Update merchant for reinstall"""
│               return await self.prisma.merchant.update(
│                   where={"id": merchant_id},
│                   data={
│                       "uninstalled_at": None,
│                       "last_auth_at": data.auth_at,
│                       "app_version": data.app_version,
│                       "scopes": data.scopes,
│                       "shop_name": data.shop_name,
│                       "email": data.email,
│                       "timezone": data.timezone or "UTC",
│                       "currency": data.currency or "USD",
│                       "platform_api_version": data.platform_api_version or "2024-01",
│                       "install_source": data.install_source
│                   }
│               )
│           
│           async def update_status(self, merchant_id: str, new_status: MerchantStatus, reason: str, previous_status: MerchantStatus) -> Merchant:
│               """Update merchant status"""
│               return await self.prisma.merchant.update(
│                   where={"id": merchant_id},
│                   data={
│                       "status": new_status,
│                       "previous_status": previous_status,
│                       "status_reason": reason,
│                       "status_changed_at": datetime.utcnow()
│                   }
│               )
│           
│           async def update_last_activity(self, merchant_id: str) -> None:
│               """Update last activity timestamp"""
│               await self.prisma.merchant.update(
│                   where={"id": merchant_id},
│                   data={"last_activity_at": datetime.utcnow()}
│               )
│           
│           async def mark_uninstalled(self, merchant_id: str, reason: Optional[str] = None) -> Merchant:
│               """Mark merchant as uninstalled"""
│               return await self.prisma.merchant.update(
│                   where={"id": merchant_id},
│                   data={
│                       "uninstalled_at": datetime.utcnow(),
│                       "uninstall_reason": reason
│                   }
│               )
│           
│           # Settings operations
│           async def get_settings(self, merchant_id: str) -> Optional[MerchantSettings]:
│               """Get merchant settings"""
│               return await self.prisma.merchantsettings.find_unique(
│                   where={"merchant_id": merchant_id}
│               )
│           
│           async def update_settings(self, merchant_id: str, updates: MerchantSettingsUpdate) -> MerchantSettings:
│               """Update merchant settings"""
│               update_data = {k: v for k, v in updates.model_dump(exclude_unset=True).items() if v is not None}
│               update_data["updated_at"] = datetime.utcnow()
│               update_data["updated_by"] = "merchant-ui"
│               
│               return await self.prisma.merchantsettings.update(
│                   where={"merchant_id": merchant_id},
│                   data=update_data
│               )
│           
│           # Consent operations
│           async def create_consent_audit(self, merchant_id: str, consent_type: ConsentType, accepted: bool, source: str, ip: Optional[str] = None, user_agent: Optional[str] = None) -> MerchantConsent:
│               """Create consent audit record"""
│               return await self.prisma.merchantconsent.create(
│                   data={
│                       "merchant_id": merchant_id,
│                       "type": consent_type,
│                       "accepted": accepted,
│                       "source": source,
│                       "ip": ip,
│                       "user_agent": user_agent,
│                       "occurred_at": datetime.utcnow()
│                   }
│               )
│           
│           # Idempotency operations
│           async def check_idempotency_key(self, key: str) -> bool:
│               """Check if idempotency key exists"""
│               result = await self.prisma.idempotencykey.find_unique(
│                   where={"key": key}
│               )
│               return result is not None
│           
│           async def create_idempotency_key(self, key: str, scope: str) -> None:
│               """Create idempotency key"""
│               await self.prisma.idempotencykey.create(
│                   data={
│                       "key": key,
│                       "scope": scope
│                   }
│               )
│       
│       ```
│       
├── schemas/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   from .merchant import (
│   │       MerchantSyncIn,
│   │       MerchantSyncOut,
│   │       MerchantSelfIn,
│   │       MerchantSelfOut,
│   │       MerchantSyncedPayload,
│   │       MerchantStatusUpdatedPayload
│   │   )
│   │   
│   │   __all__ = [
│   │       "MerchantSyncIn",
│   │       "MerchantSyncOut",
│   │       "MerchantSelfIn",
│   │       "MerchantSelfOut",
│   │       "MerchantSyncedPayload",
│   │       "MerchantStatusUpdatedPayload"
│   │   ]
│   │   ```
│   │   
│   └── merchant.py
│       
│       ```py
│       # services/merchant-service/src/schemas/merchant.py
│       from pydantic import BaseModel, Field, EmailStr
│       from prisma.enums import MerchantStatus
│       
│       # ---------- INPUT DTOs ----------
│       class MerchantSyncIn(BaseModel):
│           """Input DTO for syncing merchant"""
│           platform: str = Field(..., description="Platform name (e.g., Shopify)")
│           platform_id: str = Field(..., description="Shopify Global ID (e.g., gid://shopify/Shop/123)")
│           platform_domain: str = Field(..., description="Shop domain (e.g., myshopify.com)")
│           name: str = Field(..., description="Shop display name")
│           email: EmailStr = Field(None, description="Shop contact email")
│           primary_domain: str = Field(..., description="Primary domain of the shop")
│           currency: str = Field(..., description="Shop currency (e.g., USD)")
│           country: str = Field(..., description="Shop country code (e.g., US)")
│           platform_version: str = Field(..., description="Shopify API version (e.g., 2024-01)")
│           scopes: str = Field(..., description="OAuth scopes granted by the shop")
│           
│       class MerchantSyncOut(BaseModel):
│           """Output DTO for merchant sync result"""
│           created: bool = Field(..., description="Indicates if the merchant was newly created")
│           merchant_id: str = Field(..., description="Unique identifier of the merchant")
│           
│       class MerchantSelfIn(BaseModel):
│           """Get self merchant"""
│           platform_id: str
│           platform_domain: str
│           
│       class MerchantSelfOut(BaseModel):
│           """Output DTO for self merchant"""
│           id: str
│           platform_id: str
│           platform_domain: str
│           name: str
│           status: MerchantStatus  
│       
│       # ---------- EVENT PAYLOADS ----------
│       class MerchantSyncedPayload(BaseModel):
│           """Payload for evt.merchant.synced"""
│           merchant_id: str
│           platform: str
│           platform_id: str
│           platform_domain: str
│           contact_email: EmailStr
│           name: str
│           status: MerchantStatus
│           
│       class MerchantStatusUpdatedPayload(BaseModel):
│           """Payload for evt.merchant.status_updated"""
│           merchant_id: str
│           platform_id: str
│           platform_domain: str
│           status: MerchantStatus
│       
│       ```
│       
├── services/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/merchant-service/src/services/__init__.py
│   │   """Service package for merchant service"""
│   │   
│   │   from .merchant_service import MerchantService
│   │   
│   │   __all__ = [
│   │       "MerchantService",
│   │   ]
│   │   ```
│   │   
│   └── merchant_service.py
│       
│       ```py
│       from typing import Optional
│       from datetime import datetime
│       from shared.utils.logger import ServiceLogger
│       from ..repositories.merchant_repository import MerchantRepository
│       from ..schemas.merchant import (
│           MerchantSyncIn, MerchantOut, MerchantSettingsUpdate, 
│           MerchantSettingsOut, MerchantSyncOut, MerchantActivity
│       )
│       from ..events.publishers import MerchantEventPublisher
│       from ..exceptions import (
│           MerchantNotFoundError, InvalidStatusTransitionError)
│       from prisma.enums import MerchantStatus, ConsentType
│       import redis.asyncio as redis
│       
│       # Status transition rules
│       STATUS_TRANSITIONS = {
│           MerchantStatus.PENDING: [MerchantStatus.ACTIVE, MerchantStatus.DEACTIVATED],
│           MerchantStatus.ACTIVE: [MerchantStatus.SUSPENDED, MerchantStatus.DEACTIVATED],
│           MerchantStatus.SUSPENDED: [MerchantStatus.ACTIVE, MerchantStatus.DEACTIVATED],
│           MerchantStatus.DEACTIVATED: []  # Terminal state
│       }
│       
│       class MerchantService:
│           """Business logic for merchant operations"""
│           
│           def __init__(
│               self,
│               repository: MerchantRepository,
│               publisher: MerchantEventPublisher,
│               logger: ServiceLogger,
│               # redis_client: redis.Redis
│           ):
│               self.repository = repository
│               self.publisher = publisher
│               self.logger = logger
│               # self.redis = redis_client
│           
│           async def sync_merchant(self, data: MerchantSyncIn, ctx) -> MerchantSyncOut:
│               """Sync merchant from OAuth flow"""
│               
│               self.logger.info(
│                   f"Syncing merchant: {data.shop_domain}",
│                   extra={
│                       "correlation_id": ctx.correlation_id,
│                       "shop_domain": data.shop_domain,
│                       "shop_gid": data.shop_gid
│                   }
│               )
│               
│               # Find existing merchant
│               existing = await self.repository.find_by_domain_or_gid(data.shop_domain, data.shop_gid)
│               
│               if existing:
│                   # Reinstall case
│                   merchant = await self.repository.update_for_reinstall(existing.id, data)
│                   created = False
│               else:
│                   # New install
│                   merchant = await self.repository.create(data)
│                   created = True
│                   
│                   # Publish merchant created event
│                   await self.publisher.publish_merchant_created(
│                       merchant_id=merchant.id,
│                       shop_gid=merchant.shop_gid,
│                       shop_domain=merchant.shop_domain,
│                       shop_name=merchant.shop_name,
│                       email=merchant.email,
│                       timezone=merchant.timezone,
│                       currency=merchant.currency,
│                       platform=merchant.platform,
│                       installed_at=merchant.installed_at,
│                       install_source=merchant.install_source
│                   )
│               
│               # Always publish synced event
│               await self.publisher.publish_merchant_synced(
│                   merchant_id=merchant.id,
│                   shop_gid=merchant.shop_gid,
│                   shop_domain=merchant.shop_domain,
│                   first_install=created,
│                   last_auth_at=data.auth_at,
│                   scopes=data.scopes
│               )
│               
│               result = MerchantSyncOut(created=created, merchant_id=merchant.id)
│               
│               return result
│           
│           async def get_merchant_by_domain(self, shop_domain: str) -> MerchantOut:
│               """Get merchant by shop domain"""
│               merchant = await self.repository.find_by_domain(shop_domain)
│               if not merchant:
│                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
│               
│               # Get settings to check if any consent is accepted
│               settings = await self.repository.get_settings(merchant.id)
│               settings_accepted = bool(settings and (settings.data_access or settings.auto_sync or settings.tos))
│               
│               return MerchantOut(
│                   merchant_id=merchant.id,
│                   shop_domain=merchant.shop_domain,
│                   shop_gid=merchant.shop_gid,
│                   shop_name=merchant.shop_name,
│                   email=merchant.email,
│                   timezone=merchant.timezone,
│                   currency=merchant.currency,
│                   installed_at=merchant.installed_at,
│                   uninstalled_at=merchant.uninstalled_at,
│                   last_auth_at=merchant.last_auth_at,
│                   last_activity_at=merchant.last_activity_at,
│                   status=merchant.status,
│                   status_reason=merchant.status_reason,
│                   settings_accepted=settings_accepted
│               )
│           
│           async def get_settings(self, shop_domain: str) -> MerchantSettingsOut:
│               """Get merchant settings"""
│               merchant = await self.repository.find_by_domain(shop_domain)
│               if not merchant:
│                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
│               
│               settings = await self.repository.get_settings(merchant.id)
│               if not settings:
│                   # Create default settings if missing
│                   settings = await self.repository.update_settings(
│                       merchant.id,
│                       MerchantSettingsUpdate(data_access=False, auto_sync=False, tos=False)
│                   )
│               
│               return MerchantSettingsOut(
│                   data_access=settings.data_access,
│                   auto_sync=settings.auto_sync,
│                   tos=settings.tos
│               )
│           
│           async def update_settings(self, shop_domain: str, updates: MerchantSettingsUpdate, ip: Optional[str] = None, user_agent: Optional[str] = None) -> MerchantSettingsOut:
│               """Update merchant settings"""
│               merchant = await self.repository.find_by_domain(shop_domain)
│               if not merchant:
│                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
│               
│               # Get current settings
│               current_settings = await self.repository.get_settings(merchant.id)
│               if not current_settings:
│                   # Create default settings if missing
│                   current_settings = await self.repository.update_settings(
│                       merchant.id,
│                       MerchantSettingsUpdate(data_access=False, auto_sync=False, tos=False)
│                   )
│               
│               # Track changes
│               changes = {}
│               consent_map = {
│                   'data_access': ConsentType.DATA_ACCESS,
│                   'auto_sync': ConsentType.AUTO_SYNC,
│                   'tos': ConsentType.TOS
│               }
│               
│               for field, value in updates.model_dump(exclude_unset=True).items():
│                   if value is not None:
│                       current_value = getattr(current_settings, field)
│                       if current_value != value:
│                           changes[field] = value
│                           
│                           # Log consent change
│                           await self.repository.create_consent_audit(
│                               merchant_id=merchant.id,
│                               consent_type=consent_map[field],
│                               accepted=value,
│                               source="ui",
│                               ip=ip,
│                               user_agent=user_agent
│                           )
│               
│               # Update settings if there are changes
│               if changes:
│                   updated_settings = await self.repository.update_settings(merchant.id, updates)
│                   
│                   # Publish settings updated event
│                   await self.publisher.publish_settings_updated(
│                       merchant_id=merchant.id,
│                       shop_gid=merchant.shop_gid,
│                       shop_domain=merchant.shop_domain,
│                       changes=changes,
│                       updated_at=datetime.utcnow()
│                   )
│               else:
│                   updated_settings = current_settings
│               
│               return MerchantSettingsOut(
│                   data_access=updated_settings.data_access,
│                   auto_sync=updated_settings.auto_sync,
│                   tos=updated_settings.tos
│               )
│           
│           async def record_activity(self, shop_domain: str, activity: MerchantActivity) -> None:
│               """Record merchant activity"""
│               merchant = await self.repository.find_by_domain(shop_domain)
│               if not merchant:
│                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
│               
│               # Update last activity timestamp
│               await self.repository.update_last_activity(merchant.id)
│               
│               # Publish activity event
│               await self.publisher.publish_activity_recorded(
│                   merchant_id=merchant.id,
│                   shop_gid=merchant.shop_gid,
│                   activity_type=activity.activity_type,
│                   activity_name=activity.activity_name,
│                   activity_data=activity.activity_data,
│                   timestamp=datetime.utcnow()
│               )
│           
│           async def update_merchant_status(self, merchant_id: str, new_status: MerchantStatus, reason: str) -> None:
│               """Update merchant status with validation"""
│               merchant = await self.repository.find_by_gid(merchant_id)
│               if not merchant:
│                   merchant = await self.repository.find_by_domain(merchant_id)
│               if not merchant:
│                   raise MerchantNotFoundError(f"Merchant not found: {merchant_id}")
│               
│               old_status = merchant.status
│               
│               # Validate transition
│               if new_status not in STATUS_TRANSITIONS.get(old_status, []):
│                   raise InvalidStatusTransitionError(
│                       f"Invalid status transition from {old_status} to {new_status}"
│                   )
│               
│               # Update status
│               await self.repository.update_status(merchant.id, new_status, reason, old_status)
│               
│               # Publish status changed event
│               await self.publisher.publish_status_changed(
│                   merchant_id=merchant.id,
│                   shop_gid=merchant.shop_gid,
│                   old_status=old_status,
│                   new_status=new_status,
│                   reason=reason,
│                   changed_at=datetime.utcnow()
│               )
│           
│           async def handle_app_uninstalled(self, shop_domain: str, uninstall_reason: Optional[str] = None) -> None:
│               """Handle app uninstalled webhook"""
│               merchant = await self.repository.find_by_domain(shop_domain)
│               if not merchant:
│                   self.logger.warning(
│                       f"Uninstall event for unknown merchant: {shop_domain}",
│                       extra={"shop_domain": shop_domain}
│                   )
│                   return
│               
│               # Update status to DEACTIVATED
│               await self.update_merchant_status(merchant.id, MerchantStatus.DEACTIVATED, "app_uninstalled")
│               
│               # Mark as uninstalled
│               await self.repository.mark_uninstalled(merchant.id, uninstall_reason)
│               
│               # Publish uninstalled event
│               await self.publisher.publish_merchant_uninstalled(
│                   merchant_id=merchant.id,
│                   shop_gid=merchant.shop_gid,
│                   shop_domain=merchant.shop_domain,
│                   uninstalled_at=datetime.utcnow(),
│                   uninstall_reason=uninstall_reason
│               )
│       
│       ```
│       
├── __init__.py
├── config.py
│   
│   ```py
│   import os
│   from functools import lru_cache
│   from typing import Optional
│   from pydantic import BaseModel, Field, ConfigDict, model_validator
│   from shared.utils.config_loader import merged_config, flatten_config
│   from shared.utils.exceptions import ConfigurationError
│   
│   class ServiceConfig(BaseModel):
│       """Service configuration from YAML + environment"""
│       model_config = ConfigDict(populate_by_name=True, extra="ignore")
│       
│       # Service Identity
│       service_name: str = Field(..., alias="service.name")
│       service_version: str = Field(..., alias="service.version")
│       service_description: str = Field(..., alias="service.description")
│       debug: bool = Field(..., alias="service.debug")
│       
│       # Environment - from env
│       environment: str = Field(..., alias="APP_ENV")
│       
│       # API Configuration
│       api_host: str = Field(..., alias="api.host")
│       api_external_port: int = Field(..., alias="MERCHANT_API_EXTERNAL_PORT")
│       api_cors_origins: list[str] = Field(..., alias="api.cors_origins")
│       
│       # Database
│       database_enabled: bool = Field(..., alias="MERCHANT_DB_ENABLED")
│       database_url: str = Field(..., alias="DATABASE_URL")
│   
│       # Logging
│       logging_level: str = Field(..., alias="logging.level")
│       logging_format: str = Field(..., alias="logging.format")
│       logging_file_path: str = Field(..., alias="logging.file_path")
│       
│       # Monitoring
│       monitoring_metrics_enabled: bool = Field(..., alias="monitoring.metrics_enabled")
│       monitoring_tracing_enabled: bool = Field(..., alias="monitoring.tracing_enabled")
│       
│       # Rate limiting
│       rate_limiting_enabled: bool = Field(..., alias="rate_limiting.enabled")
│       rate_limiting_window_seconds: int = Field(..., alias="rate_limiting.window_seconds")
│       
│       # Internal Authentication
│       internal_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
│       
│       # Computed properties
│       @property
│       def nats_url(self) -> str:
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "nats://nats:4222"
│           return "nats://localhost:4222"
│       
│       @property
│       def redis_url(self) -> str:
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "redis://redis:6379"
│           return "redis://localhost:6379"
│       
│       @property
│       def api_port(self) -> int:
│           in_container = os.path.exists("/.dockerenv")
│           return 8000 if in_container else self.api_external_port
│   
│       @model_validator(mode="after")
│       def _require_db_url_when_enabled(self):
│           if self.database_enabled and not self.database_url:
│               raise ValueError("database_enabled=true requires DATABASE_URL")
│           return self
│   
│   
│   @lru_cache
│   def get_service_config() -> ServiceConfig:
│       """Load and cache service configuration"""
│       try:
│           # Load YAML + all env vars
│           cfg_dict = merged_config("merchant-service")
│           flattened = flatten_config(cfg_dict)
│           return ServiceConfig(**flattened)
│           
│       except Exception as e:
│           print(f"❌ Configuration error: {e}")
│           raise ConfigurationError(
│               f"Failed to load service configuration: {e}", 
│               config_key="merchant-service", 
│               expected_value="valid config"
│           )
│   ```
│   
├── dependencies.py
│   
│   ```py
│   from typing import Annotated
│   from fastapi import Depends, Request, HTTPException, status
│   from shared.api.dependencies import (
│       RequestIdDep, PaginationDep, CorrelationIdDep, RequestContextDep
│   )
│   from .lifecycle import ServiceLifecycle
│   from .config import ServiceConfig
│   from .services import MerchantService
│   
│   __all__ = [
│       "CorrelationIdDep",
│       "PaginationDep",
│       "RequestIdDep",
│       "RequestContextDep",
│       "LifecycleDep",
│       "ConfigDep",
│       "MerchantServiceDep",
│   ]
│   
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       lc = getattr(request.app.state, "lifecycle", None)
│       if lc is None:
│           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Lifecycle not initialized")
│       return lc
│   
│   def get_config(request: Request) -> ServiceConfig:
│       cfg = getattr(request.app.state, "config", None)
│       if cfg is None:
│           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Config not initialized")
│       return cfg
│   
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
│   
│   def get_merchant_service(lifecycle: LifecycleDep) -> MerchantService:
│       svc = lifecycle.merchant_service
│       if svc is None:
│           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "MerchantService not initialized")
│       return svc
│   
│   MerchantServiceDep = Annotated[MerchantService, Depends(get_merchant_service)]
│   ```
│   
├── exceptions.py
│   
│   ```py
│   from shared.utils.exceptions import (
│       NotFoundError, ValidationError, ConflictError,
│       DomainError
│   )
│   
│   class MerchantNotFoundError(NotFoundError):
│       """Raised when merchant is not found"""
│       def __init__(self, message: str = "Merchant not found"):
│           super().__init__(message=message, resource="merchant")
│   
│   class InvalidDomainError(ValidationError):
│       """Raised when shop domain is invalid"""
│       def __init__(self, message: str = "Invalid shop domain format"):
│           super().__init__(message=message, field="shop_domain")
│   
│   class ConsentViolationError(ConflictError):
│       """Raised when trying to violate consent rules"""
│       def __init__(self, message: str = "Cannot unset required consent"):
│           super().__init__(message=message, conflicting_resource="consent")
│   
│   class InvalidStatusTransitionError(DomainError):
│       """Raised when status transition is invalid"""
│       def __init__(self, message: str):
│           super().__init__(message=message, code="INVALID_STATUS_TRANSITION")
│   
│   ```
│   
├── lifecycle.py
│   
│   ```py
│   # services/merchant-service/src/lifecycle.py
│   from typing import Optional, List, Dict, Any
│   import asyncio
│   from prisma import Prisma
│   from shared.messaging.jetstream_client import JetStreamClient
│   from shared.utils.logger import ServiceLogger
│   from .config import ServiceConfig
│   from .repositories import MerchantRepository
│   from .services.merchant_service import MerchantService
│   from .events.publishers import MerchantEventPublisher
│   
│   class ServiceLifecycle:
│       """Manages service lifecycle and dependencies"""
│   
│       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│   
│           # External connections
│           self.messaging_client: Optional[JetStreamClient] = None
│           self.prisma: Optional[Prisma] = None
│           self._db_connected: bool = False
│   
│           # Publisher / listeners
│           self.event_publisher: Optional[MerchantEventPublisher] = None
│           self._listeners: list = []
│   
│           # Repositories / mappers / services
│           self.merchant_repo: Optional[MerchantRepository] = None
│           self.merchant_service: Optional[MerchantService] = None
│   
│           # Tasks
│           self._tasks: List[asyncio.Task] = []
│           self._shutdown_event = asyncio.Event()
│   
│       async def startup(self) -> None:
│           try:
│               self.logger.info("Starting service components...")
│               await self._init_messaging()
│               await self._init_database()
│               self._init_repositories()
│               self._init_local_services()
│               await self._init_listeners()
│               self.logger.info("%s started successfully", self.config.service_name)
│           except Exception:
│               self.logger.critical("Service failed to start", exc_info=True)
│               await self.shutdown()
│               raise
│   
│       async def shutdown(self) -> None:
│           """Graceful shutdown of all components"""
│           self.logger.info("Shutting down %s", self.config.service_name)
│   
│           for t in self._tasks:
│               t.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│   
│           for lst in self._listeners:
│               try:
│                   await lst.stop()
│               except Exception:
│                   self.logger.critical("Listener stop failed")
│   
│           if self.messaging_client:
│               try:
│                   await self.messaging_client.close()
│               except Exception:
│                   self.logger.critical("Messaging client close failed")
│   
│           if self.prisma and self._db_connected:
│               try:
│                   await self.prisma.disconnect()
│               except Exception:
│                   self.logger.critical("Prisma disconnect failed")
│   
│           self.logger.info("%s shutdown complete", self.config.service_name)
│   
│       async def _init_messaging(self) -> None:
│           self.messaging_client = JetStreamClient(self.logger)
│           await self.messaging_client.connect([self.config.nats_url])
│           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.*", "cmd.*"])
│   
│           # Initialize publisher now (you require it in _init_listeners)
│           self.event_publisher = MerchantEventPublisher(
│               jetstream_client=self.messaging_client,
│               logger=self.logger
│           )
│           self.logger.info("Messaging client and publisher initialized")
│   
│       async def _init_database(self) -> None:
│           """Initialize Prisma client if database is enabled."""
│           if not self.config.database_enabled:
│               self.logger.info("Database disabled; skipping Prisma initialization")
│               return
│   
│           # Prisma reads DATABASE_URL from the environment; no args needed
│           self.prisma = Prisma()
│           
│           if not self.prisma:
│               raise RuntimeError("Prisma client not initialized")
│   
│           try:
│               await self.prisma.connect()
│               self._db_connected = True
│               self.logger.info("Prisma connected")
│           except Exception as e:
│               # Be explicit; this usually means DATABASE_URL is missing/invalid or client not generated
│               self.logger.error("Prisma connect failed: %s", e, exc_info=True)
│               raise
│   
│       # ---------------------------------------------------------------- repos
│       def _init_repositories(self) -> None:
│           if self.config.database_enabled:
│               if not (self.prisma and self._db_connected):
│                   raise RuntimeError("Prisma client not initialized/connected")
│               self.merchant_repo = MerchantRepository(self.prisma)
│               self.logger.info("Merchant repository initialized")
│           else:
│               self.merchant_repo = None  # service must handle db-disabled mode
│   
│       # ---------------------------------------------------------- local services
│       def _init_local_services(self) -> None:
│           
│           if not self.merchant_repo or not self.event_publisher:
│               raise RuntimeError("Merchant repository not initialized")
│           
│           self.merchant_service = MerchantService(
│               repository=self.merchant_repo,
│               publisher=self.event_publisher,
│               logger=self.logger
│               
│           )
│   
│       # -------------------------------------------------------------- listeners
│       async def _init_listeners(self) -> None:
│           if not self.messaging_client or not self.merchant_service or not self.event_publisher:
│               raise RuntimeError("Messaging or service layer not ready")
│   
│           # Initialize and start subscribers here when you add them
│           # await some_listener.start()
│           # self._listeners.append(some_listener)
│   
│       # ================================================= convenience helpers
│       def add_task(self, coro) -> asyncio.Task:
│           t = asyncio.create_task(coro)
│           self._tasks.append(t)
│           return t
│   
│       async def wait_for_shutdown(self) -> None:
│           await self._shutdown_event.wait()
│   
│       def signal_shutdown(self) -> None:
│           self._shutdown_event.set()
│   ```
│   
└── main.py
    
    ```py
    from contextlib import asynccontextmanager
    from fastapi import FastAPI
    from shared.api import setup_middleware
    from shared.api.health import create_health_router
    from shared.utils.logger import create_logger
    from .config import get_service_config
    from .lifecycle import ServiceLifecycle
    from .api import api_router
    
    # Global singletons
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """FastAPI lifespan adapter"""
        logger.info(f"Starting {config.service_name}", extra={
            "service_name": config.service_name,
            "version": config.service_version,
            "environment": config.environment,
            "api_host": config.api_host,
            "api_port": config.api_port,
        })
        
        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger
        
        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()
    
    def create_application() -> FastAPI:
        """Create and configure the FastAPI application."""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            lifespan=lifespan,
            description=config.service_description,
            docs_url="/docs",
            redoc_url="/redoc",
            exception_handlers={}  # Use shared middleware for exception handling
        )
        
        setup_middleware(
            app,
            service_name=config.service_name,
            enable_metrics=config.monitoring_metrics_enabled,
            metrics_path="/metrics"
        )
        
        # Include routers
        app.include_router(create_health_router(config.service_name))
        app.include_router(api_router)
        
        
        return app
    
    app = create_application()
    
    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(
            "src.main:app",
            host=config.api_host,
            port=config.api_port,
            reload=config.debug
        )
    
    ```
    
tests/
└── __init__.py
.env.example
.pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files

  - repo: https://github.com/psf/black
    rev: 23.11.0
    hooks:
      - id: black
        args: [--line-length=100]

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: [--profile=black, --line-length=100]

  - repo: https://github.com/pycqa/flake8
    rev: 6.1.0
    hooks:
      - id: flake8
        args: [--max-line-length=100, --extend-ignore=E203,W503]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.7.1
    hooks:
      - id: mypy
        args: [--strict, --ignore-missing-imports]

  # Custom hooks for ID management
  - repo: local
    hooks:
      - id: check-uuid4-usage
        name: Check for manual uuid4() usage
        entry: bash -c 'if grep -r "uuid4()" --include="*.py" --exclude-dir=tests .; then echo "Use uuid7() instead of uuid4() for event IDs"; exit 1; fi'
        language: system
        pass_filenames: false

```

.python-version
__init__.py
docker-compose.yml

```yml
version: '3.8'

services:
  merchant-service:
    build: .
    ports:
      - "8113:8000"
      - "9090:9090"  # Metrics
    environment:
      - DATABASE_URL=postgresql://merchant:password@postgres:5432/merchant_db
      - REDIS_URL=redis://redis:6379
      - NATS_URL=nats://nats:4222
      - BACKEND_API_KEY=test-api-key
      - LOG_LEVEL=INFO
      - DEBUG=false
      - DOCKER_CONTAINER=1
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      nats:
        condition: service_started
    volumes:
      - ./src:/app/src  # Hot reload
      - ./config:/app/config  # Mount config
    networks:
      - merchant-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: merchant_db
      POSTGRES_USER: merchant
      POSTGRES_PASSWORD: password
    ports:
      - "5413:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - merchant-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U merchant -d merchant_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6313:6379"
    volumes:
      - redis_data:/data
    networks:
      - merchant-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nats:
    image: nats:2.10-alpine
    ports:
      - "4213:4222"
      - "8213:8222"  # HTTP monitoring
    command: [
      "nats-server",
      "--jetstream",
      "--store_dir=/data",
      "--http_port=8222"
    ]
    volumes:
      - nats_data:/data
    networks:
      - merchant-network

volumes:
  postgres_data:
  redis_data:
  nats_data:

networks:
  merchant-network:
    driver: bridge

```

Dockerfile

```
# ──────────────────────────────────────────────────────────────
# 📦  Stage 1 ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim AS builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry
RUN poetry config virtualenvs.create false

# ---- 1️⃣  Install shared package dependencies
COPY shared /shared
WORKDIR /shared
RUN poetry install --no-dev

# ---- 2️⃣  Install service dependencies  
WORKDIR /app
COPY services/merchant-service/pyproject.toml services/merchant-service/poetry.lock* ./
RUN poetry install --no-dev --no-interaction --no-ansi

# ---- 3️⃣  Copy Prisma schema and generate client
COPY services/merchant-service/prisma ./prisma
RUN prisma generate

# ---- 4️⃣  Copy service code
COPY services/merchant-service /app

# ---- 5️⃣  Copy config
COPY config /app/config

# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime  
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app /app
COPY --from=builder /shared /shared

ENV PYTHONPATH="/shared:/app"
ENV DOCKER_CONTAINER=1

WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run migrations and start server
CMD ["sh", "-c", "prisma migrate deploy && uvicorn src.main:app --host 0.0.0.0 --port 8000"]

```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
# services/merchant-service/pyproject.toml
[tool.poetry]
name = "merchant-service"
version = "1.0.0"
description = "Merchant identity and consent management service"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
email-validator = "^2.1.0"
prisma = "^0.15.0"
nats-py = "^2.6.0"
redis = "^5.0.1"
python-multipart = "^0.0.6"
httpx = "^0.25.2"
python-dotenv = "^1.0.0"
prometheus-client = "^0.19.0"
uuid7 = "^0.1.0"
shared = { path = "../../shared", develop = true }

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
isort = "^5.12.0"
flake8 = "^6.1.0"
mypy = "^1.7.1"
pre-commit = "^3.6.0"

[tool.poetry.group.test.dependencies]
httpx = "^0.25.2"
pytest-mock = "^3.12.0"
testcontainers = "^3.7.1"

[tool.pytest.ini_options]
minversion = "7.0"
addopts = "-ra -q --strict-markers --strict-config"
testpaths = ["tests"]
pythonpath = ["src"]
asyncio_mode = "auto"
markers = [
    "unit: Unit tests",
    "integration: Integration tests",
    "e2e: End-to-end tests"
]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.mypy]
python_version = "3.11"
strict = true
ignore_missing_imports = true

[tool.coverage.run]
source = ["src"]
omit = ["tests/*", "*/migrations/*", "*/__init__.py"]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

README.md

```md
# Merchant Service

Merchant identity and consent management service for the GLAM platform.

## Overview

The Merchant Service manages:
- Merchant identity and installation lifecycle
- Consent settings (data access, auto-sync, TOS)
- OAuth sync after Shopify installation
- Activity tracking for analytics
- Status management (PENDING, ACTIVE, SUSPENDED, DEACTIVATED)

## Port Configuration

- Internal Port: 8013 (container)
- External Port: 8113 (local development)
- Database Port: 5413
- Redis Port: 6313
- NATS Port: 4213

## Setup

1. Install dependencies:
```bash
poetry install
```

2. Set up environment:
```bash
cp .env.example .env
# Edit .env with your secrets
```

3. Generate Prisma client:
```bash
prisma generate
```

4. Run migrations:
```bash
prisma migrate dev
```

5. Start service:
```bash
```


================================================================================
Output includes file contents
================================================================================