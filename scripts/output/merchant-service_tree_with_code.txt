================================================================================
Directory Structure: /home/bellabe/glam-app/services/merchant-service
================================================================================

merchant-service/
.ruff_cache/
â”œâ”€â”€ 0.1.9/
â”‚   â””â”€â”€ 608319233369684344
â”œâ”€â”€ .gitignore
â””â”€â”€ CACHEDIR.TAG
prisma/
â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ 20250814041744_desktop_pgt_1_cqb/
â”‚   â”‚   â””â”€â”€ migration.sql
â”‚   â”‚
â”‚   â”‚       ```sql
â”‚   â”‚       -- CreateEnum
â”‚   â”‚       CREATE TYPE "MerchantStatus" AS ENUM ('PENDING', 'ACTIVE', 'PAUSED', 'SUSPENDED', 'UNINSTALLED');
â”‚   â”‚
â”‚   â”‚       -- CreateTable
â”‚   â”‚       CREATE TABLE "merchants" (
â”‚   â”‚           "id" UUID NOT NULL,
â”‚   â”‚           "platform_name" TEXT NOT NULL,
â”‚   â”‚           "platform_id" TEXT NOT NULL,
â”‚   â”‚           "platform_domain" TEXT NOT NULL,
â”‚   â”‚           "name" TEXT NOT NULL,
â”‚   â”‚           "email" TEXT NOT NULL,
â”‚   â”‚           "primary_domain" TEXT,
â”‚   â”‚           "currency" TEXT NOT NULL DEFAULT 'USD',
â”‚   â”‚           "country" TEXT,
â”‚   â”‚           "platform_version" TEXT NOT NULL,
â”‚   â”‚           "scopes" TEXT,
â”‚   â”‚           "status" "MerchantStatus" NOT NULL DEFAULT 'PENDING',
â”‚   â”‚           "status_changed_at" TIMESTAMP(3),
â”‚   â”‚           "installed_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
â”‚   â”‚           "uninstalled_at" TIMESTAMP(3),
â”‚   â”‚           "last_sync_at" TIMESTAMP(3),
â”‚   â”‚           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
â”‚   â”‚           "updated_at" TIMESTAMPTZ(3) NOT NULL,
â”‚   â”‚
â”‚   â”‚           CONSTRAINT "merchants_pkey" PRIMARY KEY ("id")
â”‚   â”‚       );
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE INDEX "merchants_platform_id_platform_domain_idx" ON "merchants"("platform_id", "platform_domain");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE INDEX "merchants_platform_domain_idx" ON "merchants"("platform_domain");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE INDEX "merchants_status_idx" ON "merchants"("status");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE UNIQUE INDEX "merchants_platform_name_platform_id_key" ON "merchants"("platform_name", "platform_id");
â”‚   â”‚
â”‚   â”‚       -- CreateIndex
â”‚   â”‚       CREATE UNIQUE INDEX "merchants_platform_name_platform_domain_key" ON "merchants"("platform_name", "platform_domain");
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â””â”€â”€ migration_lock.toml
â”‚
â”‚       ```toml
â”‚       # Please do not edit this file manually
â”‚       # It should be added in your version-control system (i.e. Git)
â”‚       provider = "postgresql"
â”‚       ```
â”‚
â””â”€â”€ schema.prisma
src/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   ```py
â”‚   â”‚   â”‚   # services/merchant-service/src/api/v1/__init__.py
â”‚   â”‚   â”‚   from fastapi import APIRouter
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   from .merchants import merchants_router
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   v1_router = APIRouter(prefix="/v1")
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   v1_router.include_router(merchants_router, tags=["merchants"])
â”‚   â”‚   â”‚   ```
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ merchants.py
â”‚   â”‚
â”‚   â”‚       ```py
â”‚   â”‚       # services/merchant-service/src/api/v1/merchants.py
â”‚   â”‚       from fastapi import APIRouter, HTTPException, status
â”‚   â”‚
â”‚   â”‚       from shared.api import ApiResponse, success_response
â”‚   â”‚       from shared.api.dependencies import (
â”‚   â”‚           ClientAuthDep,
â”‚   â”‚           LoggerDep,
â”‚   â”‚           PlatformContextDep,
â”‚   â”‚           RequestContextDep,
â”‚   â”‚       )
â”‚   â”‚       from shared.api.validation import validate_shop_context
â”‚   â”‚
â”‚   â”‚       from ...dependencies import MerchantServiceDep
â”‚   â”‚       from ...exceptions import MerchantNotFoundError
â”‚   â”‚       from ...schemas import MerchantSelfOut, MerchantSyncIn, MerchantSyncOut
â”‚   â”‚
â”‚   â”‚       merchants_router = APIRouter(prefix="/merchants")
â”‚   â”‚
â”‚   â”‚
â”‚   â”‚       @merchants_router.post(
â”‚   â”‚           "/sync",
â”‚   â”‚           response_model=ApiResponse[MerchantSyncOut],
â”‚   â”‚           status_code=status.HTTP_200_OK,
â”‚   â”‚           summary="Sync merchant from OAuth flow",
â”‚   â”‚           description="Create or update merchant after OAuth completion. Used in afterAuth hooks.",
â”‚   â”‚       )
â”‚   â”‚       async def sync_merchant(
â”‚   â”‚           body: MerchantSyncIn,
â”‚   â”‚           service: MerchantServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           client_auth: ClientAuthDep,
â”‚   â”‚           platform_ctx: PlatformContextDep,
â”‚   â”‚           logger: LoggerDep,
â”‚   â”‚       ):
â”‚   â”‚           """Sync merchant after OAuth completion."""
â”‚   â”‚           validate_shop_context(
â”‚   â”‚               client_auth=client_auth,
â”‚   â”‚               platform_ctx=platform_ctx,
â”‚   â”‚               logger=logger,
â”‚   â”‚               body_platform=body.platform_name,
â”‚   â”‚               body_domain=body.shop_domain,
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           logger.set_request_context(
â”‚   â”‚               platform=platform_ctx.platform,
â”‚   â”‚               domain=platform_ctx.domain,
â”‚   â”‚               platform_shop_id=body.platform_shop_id,
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           logger.info("Starting merchant sync")
â”‚   â”‚
â”‚   â”‚           try:
â”‚   â”‚               result = await service.sync_merchant(body, ctx)
â”‚   â”‚
â”‚   â”‚               logger.info(
â”‚   â”‚                   "Merchant synced successfully",
â”‚   â”‚                   extra={
â”‚   â”‚                       "merchant_id": result.merchant_id,
â”‚   â”‚                       "operation": "create" if result.created else "update",
â”‚   â”‚                   },
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               return success_response(result, ctx.request_id, ctx.correlation_id)
â”‚   â”‚
â”‚   â”‚           except Exception as e:
â”‚   â”‚               logger.error(
â”‚   â”‚                   "Merchant sync failed",
â”‚   â”‚                   extra={"error_type": type(e).__name__, "error_message": str(e)},
â”‚   â”‚               )
â”‚   â”‚               raise
â”‚   â”‚
â”‚   â”‚
â”‚   â”‚       @merchants_router.get(
â”‚   â”‚           "/self",
â”‚   â”‚           response_model=ApiResponse[MerchantSelfOut],
â”‚   â”‚           status_code=status.HTTP_200_OK,
â”‚   â”‚           summary="Get current merchant",
â”‚   â”‚           description="Get current merchant using platform context from headers",
â”‚   â”‚       )
â”‚   â”‚       async def get_current_merchant(
â”‚   â”‚           service: MerchantServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           client_auth: ClientAuthDep,
â”‚   â”‚           platform_ctx: PlatformContextDep,
â”‚   â”‚           logger: LoggerDep,
â”‚   â”‚       ):
â”‚   â”‚           """Get current merchant using platform context from headers."""
â”‚   â”‚
â”‚   â”‚           # Security validation
â”‚   â”‚           if client_auth.shop != platform_ctx.domain:
â”‚   â”‚               logger.warning(
â”‚   â”‚                   "Shop domain mismatch between JWT and headers",
â”‚   â”‚                   extra={"jwt_shop": client_auth.shop, "header_domain": platform_ctx.domain},
â”‚   â”‚               )
â”‚   â”‚               raise HTTPException(
â”‚   â”‚                   status_code=status.HTTP_401_UNAUTHORIZED,
â”‚   â”‚                   detail={
â”‚   â”‚                       "code": "SHOP_DOMAIN_MISMATCH",
â”‚   â”‚                       "message": "Shop domain mismatch between JWT and headers",
â”‚   â”‚                       "details": {
â”‚   â”‚                           "jwt_shop": client_auth.shop,
â”‚   â”‚                           "header_domain": platform_ctx.domain,
â”‚   â”‚                       },
â”‚   â”‚                   },
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           logger.set_request_context(platform=platform_ctx.platform, domain=platform_ctx.domain)
â”‚   â”‚
â”‚   â”‚           logger.info("Getting current merchant")
â”‚   â”‚
â”‚   â”‚           try:
â”‚   â”‚               merchant = await service.get_merchant_by_domain(
â”‚   â”‚                   shop_domain=platform_ctx.domain,
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               logger.info(
â”‚   â”‚                   "Current merchant retrieved successfully",
â”‚   â”‚                   extra={"merchant_id": merchant.id},
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               return success_response(merchant, ctx.request_id, ctx.correlation_id)
â”‚   â”‚
â”‚   â”‚           except MerchantNotFoundError:
â”‚   â”‚               logger.warning("Current merchant not found")
â”‚   â”‚
â”‚   â”‚               raise HTTPException(
â”‚   â”‚                   status_code=status.HTTP_404_NOT_FOUND,
â”‚   â”‚                   detail={
â”‚   â”‚                       "code": "MERCHANT_NOT_FOUND",
â”‚   â”‚                       "message": "Merchant not found for current shop",
â”‚   â”‚                       "details": {
â”‚   â”‚                           "platform": platform_ctx.platform,
â”‚   â”‚                           "domain": platform_ctx.domain,
â”‚   â”‚                       },
â”‚   â”‚                   },
â”‚   â”‚               ) from MerchantNotFoundError(f"Merchant not found for domain {platform_ctx.domain}")
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â””â”€â”€ __init__.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/api/__init__.py
â”‚       from fastapi import APIRouter
â”‚
â”‚       from .v1 import v1_router
â”‚
â”‚       api_router = APIRouter(prefix="/api")
â”‚
â”‚       # Include v1 routes
â”‚       api_router.include_router(v1_router)
â”‚       ```
â”‚
â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ listeners.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   from shared.messaging.jetstream_client import JetStreamClient
â”‚   â”‚   from shared.messaging.listener import Listener
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚
â”‚   â”‚   from ..services.merchant_service import MerchantService
â”‚   â”‚
â”‚   â”‚
â”‚   â”‚   class AppUninstalledListener(Listener):
â”‚   â”‚       """Listener for app uninstalled webhook events"""
â”‚   â”‚
â”‚   â”‚       @property
â”‚   â”‚       def subject(self) -> str:
â”‚   â”‚           return "evt.webhook.app.uninstalled.v1"
â”‚   â”‚
â”‚   â”‚       @property
â”‚   â”‚       def queue_group(self) -> str:
â”‚   â”‚           return "merchant-uninstall"
â”‚   â”‚
â”‚   â”‚       @property
â”‚   â”‚       def service_name(self) -> str:
â”‚   â”‚           return "merchant-service"
â”‚   â”‚
â”‚   â”‚       def __init__(self, js_client: JetStreamClient, service: MerchantService, logger: ServiceLogger):
â”‚   â”‚           super().__init__(js_client, logger)
â”‚   â”‚           self.service = service
â”‚   â”‚
â”‚   â”‚       async def on_message(self, data: dict) -> None:
â”‚   â”‚           """Handle app uninstalled event"""
â”‚   â”‚           try:
â”‚   â”‚               shop_domain = data.get("shop_domain")
â”‚   â”‚               uninstall_reason = data.get("uninstall_reason")
â”‚   â”‚
â”‚   â”‚               if not shop_domain:
â”‚   â”‚                   self.logger.error("Missing shop_domain in uninstall event", extra={"data": data})
â”‚   â”‚                   return
â”‚   â”‚
â”‚   â”‚               self.logger.info(
â”‚   â”‚                   f"Processing app uninstall for {shop_domain}",
â”‚   â”‚                   extra={"shop_domain": shop_domain, "uninstall_reason": uninstall_reason},
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚               await self.service.handle_app_uninstalled(shop_domain, uninstall_reason)
â”‚   â”‚
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.logger.error(f"Failed to process app uninstall: {e}", exc_info=True, extra={"data": data})
â”‚   â”‚               raise  # NACK for retry
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ publishers.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/events/publishers.py
â”‚       from datetime import UTC, datetime
â”‚
â”‚       from prisma.enums import MerchantStatus
â”‚
â”‚       from shared.messaging.publisher import Publisher
â”‚
â”‚       from ..schemas.merchant import MerchantStatusUpdatedPayload, MerchantSyncedPayload
â”‚
â”‚
â”‚       class MerchantEventPublisher(Publisher):
â”‚           """Publisher for merchant domain events"""
â”‚
â”‚           @property
â”‚           def service_name(self) -> str:
â”‚               return "merchant-service"
â”‚
â”‚           async def publish_merchant_created(
â”‚               self,
â”‚               correlation_id: str,
â”‚               merchant_id: str,
â”‚               platform_name: str,
â”‚               platform_shop_id: str,
â”‚               shop_domain: str,
â”‚               name: str,
â”‚               email: str,
â”‚               installed_at: datetime,
â”‚           ) -> str:
â”‚               """Publish evt.merchant.installed event"""
â”‚
â”‚               self.logger.info(
â”‚                   "Publishing merchant installed event",
â”‚                   extra={"correlation_id": correlation_id, "merchant_id": merchant_id, "shop_domain": shop_domain},
â”‚               )
â”‚
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.created.v1",
â”‚                   data={
â”‚                       "merchant_id": merchant_id,
â”‚                       "platform_name": platform_name,
â”‚                       "platform_shop_id": platform_shop_id,
â”‚                       "shop_domain": shop_domain,
â”‚                       "name": name,
â”‚                       "email": email,
â”‚                       "installed_at": installed_at.isoformat(),
â”‚                   },
â”‚                   correlation_id=correlation_id,
â”‚               )
â”‚
â”‚           async def publish_merchant_reinstalled(
â”‚               self, correlation_id: str, merchant_id: str, platform_shop_id: str, shop_domain: str, name: str, email: str
â”‚           ) -> str:
â”‚               """Publish evt.merchant.reinstalled event"""
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.reinstalled.v1",
â”‚                   data={
â”‚                       "merchant_id": merchant_id,
â”‚                       "platform_shop_id": platform_shop_id,
â”‚                       "shop_domain": shop_domain,
â”‚                       "name": name,
â”‚                       "email": email,
â”‚                       "reinstalled_at": datetime.utcnow().isoformat(),
â”‚                   },
â”‚                   correlation_id=correlation_id,
â”‚               )
â”‚
â”‚           async def publish_merchant_synced(self, correlation_id: str, payload: MerchantSyncedPayload) -> str:
â”‚               """Publish evt.merchant.synced event"""
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.synced.v1", data=payload.model_dump(), correlation_id=correlation_id
â”‚               )
â”‚
â”‚           async def publish_status_changed(
â”‚               self,
â”‚               correlation_id: str,  # REQUIRED
â”‚               old_status: MerchantStatus,
â”‚               payload: MerchantStatusUpdatedPayload,
â”‚           ) -> str:
â”‚               """Publish evt.merchant.status.changed event"""
â”‚               return await self.publish_event(
â”‚                   subject="evt.merchant.status.changed.v1",
â”‚                   data={**payload.model_dump(), "old_status": old_status.value, "changed_at": datetime.now(UTC).isoformat()},
â”‚                   correlation_id=correlation_id,
â”‚               )
â”‚       ```
â”‚
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   # services/merchant-service/src/repositories/__init__.py
â”‚   â”‚   """Repository package for merchant service"""
â”‚   â”‚
â”‚   â”‚   from .merchant_repository import MerchantRepository
â”‚   â”‚
â”‚   â”‚   __all__ = [
â”‚   â”‚       "MerchantRepository",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ merchant_repository.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/repositories/merchant_repository.py
â”‚       from datetime import UTC, datetime
â”‚
â”‚       from prisma import Prisma  # type: ignore[attr-defined]
â”‚       from prisma.enums import MerchantStatus
â”‚       from prisma.models import Merchant
â”‚
â”‚       from ..schemas.merchant import MerchantSyncIn
â”‚
â”‚
â”‚       class MerchantRepository:
â”‚           """Repository for Merchant operations using Prisma"""
â”‚
â”‚           def __init__(self, prisma: Prisma):
â”‚               self.prisma = prisma
â”‚
â”‚           async def find_by_platform_shop_identity(
â”‚               self, platform_name: str, shop_domain: str, platform_shop_id: str | None = None
â”‚           ) -> Merchant | None:
â”‚               """Find merchant by platform identity"""
â”‚               conditions = [{"platform_name": platform_name, "shop_domain": shop_domain.lower()}]
â”‚               if platform_shop_id:
â”‚                   conditions.append({"platform_name": platform_name, "platform_shop_id": platform_shop_id})
â”‚
â”‚               return await self.prisma.merchant.find_first(where={"OR": conditions})
â”‚
â”‚           async def find_by_shop_domain(self, shop_domain: str) -> Merchant | None:
â”‚               """Find merchant by platform domain"""
â”‚               return await self.prisma.merchant.find_first(where={"shop_domain": shop_domain.lower()})
â”‚
â”‚           async def create(self, data: MerchantSyncIn) -> Merchant:
â”‚               """Create new merchant"""
â”‚               return await self.prisma.merchant.create(
â”‚                   data={
â”‚                       "platform_name": data.platform_name.lower(),
â”‚                       "platform_shop_id": data.platform_shop_id,
â”‚                       "shop_domain": data.shop_domain.lower(),  # myshopify domain
â”‚                       "name": data.shop_name,
â”‚                       "email": data.email,
â”‚                       "primary_domain": data.primary_domain_host,  # could be custom domain
â”‚                       "currency": data.currency,
â”‚                       "country": data.country,
â”‚                       "platform_version": data.platform_version,
â”‚                       "scopes": data.scopes,
â”‚                       "status": MerchantStatus.PENDING,
â”‚                       "installed_at": datetime.now(UTC),
â”‚                       "last_sync_at": datetime.now(UTC),
â”‚                   }
â”‚               )
â”‚
â”‚           async def update_for_sync(self, merchant_id: str, data: MerchantSyncIn) -> Merchant:
â”‚               """Update merchant on sync (reinstall or resync)"""
â”‚               return await self.prisma.merchant.update(
â”‚                   where={"id": merchant_id},
â”‚                   data={
â”‚                       "name": data.shop_name,
â”‚                       "email": data.email,
â”‚                       "primary_domain": data.primary_domain_host,
â”‚                       "currency": data.currency,
â”‚                       "country": data.country,
â”‚                       "platform_version": data.platform_version,
â”‚                       "scopes": data.scopes,
â”‚                       "last_sync_at": datetime.utcnow(),
â”‚                       "uninstalled_at": None,  # Clear if reinstalling
â”‚                   },
â”‚               )
â”‚
â”‚           async def update_status(self, merchant_id: str, new_status: MerchantStatus) -> Merchant:
â”‚               """Update merchant status"""
â”‚               update_data = {"status": new_status, "status_changed_at": datetime.utcnow()}
â”‚
â”‚               # Set uninstalled_at if uninstalling
â”‚               if new_status == MerchantStatus.UNINSTALLED:
â”‚                   update_data["uninstalled_at"] = datetime.utcnow()
â”‚
â”‚               return await self.prisma.merchant.update(where={"id": merchant_id}, data=update_data)
â”‚       ```
â”‚
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   from .merchant import (
â”‚   â”‚       MerchantSelfOut,
â”‚   â”‚       MerchantStatusUpdatedPayload,
â”‚   â”‚       MerchantSyncedPayload,
â”‚   â”‚       MerchantSyncIn,
â”‚   â”‚       MerchantSyncOut,
â”‚   â”‚   )
â”‚   â”‚
â”‚   â”‚   __all__ = [
â”‚   â”‚       "MerchantSelfOut",
â”‚   â”‚       "MerchantStatusUpdatedPayload",
â”‚   â”‚       "MerchantSyncIn",
â”‚   â”‚       "MerchantSyncOut",
â”‚   â”‚       "MerchantSyncedPayload",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ merchant.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/schemas/merchant.py
â”‚       from prisma.enums import MerchantStatus
â”‚       from pydantic import BaseModel, Field
â”‚
â”‚
â”‚       # ---------- INPUT DTOs ----------
â”‚       class MerchantSyncIn(BaseModel):
â”‚           """Input DTO for syncing merchant"""
â”‚
â”‚           platform_name: str = Field(..., description="Platform name (e.g., Shopify)")
â”‚           platform_shop_id: str = Field(..., description="Shopify Global ID (e.g., gid://shopify/Shop/123)")
â”‚           shop_domain: str = Field(..., description="Shop domain (e.g., myshopify.com)")
â”‚           shop_name: str = Field(..., description="Shop display name")
â”‚           email: str = Field(..., description="Shop contact email")
â”‚           primary_domain_host: str = Field(..., description="Primary domain of the shop")
â”‚           currency: str = Field(..., description="Shop currency (e.g., USD)")
â”‚           country: str = Field(..., description="Shop country code (e.g., US)")
â”‚           platform_version: str = Field(..., description="Shopify API version (e.g., 2025-01)")
â”‚           scopes: str = Field(..., description="OAuth scopes granted by the shop")
â”‚
â”‚
â”‚       class MerchantSyncOut(BaseModel):
â”‚           """Output DTO for merchant sync result"""
â”‚
â”‚           created: bool = Field(..., description="Indicates if the merchant was newly created")
â”‚           merchant_id: str = Field(..., description="Unique identifier of the merchant")
â”‚
â”‚
â”‚       class MerchantSelfOut(BaseModel):
â”‚           """Output DTO for self merchant"""
â”‚
â”‚           id: str
â”‚           platform_shop_id: str
â”‚           shop_domain: str
â”‚           shop_name: str
â”‚           status: MerchantStatus
â”‚
â”‚
â”‚       # ---------- EVENT PAYLOADS ----------
â”‚       class MerchantSyncedPayload(BaseModel):
â”‚           """Payload for evt.merchant.synced"""
â”‚
â”‚           merchant_id: str
â”‚           platform_name: str
â”‚           platform_shop_id: str
â”‚           shop_domain: str
â”‚           contact_email: str
â”‚           name: str
â”‚           status: MerchantStatus
â”‚
â”‚
â”‚       class MerchantStatusUpdatedPayload(BaseModel):
â”‚           """Payload for evt.merchant.status_updated"""
â”‚
â”‚           merchant_id: str
â”‚           platform_shop_id: str
â”‚           shop_domain: str
â”‚           status: MerchantStatus
â”‚       ```
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   # services/merchant-service/src/services/__init__.py
â”‚   â”‚   """Service package for merchant service"""
â”‚   â”‚
â”‚   â”‚   from .merchant_service import MerchantService
â”‚   â”‚
â”‚   â”‚   __all__ = [
â”‚   â”‚       "MerchantService",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ merchant_service.py
â”‚
â”‚       ```py
â”‚       # services/merchant-service/src/services/merchant_service.py
â”‚       from prisma.enums import MerchantStatus
â”‚
â”‚       from shared.utils.logger import ServiceLogger
â”‚
â”‚       from ..events.publishers import MerchantEventPublisher
â”‚       from ..exceptions import InvalidStatusTransitionError, MerchantNotFoundError
â”‚       from ..repositories.merchant_repository import MerchantRepository
â”‚       from ..schemas.merchant import (
â”‚           MerchantSelfOut,
â”‚           MerchantStatusUpdatedPayload,
â”‚           MerchantSyncedPayload,
â”‚           MerchantSyncIn,
â”‚           MerchantSyncOut,
â”‚       )
â”‚
â”‚       # Status transition rules
â”‚       STATUS_TRANSITIONS = {
â”‚           MerchantStatus.PENDING: [MerchantStatus.ACTIVE, MerchantStatus.UNINSTALLED],
â”‚           MerchantStatus.ACTIVE: [MerchantStatus.PAUSED, MerchantStatus.SUSPENDED, MerchantStatus.UNINSTALLED],
â”‚           MerchantStatus.PAUSED: [MerchantStatus.ACTIVE, MerchantStatus.SUSPENDED, MerchantStatus.UNINSTALLED],
â”‚           MerchantStatus.SUSPENDED: [MerchantStatus.ACTIVE, MerchantStatus.PAUSED, MerchantStatus.UNINSTALLED],
â”‚           MerchantStatus.UNINSTALLED: [MerchantStatus.PENDING],
â”‚       }
â”‚
â”‚
â”‚       class MerchantService:
â”‚           """Business logic for merchant operations"""
â”‚
â”‚           def __init__(self, repository: MerchantRepository, publisher: MerchantEventPublisher, logger: ServiceLogger):
â”‚               self.repository = repository
â”‚               self.publisher = publisher
â”‚               self.logger = logger
â”‚
â”‚           async def sync_merchant(self, data: MerchantSyncIn, ctx) -> MerchantSyncOut:
â”‚               """Sync merchant from OAuth flow"""
â”‚
â”‚               self.logger.info(
â”‚                   f"Syncing merchant: {data.shop_domain}",
â”‚                   extra={
â”‚                       "correlation_id": ctx.correlation_id,
â”‚                       "shop_domain": data.shop_domain,
â”‚                       "platform_shop_id": data.platform_shop_id,
â”‚                   },
â”‚               )
â”‚
â”‚               # Find existing merchant
â”‚               existing = await self.repository.find_by_platform_shop_identity(
â”‚                   platform_name=data.platform_name, shop_domain=data.shop_domain, platform_shop_id=data.platform_shop_id
â”‚               )
â”‚
â”‚               if existing:
â”‚                   # Update existing merchant
â”‚                   merchant = await self.repository.update_for_sync(existing.id, data)
â”‚                   created = False
â”‚
â”‚                   # If merchant was uninstalled, set back to PENDING
â”‚                   if merchant.status == MerchantStatus.UNINSTALLED:
â”‚                       merchant = await self.repository.update_status(merchant.id, MerchantStatus.PENDING)
â”‚
â”‚                       # Publish reinstalled event
â”‚                       await self.publisher.publish_merchant_reinstalled(
â”‚                           correlation_id=ctx.correlation_id,
â”‚                           merchant_id=merchant.id,
â”‚                           platform_shop_id=merchant.platform_shop_id,
â”‚                           shop_domain=merchant.shop_domain,
â”‚                           name=merchant.name,
â”‚                           email=merchant.email,
â”‚                       )
â”‚               else:
â”‚                   # Create new merchant
â”‚                   merchant = await self.repository.create(data)
â”‚                   created = True
â”‚
â”‚                   self.logger.info(
â”‚                       f"Created new merchant: {merchant.shop_domain}",
â”‚                       extra={"merchant_id": merchant.id, "shop_domain": merchant.shop_domain},
â”‚                   )
â”‚
â”‚                   # Publish installed event
â”‚                   await self.publisher.publish_merchant_created(
â”‚                       correlation_id=ctx.correlation_id,
â”‚                       merchant_id=merchant.id,
â”‚                       platform_name=merchant.platform_name,
â”‚                       platform_shop_id=merchant.platform_shop_id,
â”‚                       shop_domain=merchant.shop_domain,
â”‚                       name=merchant.name,
â”‚                       email=merchant.email,
â”‚                       installed_at=merchant.installed_at,
â”‚                   )
â”‚
â”‚               # Always publish synced event
â”‚               synced_payload = MerchantSyncedPayload(
â”‚                   merchant_id=merchant.id,
â”‚                   platform_name=merchant.platform_name,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   contact_email=merchant.email,
â”‚                   name=merchant.name,
â”‚                   status=merchant.status,
â”‚               )
â”‚
â”‚               await self.publisher.publish_merchant_synced(correlation_id=ctx.correlation_id, payload=synced_payload)
â”‚
â”‚               return MerchantSyncOut(created=created, merchant_id=merchant.id)
â”‚
â”‚           async def get_merchant_by_domain(self, shop_domain: str) -> MerchantSelfOut:
â”‚               """Get merchant by platform domain"""
â”‚               merchant = await self.repository.find_by_shop_domain(shop_domain)
â”‚               if not merchant:
â”‚                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
â”‚
â”‚               return MerchantSelfOut(
â”‚                   id=merchant.id,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   shop_name=merchant.name,
â”‚                   status=merchant.status,
â”‚               )
â”‚
â”‚           async def update_merchant_status(self, shop_domain: str, new_status: MerchantStatus) -> None:
â”‚               """Update merchant status (called by event listeners)"""
â”‚
â”‚               merchant = await self.repository.find_by_shop_domain(shop_domain)
â”‚               if not merchant:
â”‚                   raise MerchantNotFoundError(f"Merchant not found: {shop_domain}")
â”‚
â”‚               old_status = merchant.status
â”‚
â”‚               # Validate transition
â”‚               if new_status not in STATUS_TRANSITIONS.get(old_status, []):
â”‚                   self.logger.warning(
â”‚                       f"Invalid status transition from {old_status} to {new_status}",
â”‚                       extra={"merchant_id": merchant.id, "shop_domain": shop_domain},
â”‚                   )
â”‚                   raise InvalidStatusTransitionError(f"Invalid status transition from {old_status} to {new_status}")
â”‚
â”‚               # Update status
â”‚               await self.repository.update_status(merchant.id, new_status)
â”‚
â”‚               # Publish status changed event
â”‚               status_payload = MerchantStatusUpdatedPayload(
â”‚                   merchant_id=merchant.id,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   status=new_status,
â”‚               )
â”‚
â”‚               await self.publisher.publish_status_changed(
â”‚                   correlation_id=merchant.correlation_id,  # TODO: set a propper ctx Assuming this is available in the context
â”‚                   old_status=old_status,
â”‚                   payload=status_payload,
â”‚               )
â”‚
â”‚           async def handle_app_uninstalled(self, shop_domain: str, uninstall_reason: str | None = None) -> None:
â”‚               """Handle app uninstalled event"""
â”‚               self.logger.info(f"Handling app uninstall for {shop_domain}", extra={"shop_domain": shop_domain})
â”‚
â”‚               merchant = await self.repository.find_by_shop_domain(shop_domain)
â”‚               if not merchant:
â”‚                   self.logger.warning(f"Merchant not found for uninstall: {shop_domain}")
â”‚                   return
â”‚
â”‚               # Update status to UNINSTALLED
â”‚               await self.repository.update_status(merchant.id, MerchantStatus.UNINSTALLED)
â”‚
â”‚               # Publish uninstalled event
â”‚               await self.publisher.publish_merchant_uninstalled(
â”‚                   correlation_id=merchant.correlation_id,  # TODO: set a propper ctx Assuming this is available in the context
â”‚                   merchant_id=merchant.id,
â”‚                   platform_shop_id=merchant.platform_shop_id,
â”‚                   shop_domain=merchant.shop_domain,
â”‚                   name=merchant.name,
â”‚                   email=merchant.email,
â”‚                   uninstall_reason=uninstall_reason,
â”‚               )
â”‚       ```
â”‚
â”œâ”€â”€ __init__.py
â”œâ”€â”€ config.py
â”‚
â”‚   ```py
â”‚   import os
â”‚   from functools import lru_cache
â”‚
â”‚   from pydantic import BaseModel, ConfigDict, Field, model_validator
â”‚
â”‚   from shared.utils import load_root_env
â”‚   from shared.utils.exceptions import ConfigurationError
â”‚
â”‚
â”‚   class ServiceConfig(BaseModel):
â”‚       """Merchant service configuration"""
â”‚
â”‚       model_config = ConfigDict(
â”‚           extra="ignore",
â”‚           populate_by_name=True,
â”‚       )
â”‚
â”‚       service_name: str = "merchant-service"
â”‚       service_version: str = "1.0.0"
â”‚       service_description: str = "Merchant management service"
â”‚       debug: bool = True
â”‚
â”‚       environment: str = Field(..., alias="APP_ENV")
â”‚       api_host: str = "0.0.0.0"
â”‚       api_external_port: int = Field(..., alias="MERCHANT_API_EXTERNAL_PORT")
â”‚
â”‚       database_enabled: bool = Field(..., alias="MERCHANT_DB_ENABLED")
â”‚       database_url: str = Field(..., alias="DATABASE_URL")
â”‚
â”‚       logging_level: str = "INFO"
â”‚       logging_format: str = "json"
â”‚       logging_file_path: str = ""
â”‚
â”‚       client_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
â”‚
â”‚       @property
â”‚       def nats_url(self) -> str:
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           return (
â”‚               "nats://nats:4222"
â”‚               if in_container or self.environment in ["development", "production"]
â”‚               else "nats://localhost:4222"
â”‚           )
â”‚
â”‚       @property
â”‚       def redis_url(self) -> str:
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           return (
â”‚               "redis://redis:6379"
â”‚               if in_container or self.environment in ["development", "production"]
â”‚               else "redis://localhost:6379"
â”‚           )
â”‚
â”‚       @property
â”‚       def api_port(self) -> int:
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           return 8000 if in_container else self.api_external_port
â”‚
â”‚       @model_validator(mode="after")
â”‚       def _require_db_url_when_enabled(self):
â”‚           if self.database_enabled and not self.database_url:
â”‚               raise ValueError("database_enabled=true requires DATABASE_URL")
â”‚           return self
â”‚
â”‚
â”‚   @lru_cache
â”‚   def get_service_config() -> ServiceConfig:
â”‚       try:
â”‚           load_root_env()
â”‚           return ServiceConfig(**os.environ)  # type: ignore[arg-type]
â”‚       except Exception as e:
â”‚           raise ConfigurationError(
â”‚               f"Failed to load service configuration: {e}",
â”‚               config_key="merchant-service",
â”‚               expected_value="valid config",
â”‚           ) from e
â”‚   ```
â”‚
â”œâ”€â”€ dependencies.py
â”‚
â”‚   ```py
â”‚   from typing import Annotated
â”‚
â”‚   from fastapi import Depends, HTTPException, Request, status
â”‚
â”‚   from shared.api.dependencies import CorrelationIdDep, PaginationDep, RequestContextDep, RequestIdDep
â”‚
â”‚   from .config import ServiceConfig
â”‚   from .lifecycle import ServiceLifecycle
â”‚   from .services import MerchantService
â”‚
â”‚   __all__ = [
â”‚       "ConfigDep",
â”‚       "CorrelationIdDep",
â”‚       "LifecycleDep",
â”‚       "MerchantServiceDep",
â”‚       "PaginationDep",
â”‚       "RequestContextDep",
â”‚       "RequestIdDep",
â”‚   ]
â”‚
â”‚
â”‚   # Core dependencies
â”‚   def get_lifecycle(request: Request) -> ServiceLifecycle:
â”‚       lc = getattr(request.app.state, "lifecycle", None)
â”‚       if lc is None:
â”‚           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Lifecycle not initialized")
â”‚       return lc
â”‚
â”‚
â”‚   def get_config(request: Request) -> ServiceConfig:
â”‚       cfg = getattr(request.app.state, "config", None)
â”‚       if cfg is None:
â”‚           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Config not initialized")
â”‚       return cfg
â”‚
â”‚
â”‚   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
â”‚   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
â”‚
â”‚
â”‚   def get_merchant_service(lifecycle: LifecycleDep) -> MerchantService:
â”‚       svc = lifecycle.merchant_service
â”‚       if svc is None:
â”‚           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "MerchantService not initialized")
â”‚       return svc
â”‚
â”‚
â”‚   MerchantServiceDep = Annotated[MerchantService, Depends(get_merchant_service)]
â”‚   ```
â”‚
â”œâ”€â”€ exceptions.py
â”‚
â”‚   ```py
â”‚   from shared.utils.exceptions import ConflictError, DomainError, NotFoundError, ValidationError
â”‚
â”‚
â”‚   class MerchantNotFoundError(NotFoundError):
â”‚       """Raised when merchant is not found"""
â”‚
â”‚       def __init__(self, message: str = "Merchant not found"):
â”‚           super().__init__(message=message, resource="merchant")
â”‚
â”‚
â”‚   class InvalidDomainError(ValidationError):
â”‚       """Raised when shop domain is invalid"""
â”‚
â”‚       def __init__(self, message: str = "Invalid shop domain format"):
â”‚           super().__init__(message=message, field="shop_domain")
â”‚
â”‚
â”‚   class ConsentViolationError(ConflictError):
â”‚       """Raised when trying to violate consent rules"""
â”‚
â”‚       def __init__(self, message: str = "Cannot unset required consent"):
â”‚           super().__init__(message=message, conflicting_resource="consent")
â”‚
â”‚
â”‚   class InvalidStatusTransitionError(DomainError):
â”‚       """Raised when status transition is invalid"""
â”‚
â”‚       def __init__(self, message: str):
â”‚           super().__init__(message=message, code="INVALID_STATUS_TRANSITION")
â”‚   ```
â”‚
â”œâ”€â”€ lifecycle.py
â”‚
â”‚   ```py
â”‚   # services/merchant-service/src/lifecycle.py
â”‚   import asyncio
â”‚
â”‚   from prisma import Prisma  # type: ignore[attr-defined]
â”‚
â”‚   from shared.messaging.jetstream_client import JetStreamClient
â”‚   from shared.utils.logger import ServiceLogger
â”‚
â”‚   from .config import ServiceConfig
â”‚   from .events.publishers import MerchantEventPublisher
â”‚   from .repositories import MerchantRepository
â”‚   from .services.merchant_service import MerchantService
â”‚
â”‚
â”‚   class ServiceLifecycle:
â”‚       """Manages service lifecycle and dependencies"""
â”‚
â”‚       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
â”‚           self.config = config
â”‚           self.logger = logger
â”‚
â”‚           # External connections
â”‚           self.messaging_client: JetStreamClient | None = None
â”‚           self.prisma: Prisma | None = None
â”‚           self._db_connected: bool = False
â”‚
â”‚           # Publisher / listeners
â”‚           self.event_publisher: MerchantEventPublisher | None = None
â”‚           self._listeners: list = []
â”‚
â”‚           # Repositories / mappers / services
â”‚           self.merchant_repo: MerchantRepository | None = None
â”‚           self.merchant_service: MerchantService | None = None
â”‚
â”‚           # Tasks
â”‚           self._tasks: list[asyncio.Task] = []
â”‚           self._shutdown_event = asyncio.Event()
â”‚
â”‚       async def startup(self) -> None:
â”‚           try:
â”‚               self.logger.info("Starting service components...")
â”‚               await self._init_messaging()
â”‚               await self._init_database()
â”‚               self._init_repositories()
â”‚               self._init_local_services()
â”‚               await self._init_listeners()
â”‚               self.logger.info("%s started successfully", self.config.service_name)
â”‚           except Exception:
â”‚               self.logger.critical("Service failed to start", exc_info=True)
â”‚               await self.shutdown()
â”‚               raise
â”‚
â”‚       async def shutdown(self) -> None:
â”‚           """Graceful shutdown of all components"""
â”‚           self.logger.info("Shutting down %s", self.config.service_name)
â”‚
â”‚           for t in self._tasks:
â”‚               t.cancel()
â”‚           if self._tasks:
â”‚               await asyncio.gather(*self._tasks, return_exceptions=True)
â”‚
â”‚           for lst in self._listeners:
â”‚               try:
â”‚                   await lst.stop()
â”‚               except Exception:
â”‚                   self.logger.critical("Listener stop failed")
â”‚
â”‚           if self.messaging_client:
â”‚               try:
â”‚                   await self.messaging_client.close()
â”‚               except Exception:
â”‚                   self.logger.critical("Messaging client close failed")
â”‚
â”‚           if self.prisma and self._db_connected:
â”‚               try:
â”‚                   await self.prisma.disconnect()
â”‚               except Exception:
â”‚                   self.logger.critical("Prisma disconnect failed")
â”‚
â”‚           self.logger.info("%s shutdown complete", self.config.service_name)
â”‚
â”‚       async def _init_messaging(self) -> None:
â”‚           self.messaging_client = JetStreamClient(self.logger)
â”‚           await self.messaging_client.connect([self.config.nats_url])
â”‚           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.>", "cmd.>"])
â”‚
â”‚           # Initialize publisher now (you require it in _init_listeners)
â”‚           self.event_publisher = MerchantEventPublisher(jetstream_client=self.messaging_client, logger=self.logger)
â”‚           self.logger.info("Messaging client and publisher initialized")
â”‚
â”‚       async def _init_database(self) -> None:
â”‚           """Initialize Prisma client if database is enabled."""
â”‚           if not self.config.database_enabled:
â”‚               self.logger.info("Database disabled; skipping Prisma initialization")
â”‚               return
â”‚
â”‚           # Prisma reads DATABASE_URL from the environment; no args needed
â”‚           self.prisma = Prisma()
â”‚
â”‚           if not self.prisma:
â”‚               raise RuntimeError("Prisma client not initialized")
â”‚
â”‚           try:
â”‚               await self.prisma.connect()
â”‚               self._db_connected = True
â”‚               self.logger.info("Prisma connected")
â”‚           except Exception as e:
â”‚               # Be explicit; this usually means DATABASE_URL is missing/invalid or client not generated
â”‚               self.logger.error("Prisma connect failed: %s", e, exc_info=True)
â”‚               raise
â”‚
â”‚       def _init_repositories(self) -> None:
â”‚           if self.config.database_enabled:
â”‚               if not (self.prisma and self._db_connected):
â”‚                   raise RuntimeError("Prisma client not initialized/connected")
â”‚               self.merchant_repo = MerchantRepository(self.prisma)
â”‚               self.logger.info("Merchant repository initialized")
â”‚           else:
â”‚               self.merchant_repo = None  # service must handle db-disabled mode
â”‚
â”‚       def _init_local_services(self) -> None:
â”‚           if not self.merchant_repo or not self.event_publisher:
â”‚               raise RuntimeError("Merchant repository not initialized")
â”‚
â”‚           self.merchant_service = MerchantService(
â”‚               repository=self.merchant_repo, publisher=self.event_publisher, logger=self.logger
â”‚           )
â”‚
â”‚       async def _init_listeners(self) -> None:
â”‚           if not self.messaging_client or not self.merchant_service or not self.event_publisher:
â”‚               raise RuntimeError("Messaging or service layer not ready")
â”‚
â”‚           # Initialize and start subscribers here when you add them
â”‚           # await some_listener.start()
â”‚           # self._listeners.append(some_listener)
â”‚
â”‚       # convenience helpers
â”‚       def add_task(self, coro) -> asyncio.Task:
â”‚           t = asyncio.create_task(coro)
â”‚           self._tasks.append(t)
â”‚           return t
â”‚
â”‚       async def wait_for_shutdown(self) -> None:
â”‚           await self._shutdown_event.wait()
â”‚
â”‚       def signal_shutdown(self) -> None:
â”‚           self._shutdown_event.set()
â”‚   ```
â”‚
â””â”€â”€ main.py

    ```py
    from contextlib import asynccontextmanager

    from fastapi import FastAPI

    from shared.api import setup_debug_handlers, setup_debug_middleware, setup_middleware
    from shared.api.health import create_health_router
    from shared.utils.logger import create_logger

    from .api import api_router
    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    # Global singletons
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)


    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """FastAPI lifespan adapter"""
        logger.info(
            f"Starting {config.service_name}",
            extra={
                "service_name": config.service_name,
                "version": config.service_version,
                "environment": config.environment,
                "api_host": config.api_host,
                "api_port": config.api_port,
            },
        )

        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()


    def create_application() -> FastAPI:
        """Create and configure the FastAPI application."""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            lifespan=lifespan,
            description=config.service_description,
            docs_url="/docs",
            redoc_url="/redoc",
            exception_handlers={},  # Use shared middleware for exception handling
        )

        if config.debug:
            logger.info("ğŸš¨ Debug mode enabled - adding debug handlers")
            setup_debug_handlers(app)
            setup_debug_middleware(app)

        setup_middleware(app, service_name=config.service_name)

        # Include routers
        app.include_router(create_health_router(config.service_name))
        app.include_router(api_router)

        return app


    app = create_application()

    if __name__ == "__main__":
        import uvicorn

        uvicorn.run("src.main:app", host=config.api_host, port=config.api_port, reload=config.debug, workers=1)
    ```

tests/
â””â”€â”€ __init__.py
.python-version
Dockerfile

```
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“¦  Stage 1 â”€ Builder
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FROM python:3.11-slim AS builder

# Allow re-use for any service; default keeps backward compatibility
ARG SERVICE=merchant-service

# Bump this to force layer invalidation (or pass via compose)
ARG CACHE_BUSTER=1

ENV PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Minimal build deps (gcc often required for some wheels)
RUN apt-get update \
 && apt-get install -y --no-install-recommends gcc \
 && rm -rf /var/lib/apt/lists/*

# Install Poetry (system-wide, no venvs)
ARG POETRY_VERSION=1.8.3
RUN pip install --no-cache-dir "poetry==${POETRY_VERSION}" \
 && poetry config virtualenvs.create false

# ---- 0ï¸âƒ£  Cache bust marker (forces rebuild when you change the arg)
RUN echo "Cache bust value: ${CACHE_BUSTER}"

# ---- 1ï¸âƒ£  Install shared package deps
COPY shared /shared
WORKDIR /shared
RUN poetry install --no-dev --no-interaction --no-ansi

# ---- 2ï¸âƒ£  Install service deps (copy only manifests first for better caching)
WORKDIR /app
# Copy service manifests (pyproject & optional lock)
COPY services/${SERVICE}/pyproject.toml services/${SERVICE}/poetry.lock* ./
RUN poetry install --no-dev --no-interaction --no-ansi

# ---- 3ï¸âƒ£  Copy Prisma schema and generate client
# (prisma is provided by prisma-client-py; generation happens here)
COPY services/${SERVICE}/prisma ./prisma
RUN prisma generate

# ---- 4ï¸âƒ£  Copy service source
# (copy last to maximize cache hits on deps & generated client)
COPY services/${SERVICE} /app

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸš€  Stage 2 â”€ Runtime
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FROM python:3.11-slim

ARG SERVICE=merchant-service

ENV PYTHONPATH="/shared:/app" \
    DOCKER_CONTAINER=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Copy installed libs, built app, and shared code from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app /app
COPY --from=builder /shared /shared

# Non-root user
RUN useradd -m -u 1000 appuser \
 && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run migrations then start API
# (prisma CLI is available because poetry installed into system site-packages)
CMD ["sh", "-c", "prisma migrate deploy && uvicorn src.main:app --host 0.0.0.0 --port 8000"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
# services/merchant-service/pyproject.toml
[tool.poetry]
name = "merchant-service"
version = "1.0.0"
description = "Merchant identity management"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
prisma = "^0.15.0"
nats-py = "^2.6.0"
shared = { path = "../../shared", develop = true }

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
ruff = "^0.1.9"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```


================================================================================
Output includes file contents
================================================================================
