================================================================================
Directory Structure: /home/bellabe/glam-app/shared
================================================================================

shared/
shared/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   # shared/api/__init__.py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   Unified API response models and utilities for glam-app microservices.
â”‚   â”‚   
â”‚   â”‚   This module provides a single, consistent approach to API responses
â”‚   â”‚   across all services.
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   from .models import (
â”‚   â”‚       # Core models
â”‚   â”‚       ApiResponse,
â”‚   â”‚       Meta,
â”‚   â”‚       Pagination,
â”‚   â”‚       Links,
â”‚   â”‚       ErrorDetail,
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .responses import (
â”‚   â”‚       # Response helpers
â”‚   â”‚       create_response,
â”‚   â”‚       success_response,
â”‚   â”‚       error_response,
â”‚   â”‚       paginated_response,
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .dependencies import (
â”‚   â”‚       # FastAPI dependencies
â”‚   â”‚       PaginationDep,
â”‚   â”‚       RequestContextDep, 
â”‚   â”‚       WebhookHeadersDep,
â”‚   â”‚       LoggerDep,
â”‚   â”‚       ClientIpDep,
â”‚   â”‚       RequestIdDep,
â”‚   â”‚       ContentTypeDep,
â”‚   â”‚       CorrelationIdDep,
â”‚   â”‚       RequestContextDep,
â”‚   â”‚       PlatformContextDep,
â”‚   â”‚       ShopDomainDep,
â”‚   â”‚       ShopPlatformDep,
â”‚   â”‚       ClientAuthContext,
â”‚   â”‚       InternalAuthDep,
â”‚   â”‚       WebhookHeadersDep  
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .middleware import (
â”‚   â”‚       # Middleware
â”‚   â”‚       APIMiddleware,
â”‚   â”‚       setup_middleware,
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .correlation import (
â”‚   â”‚       # Correlation utilities
â”‚   â”‚       get_correlation_id,
â”‚   â”‚       set_correlation_context,
â”‚   â”‚       get_correlation_context,
â”‚   â”‚       add_correlation_header,
â”‚   â”‚       add_correlation_to_event,
â”‚   â”‚       extract_correlation_from_event, 
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .debug import (
â”‚   â”‚       # Debugging utilities
â”‚   â”‚       setup_debug_middleware,
â”‚   â”‚       setup_debug_handlers,
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .health import (
â”‚   â”‚       # Health check utilities
â”‚   â”‚       create_health_router,
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   from .validation import (
â”‚   â”‚       # Validation utilities
â”‚   â”‚       validate_shop_context
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   __all__ = [
â”‚   â”‚       # Models
â”‚   â”‚       "ApiResponse",
â”‚   â”‚       "Meta",
â”‚   â”‚       "Pagination",
â”‚   â”‚       "Links",
â”‚   â”‚       "ErrorDetail",
â”‚   â”‚       
â”‚   â”‚       # Response helpers
â”‚   â”‚       "create_response",
â”‚   â”‚       "success_response",
â”‚   â”‚       "error_response",
â”‚   â”‚       "paginated_response",
â”‚   â”‚       
â”‚   â”‚       # Dependencies
â”‚   â”‚       "PaginationDep",
â”‚   â”‚       "RequestContextDep",
â”‚   â”‚       "LoggerDep",
â”‚   â”‚       "ClientIpDep",
â”‚   â”‚       "RequestIdDep",
â”‚   â”‚       "ContentTypeDep",
â”‚   â”‚       "CorrelationIdDep",
â”‚   â”‚       "RequestContextDep",
â”‚   â”‚       "PlatformContextDep",
â”‚   â”‚       "ShopDomainDep",
â”‚   â”‚       "ShopPlatformDep",
â”‚   â”‚       "ClientAuthContext",
â”‚   â”‚       "InternalAuthDep",
â”‚   â”‚       "WebhookHeadersDep",
â”‚   â”‚       
â”‚   â”‚       # Debugging
â”‚   â”‚       "setup_debug_middleware",
â”‚   â”‚       "setup_debug_handlers", 
â”‚   â”‚       
â”‚   â”‚       # Correlation
â”‚   â”‚       "get_correlation_id",
â”‚   â”‚       "set_correlation_context",
â”‚   â”‚       "get_correlation_context",
â”‚   â”‚       "add_correlation_header",
â”‚   â”‚       "add_correlation_to_event",
â”‚   â”‚       "extract_correlation_from_event",
â”‚   â”‚       
â”‚   â”‚       # Middleware
â”‚   â”‚       "APIMiddleware",
â”‚   â”‚       "setup_middleware",
â”‚   â”‚       
â”‚   â”‚       # Health checks
â”‚   â”‚       "create_health_router",
â”‚   â”‚       
â”‚   â”‚       # Validation
â”‚   â”‚       "validate_shop_context"
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ correlation.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # File: shared/api/correlation.py
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   Simplified correlation ID support for distributed tracing.
â”‚   â”‚   
â”‚   â”‚   Focuses on the essential functionality needed for request tracing
â”‚   â”‚   across services without over-engineering.
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   from typing import Optional, Annotated
â”‚   â”‚   from contextvars import ContextVar
â”‚   â”‚   from fastapi import Request, Depends
â”‚   â”‚   import uuid
â”‚   â”‚   
â”‚   â”‚   # Context variable for async operations
â”‚   â”‚   _correlation_context: ContextVar[Optional[str]] = ContextVar(
â”‚   â”‚       "correlation_id", default=None
â”‚   â”‚   )
â”‚   â”‚   
â”‚   â”‚   def get_correlation_id(request: Request) -> str:
â”‚   â”‚       """
â”‚   â”‚       Get or generate correlation ID for the current request.
â”‚   â”‚   
â”‚   â”‚       Priority:
â”‚   â”‚       1. Request state (set by middleware)
â”‚   â”‚       2. X-Correlation-ID header (from upstream service)
â”‚   â”‚       3. Generate new one (originating request)
â”‚   â”‚       """
â”‚   â”‚       # Check request state first
â”‚   â”‚       if hasattr(request.state, "correlation_id"):
â”‚   â”‚           return request.state.correlation_id
â”‚   â”‚   
â”‚   â”‚       # Check headers from upstream service
â”‚   â”‚       correlation_id = request.headers.get("X-Correlation-ID")
â”‚   â”‚       if correlation_id:
â”‚   â”‚           return correlation_id
â”‚   â”‚   
â”‚   â”‚       # Generate new one
â”‚   â”‚       return f"corr_{uuid.uuid4().hex[:12]}"
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # FastAPI dependency
â”‚   â”‚   CorrelationIdDep = Annotated[str, Depends(get_correlation_id)]
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def set_correlation_context(correlation_id: str) -> None:
â”‚   â”‚       """Set correlation ID in async context."""
â”‚   â”‚       _correlation_context.set(correlation_id)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def get_correlation_context() -> Optional[str]:
â”‚   â”‚       """Get correlation ID from async context."""
â”‚   â”‚       return _correlation_context.get()
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # Essential integrations only
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def add_correlation_header(headers: dict) -> dict:
â”‚   â”‚       """
â”‚   â”‚       Add correlation ID to outgoing HTTP headers.
â”‚   â”‚   
â”‚   â”‚       Usage:
â”‚   â”‚           headers = add_correlation_header({"Content-Type": "application/json"})
â”‚   â”‚           response = await client.get(url, headers=headers)
â”‚   â”‚       """
â”‚   â”‚       correlation_id = get_correlation_context()
â”‚   â”‚       if correlation_id:
â”‚   â”‚           headers["X-Correlation-ID"] = correlation_id
â”‚   â”‚       return headers
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def add_correlation_to_event(event_data: dict) -> dict:
â”‚   â”‚       """
â”‚   â”‚       Add correlation ID to message bus events.
â”‚   â”‚   
â”‚   â”‚       Usage:
â”‚   â”‚           event_data = {"subject": "ORDER_CREATED", "data": {...}}
â”‚   â”‚           event_with_correlation = add_correlation_to_event(event_data)
â”‚   â”‚       """
â”‚   â”‚       correlation_id = get_correlation_context()
â”‚   â”‚       if correlation_id:
â”‚   â”‚           if "metadata" not in event_data:
â”‚   â”‚               event_data["metadata"] = {}
â”‚   â”‚           event_data["metadata"]["correlation_id"] = correlation_id
â”‚   â”‚       return event_data
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def extract_correlation_from_event(event_data: dict) -> Optional[str]:
â”‚   â”‚       """Extract correlation ID from event data."""
â”‚   â”‚       return event_data.get("metadata", {}).get("correlation_id")
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ debug.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/api/debug.py
â”‚   â”‚   """Debug utilities for FastAPI applications."""
â”‚   â”‚   
â”‚   â”‚   import logging
â”‚   â”‚   import json
â”‚   â”‚   from typing import Callable
â”‚   â”‚   from fastapi import FastAPI, Request, HTTPException
â”‚   â”‚   from fastapi.exceptions import RequestValidationError
â”‚   â”‚   from fastapi.responses import JSONResponse
â”‚   â”‚   from starlette.middleware.base import BaseHTTPMiddleware
â”‚   â”‚   
â”‚   â”‚   logger = logging.getLogger(__name__)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class EarlyDebugMiddleware(BaseHTTPMiddleware):
â”‚   â”‚       """Debug middleware that runs before any dependencies or validation."""
â”‚   â”‚       
â”‚   â”‚       async def dispatch(self, request: Request, call_next: Callable):
â”‚   â”‚           print("\n" + "="*60)
â”‚   â”‚           print("ðŸ” EARLY DEBUG - REQUEST RECEIVED")
â”‚   â”‚           print("="*60)
â”‚   â”‚           
â”‚   â”‚           # Log all request details
â”‚   â”‚           print(f"ðŸŒ URL: {request.url}")
â”‚   â”‚           print(f"ðŸ“ Path: {request.url.path}")
â”‚   â”‚           print(f"ðŸ”§ Method: {request.method}")
â”‚   â”‚           print(f"â“ Query Params: {dict(request.query_params)}")
â”‚   â”‚           
â”‚   â”‚           # Log all headers
â”‚   â”‚           print("ðŸ“‹ Headers:")
â”‚   â”‚           for name, value in request.headers.items():
â”‚   â”‚               # Mask authorization for security
â”‚   â”‚               if name.lower() == "authorization":
â”‚   â”‚                   value = f"Bearer {value[7:17]}..." if value.startswith("Bearer ") else "***"
â”‚   â”‚               print(f"   {name}: {value}")
â”‚   â”‚           
â”‚   â”‚           # Log body for POST/PUT/PATCH WITHOUT consuming it
â”‚   â”‚           body_logged = False
â”‚   â”‚           if request.method in ["POST", "PUT", "PATCH"]:
â”‚   â”‚               try:
â”‚   â”‚                   # Read body once and store it
â”‚   â”‚                   body = await request.body()
â”‚   â”‚                   if body:
â”‚   â”‚                       try:
â”‚   â”‚                           body_json = json.loads(body)
â”‚   â”‚                           print(f"ðŸ“¦ Body (JSON):")
â”‚   â”‚                           print(json.dumps(body_json, indent=2))
â”‚   â”‚                           body_logged = True
â”‚   â”‚                       except json.JSONDecodeError:
â”‚   â”‚                           body_str = body.decode('utf-8', errors='ignore')
â”‚   â”‚                           print(f"ðŸ“¦ Body (Raw): {body_str[:200]}{'...' if len(body_str) > 200 else ''}")
â”‚   â”‚                           body_logged = True
â”‚   â”‚                   else:
â”‚   â”‚                       print("ðŸ“¦ Body: (empty)")
â”‚   â”‚                       body_logged = True
â”‚   â”‚                       
â”‚   â”‚               except Exception as e:
â”‚   â”‚                   print(f"ðŸ“¦ Body: (error reading: {e})")
â”‚   â”‚           
â”‚   â”‚           if not body_logged:
â”‚   â”‚               print("ðŸ“¦ Body: (no body for GET request)")
â”‚   â”‚           
â”‚   â”‚           print("â³ Calling next middleware/handler...")
â”‚   â”‚           print("="*60)
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               response = await call_next(request)
â”‚   â”‚               
â”‚   â”‚               print("\n" + "="*60)
â”‚   â”‚               print("âœ… EARLY DEBUG - RESPONSE READY")
â”‚   â”‚               print("="*60)
â”‚   â”‚               print(f"ðŸ“¤ Status: {response.status_code}")
â”‚   â”‚               print(f"ðŸ“¤ Headers: {dict(response.headers)}")
â”‚   â”‚               print("="*60 + "\n")
â”‚   â”‚               
â”‚   â”‚               return response
â”‚   â”‚               
â”‚   â”‚           except Exception as e:
â”‚   â”‚               print("\n" + "="*60)
â”‚   â”‚               print("âŒ EARLY DEBUG - EXCEPTION CAUGHT")
â”‚   â”‚               print("="*60)
â”‚   â”‚               print(f"ðŸ’¥ Exception Type: {type(e).__name__}")
â”‚   â”‚               print(f"ðŸ’¥ Exception Message: {str(e)}")
â”‚   â”‚               print(f"ðŸ’¥ Exception Details: {getattr(e, 'detail', 'No details')}")
â”‚   â”‚               if hasattr(e, 'status_code'):
â”‚   â”‚                   print(f"ðŸ’¥ Status Code: {e.status_code}")
â”‚   â”‚               print("="*60 + "\n")
â”‚   â”‚               raise  # Re-raise to let other handlers deal with it
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def setup_debug_middleware(app: FastAPI):
â”‚   â”‚       """Add debug middleware as the first middleware."""
â”‚   â”‚       app.add_middleware(EarlyDebugMiddleware)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def setup_debug_handlers(app: FastAPI):
â”‚   â”‚       """Add debug exception handlers to catch errors before middleware."""
â”‚   â”‚       
â”‚   â”‚       @app.exception_handler(RequestValidationError)
â”‚   â”‚       async def validation_exception_handler(request: Request, exc: RequestValidationError):
â”‚   â”‚           """Debug validation errors in detail."""
â”‚   â”‚           
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           print("ðŸš¨ VALIDATION ERROR CAUGHT!")
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           
â”‚   â”‚           # Log request details
â”‚   â”‚           print(f"ðŸ“¥ Request URL: {request.url}")
â”‚   â”‚           print(f"ðŸ“¥ Request Method: {request.method}")
â”‚   â”‚           print(f"ðŸ“¥ Request Headers:")
â”‚   â”‚           for name, value in request.headers.items():
â”‚   â”‚               print(f"   {name}: {value}")
â”‚   â”‚           
â”‚   â”‚           # Log request body if available
â”‚   â”‚           try:
â”‚   â”‚               if request.method in ["POST", "PUT", "PATCH"]:
â”‚   â”‚                   # Try to get body (might be consumed already)
â”‚   â”‚                   body = await request.body()
â”‚   â”‚                   if body:
â”‚   â”‚                       try:
â”‚   â”‚                           body_json = json.loads(body)
â”‚   â”‚                           print(f"ðŸ“¥ Request Body (JSON): {json.dumps(body_json, indent=2)}")
â”‚   â”‚                       except:
â”‚   â”‚                           print(f"ðŸ“¥ Request Body (Raw): {body.decode('utf-8', errors='ignore')[:500]}...")
â”‚   â”‚                   else:
â”‚   â”‚                       print("ðŸ“¥ Request Body: (empty)")
â”‚   â”‚           except Exception as e:
â”‚   â”‚               print(f"ðŸ“¥ Request Body: (error reading: {e})")
â”‚   â”‚           
â”‚   â”‚           # Log validation errors in detail
â”‚   â”‚           print(f"âŒ Validation Errors ({len(exc.errors())} total):")
â”‚   â”‚           for i, error in enumerate(exc.errors()):
â”‚   â”‚               print(f"   {i+1}. Field: {error.get('loc', 'unknown')}")
â”‚   â”‚               print(f"      Type: {error.get('type', 'unknown')}")
â”‚   â”‚               print(f"      Message: {error.get('msg', 'unknown')}")
â”‚   â”‚               print(f"      Input: {error.get('input', 'not provided')}")
â”‚   â”‚               print()
â”‚   â”‚           
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           
â”‚   â”‚           # Return structured error response
â”‚   â”‚           validation_errors = []
â”‚   â”‚           for error in exc.errors():
â”‚   â”‚               field_path = ".".join(str(loc) for loc in error["loc"])
â”‚   â”‚               validation_errors.append({
â”‚   â”‚                   "field": field_path,
â”‚   â”‚                   "message": error["msg"],
â”‚   â”‚                   "type": error["type"],
â”‚   â”‚                   "input": error.get("input")
â”‚   â”‚               })
â”‚   â”‚           
â”‚   â”‚           return JSONResponse(
â”‚   â”‚               status_code=422,
â”‚   â”‚               content={
â”‚   â”‚                   "error": {
â”‚   â”‚                       "code": "VALIDATION_ERROR",
â”‚   â”‚                       "message": "Request validation failed",
â”‚   â”‚                       "details": {
â”‚   â”‚                           "validation_errors": validation_errors,
â”‚   â”‚                           "total_errors": len(validation_errors)
â”‚   â”‚                       }
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       @app.exception_handler(HTTPException)
â”‚   â”‚       async def http_exception_handler(request: Request, exc: HTTPException):
â”‚   â”‚           """Debug HTTP exceptions."""
â”‚   â”‚           
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           print(f"ðŸš¨ HTTP EXCEPTION: {exc.status_code}")
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           print(f"ðŸ“¥ Request URL: {request.url}")
â”‚   â”‚           print(f"ðŸ“¥ Request Method: {request.method}")
â”‚   â”‚           print(f"âŒ Exception Detail: {exc.detail}")
â”‚   â”‚           print(f"âŒ Exception Type: {type(exc.detail)}")
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           
â”‚   â”‚           # Let your middleware handle this
â”‚   â”‚           raise exc
â”‚   â”‚       
â”‚   â”‚       @app.exception_handler(Exception)
â”‚   â”‚       async def general_exception_handler(request: Request, exc: Exception):
â”‚   â”‚           """Catch any other exceptions."""
â”‚   â”‚           
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           print(f"ðŸš¨ GENERAL EXCEPTION: {type(exc).__name__}")
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           print(f"ðŸ“¥ Request URL: {request.url}")
â”‚   â”‚           print(f"ðŸ“¥ Request Method: {request.method}")
â”‚   â”‚           print(f"âŒ Exception: {exc}")
â”‚   â”‚           print("=" * 50)
â”‚   â”‚           
â”‚   â”‚           # Let your middleware handle this
â”‚   â”‚           raise exc
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ dependencies.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   """
â”‚   â”‚   FastAPI dependencies for standardized API behavior.
â”‚   â”‚   Clean, generic, production-ready dependencies.
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   from typing import Annotated, Optional, TYPE_CHECKING
â”‚   â”‚   import jwt
â”‚   â”‚   import os
â”‚   â”‚   import re
â”‚   â”‚   from fastapi import Query, Request, Depends, HTTPException, status
â”‚   â”‚   from pydantic import BaseModel, Field
â”‚   â”‚   
â”‚   â”‚   from .correlation import get_correlation_id
â”‚   â”‚   
â”‚   â”‚   if TYPE_CHECKING:
â”‚   â”‚       from shared.utils.logger import ServiceLogger
â”‚   â”‚   
â”‚   â”‚   # =========================
â”‚   â”‚   # Pagination
â”‚   â”‚   # =========================
â”‚   â”‚   
â”‚   â”‚   class PaginationParams(BaseModel):
â”‚   â”‚       """Standard pagination parameters."""
â”‚   â”‚       page: int = Field(default=1, ge=1)
â”‚   â”‚       limit: int = Field(default=50, ge=1, le=1000)
â”‚   â”‚   
â”‚   â”‚       @property
â”‚   â”‚       def offset(self) -> int:
â”‚   â”‚           return (self.page - 1) * self.limit
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def get_pagination_params(
â”‚   â”‚       page: int = Query(1, ge=1, description="Page number"),
â”‚   â”‚       limit: int = Query(50, ge=1, le=1000, description="Items per page"),
â”‚   â”‚   ) -> PaginationParams:
â”‚   â”‚       return PaginationParams(page=page, limit=limit)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   PaginationDep = Annotated[PaginationParams, Depends(get_pagination_params)]
â”‚   â”‚   
â”‚   â”‚   # =========================
â”‚   â”‚   # Logger Dependency  
â”‚   â”‚   # =========================
â”‚   â”‚   
â”‚   â”‚   def get_logger(request: Request) -> "ServiceLogger":
â”‚   â”‚       """Get the service logger from app state."""
â”‚   â”‚       return request.app.state.logger
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   LoggerDep = Annotated["ServiceLogger", Depends(get_logger)]
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # =========================
â”‚   â”‚   # Request Context
â”‚   â”‚   # =========================
â”‚   â”‚   
â”‚   â”‚   def get_request_id(request: Request) -> str:
â”‚   â”‚       if not hasattr(request.state, "request_id"):
â”‚   â”‚           raise RuntimeError("Request ID not found. Ensure APIMiddleware is properly configured.")
â”‚   â”‚       return request.state.request_id
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def get_client_ip(request: Request) -> str:
â”‚   â”‚       forwarded_for = request.headers.get("X-Forwarded-For")
â”‚   â”‚       if forwarded_for:
â”‚   â”‚           return forwarded_for.split(",")[0].strip()
â”‚   â”‚       return request.client.host if request.client else "unknown"
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def get_content_type(request: Request) -> Optional[str]:
â”‚   â”‚       return request.headers.get("Content-Type")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class RequestContext(BaseModel):
â”‚   â”‚       """Essential request context for logging/auditing."""
â”‚   â”‚       request_id: str
â”‚   â”‚       correlation_id: str
â”‚   â”‚       method: str
â”‚   â”‚       path: str
â”‚   â”‚       content_type: Optional[str] = None
â”‚   â”‚       ip_client: Optional[str] = None
â”‚   â”‚   
â”‚   â”‚       @classmethod
â”‚   â”‚       def from_request(cls, request: Request) -> "RequestContext":
â”‚   â”‚           return cls(
â”‚   â”‚               request_id=get_request_id(request),
â”‚   â”‚               correlation_id=get_correlation_id(request),
â”‚   â”‚               method=request.method,
â”‚   â”‚               path=str(request.url.path),
â”‚   â”‚               ip_client=get_client_ip(request),
â”‚   â”‚               content_type=get_content_type(request),
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def get_request_context(request: Request) -> RequestContext:
â”‚   â”‚       return RequestContext.from_request(request)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # Type annotations
â”‚   â”‚   ClientIpDep = Annotated[str, Depends(get_client_ip)]
â”‚   â”‚   RequestIdDep = Annotated[str, Depends(get_request_id)]
â”‚   â”‚   ContentTypeDep = Annotated[Optional[str], Depends(get_content_type)]
â”‚   â”‚   CorrelationIdDep = Annotated[str, Depends(get_correlation_id)]
â”‚   â”‚   RequestContextDep = Annotated[RequestContext, Depends(get_request_context)]
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # =========================
â”‚   â”‚   # Platform & Domain Context
â”‚   â”‚   # =========================
â”‚   â”‚   
â”‚   â”‚   SUPPORTED_PLATFORMS = {
â”‚   â”‚       "shopify", 
â”‚   â”‚       "bigcommerce", 
â”‚   â”‚       "woocommerce", 
â”‚   â”‚       "magento", 
â”‚   â”‚       "squarespace",
â”‚   â”‚       "custom"
â”‚   â”‚   }
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class PlatformContext(BaseModel):
â”‚   â”‚       """Generic platform and domain information."""
â”‚   â”‚       platform: str
â”‚   â”‚       domain: str
â”‚   â”‚       
â”‚   â”‚       @property
â”‚   â”‚       def is_shopify(self) -> bool:
â”‚   â”‚           return self.platform == "shopify"
â”‚   â”‚       
â”‚   â”‚       @property
â”‚   â”‚       def is_custom_domain(self) -> bool:
â”‚   â”‚           """Check if domain appears to be a custom domain vs platform default."""
â”‚   â”‚           if self.platform == "shopify":
â”‚   â”‚               return not self.domain.endswith(".myshopify.com")
â”‚   â”‚           elif self.platform == "bigcommerce":
â”‚   â”‚               return not self.domain.endswith(".mybigcommerce.com")
â”‚   â”‚           return True
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def _validate_platform(platform: str) -> str:
â”‚   â”‚       """Validate and normalize platform name."""
â”‚   â”‚       platform_norm = platform.strip().lower()
â”‚   â”‚       
â”‚   â”‚       if platform_norm not in SUPPORTED_PLATFORMS:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail={
â”‚   â”‚                   "code": "UNSUPPORTED_PLATFORM",
â”‚   â”‚                   "message": f"Platform '{platform}' is not supported",
â”‚   â”‚                   "details": {
â”‚   â”‚                       "received": platform,
â”‚   â”‚                       "supported_platforms": sorted(SUPPORTED_PLATFORMS)
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       return platform_norm
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def _validate_domain(domain: str) -> str:
â”‚   â”‚       """Generic domain validation - works for any platform."""
â”‚   â”‚       domain_norm = domain.strip().lower()
â”‚   â”‚       
â”‚   â”‚       # Basic domain format validation
â”‚   â”‚       domain_pattern = r"^[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$"
â”‚   â”‚       
â”‚   â”‚       if not re.match(domain_pattern, domain_norm):
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail={
â”‚   â”‚                   "code": "INVALID_DOMAIN_FORMAT",
â”‚   â”‚                   "message": f"Invalid domain format: '{domain}'",
â”‚   â”‚                   "details": {
â”‚   â”‚                       "received": domain,
â”‚   â”‚                       "expected_format": "Valid domain name (e.g., shop.example.com, my-store.myshopify.com)"
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       if len(domain_norm) > 255:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail="Domain name too long (max 255 characters)"
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       return domain_norm
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def require_platform_context(request: Request) -> PlatformContext:
â”‚   â”‚       """
â”‚   â”‚       Extract and validate shop platform and domain from headers.
â”‚   â”‚       
â”‚   â”‚       Expected headers:
â”‚   â”‚       - X-Shop-Platform: The e-commerce platform (shopify, bigcommerce, etc.)
â”‚   â”‚       - X-Shop-Domain: The shop's domain (can be platform domain or custom)
â”‚   â”‚       """
â”‚   â”‚       
â”‚   â”‚       platform = request.headers.get("X-Shop-Platform")
â”‚   â”‚       if not platform:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail={
â”‚   â”‚                   "code": "MISSING_PLATFORM_HEADER",
â”‚   â”‚                   "message": "Missing required shop platform header",
â”‚   â”‚                   "details": {
â”‚   â”‚                       "expected_header": "X-Shop-Platform",
â”‚   â”‚                       "supported_platforms": sorted(SUPPORTED_PLATFORMS)
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       domain = request.headers.get("X-Shop-Domain")
â”‚   â”‚       if not domain:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail={
â”‚   â”‚                   "code": "MISSING_DOMAIN_HEADER", 
â”‚   â”‚                   "message": "Missing required shop domain header",
â”‚   â”‚                   "details": {
â”‚   â”‚                       "expected_header": "X-Shop-Domain"
â”‚   â”‚                   }
â”‚   â”‚               }
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       platform_norm = _validate_platform(platform)
â”‚   â”‚       domain_norm = _validate_domain(domain)
â”‚   â”‚       
â”‚   â”‚       return PlatformContext(platform=platform_norm, domain=domain_norm)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def require_shop_platform(request: Request) -> str:
â”‚   â”‚       """Extract just the platform."""
â”‚   â”‚       return require_platform_context(request).platform
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def require_shop_domain(request: Request) -> str:
â”‚   â”‚       """Extract just the domain."""
â”‚   â”‚       return require_platform_context(request).domain
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # Type annotations
â”‚   â”‚   PlatformContextDep = Annotated[PlatformContext, Depends(require_platform_context)]
â”‚   â”‚   ShopPlatformDep = Annotated[str, Depends(require_shop_platform)]
â”‚   â”‚   ShopDomainDep = Annotated[str, Depends(require_shop_domain)]
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # =========================
â”‚   â”‚   # Authentication
â”‚   â”‚   # =========================
â”‚   â”‚   
â”‚   â”‚   class ClientAuthContext(BaseModel):
â”‚   â”‚       """Client authentication result with shop context."""
â”‚   â”‚       shop: str
â”‚   â”‚       scope: str
â”‚   â”‚       token: str
â”‚   â”‚       
â”‚   â”‚       @property
â”‚   â”‚       def audience(self) -> str:
â”‚   â”‚           return "client"
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class InternalAuthContext(BaseModel):
â”‚   â”‚       """Internal service-to-service authentication result."""
â”‚   â”‚       service: str  # Identifying which service made the request
â”‚   â”‚       token: str
â”‚   â”‚       
â”‚   â”‚       @property
â”‚   â”‚       def audience(self) -> str:
â”‚   â”‚           return "internal"
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def _get_bearer_token(request: Request) -> str:
â”‚   â”‚       """Extract bearer token from Authorization header."""
â”‚   â”‚       auth = request.headers.get("Authorization")
â”‚   â”‚       if not auth or not auth.lower().startswith("bearer "):
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_401_UNAUTHORIZED, 
â”‚   â”‚               detail="Missing bearer token"
â”‚   â”‚           )
â”‚   â”‚       return auth.split(" ", 1)[1].strip()
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def require_client_auth(request: Request) -> ClientAuthContext:
â”‚   â”‚       """
â”‚   â”‚       Client authentication using JWTs.
â”‚   â”‚       For requests from client applications with shop context.
â”‚   â”‚       """
â”‚   â”‚       token = _get_bearer_token(request)
â”‚   â”‚       secret = os.getenv("CLIENT_JWT_SECRET", "")
â”‚   â”‚       if not secret:
â”‚   â”‚           raise RuntimeError("CLIENT_JWT_SECRET not configured")
â”‚   â”‚       
â”‚   â”‚       try:
â”‚   â”‚           payload = jwt.decode(token, secret, algorithms=["HS256"])
â”‚   â”‚       except jwt.PyJWTError as e:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_401_UNAUTHORIZED, 
â”‚   â”‚               detail=f"Invalid JWT: {str(e)}"
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       return ClientAuthContext(
â”‚   â”‚           shop=payload.get("sub", ""),
â”‚   â”‚           scope=payload.get("scope", ""),
â”‚   â”‚           token=token
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def require_internal_auth(request: Request) -> InternalAuthContext:
â”‚   â”‚       """
â”‚   â”‚       Internal service-to-service authentication.
â”‚   â”‚       Uses static API keys for simplicity and performance.
â”‚   â”‚       """
â”‚   â”‚       token = _get_bearer_token(request)
â”‚   â”‚       raw = os.getenv("INTERNAL_API_KEYS", "")
â”‚   â”‚       if not raw:
â”‚   â”‚           raise RuntimeError("INTERNAL_API_KEYS not configured")
â”‚   â”‚       
â”‚   â”‚       # Format: "service1:key1,service2:key2" or just "key1,key2"
â”‚   â”‚       allowed = {}
â”‚   â”‚       for entry in raw.split(","):
â”‚   â”‚           entry = entry.strip()
â”‚   â”‚           if not entry:
â”‚   â”‚               continue
â”‚   â”‚           if ":" in entry:
â”‚   â”‚               service, key = entry.split(":", 1)
â”‚   â”‚               allowed[key.strip()] = service.strip()
â”‚   â”‚           else:
â”‚   â”‚               allowed[entry] = "unknown"
â”‚   â”‚       
â”‚   â”‚       if token not in allowed:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_401_UNAUTHORIZED, 
â”‚   â”‚               detail="Invalid bearer token"
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       return InternalAuthContext(
â”‚   â”‚           service=allowed[token],
â”‚   â”‚           token=token
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # Type annotations
â”‚   â”‚   ClientAuthDep = Annotated[ClientAuthContext, Depends(require_client_auth)]
â”‚   â”‚   InternalAuthDep = Annotated[InternalAuthContext, Depends(require_internal_auth)]
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # =========================
â”‚   â”‚   # Webhook Headers
â”‚   â”‚   # =========================
â”‚   â”‚   
â”‚   â”‚   class WebhookHeaders(BaseModel):
â”‚   â”‚       """Pure webhook metadata - platform-agnostic."""
â”‚   â”‚       topic: str
â”‚   â”‚       webhook_id: Optional[str] = None
â”‚   â”‚       
â”‚   â”‚       @property
â”‚   â”‚       def event_type(self) -> str:
â”‚   â”‚           """Normalized event type from topic."""
â”‚   â”‚           # e.g., "orders/create" -> "order.created"
â”‚   â”‚           return self.topic.replace("/", ".").replace("_", ".")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def get_webhook_headers(request: Request) -> WebhookHeaders:
â”‚   â”‚       """
â”‚   â”‚       Extract webhook-specific headers only.
â”‚   â”‚       Platform/domain handled by PlatformContext.
â”‚   â”‚       """
â”‚   â”‚       topic = request.headers.get("X-Webhook-Topic")
â”‚   â”‚       if not topic:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail={
â”‚   â”‚                   "code": "MISSING_WEBHOOK_TOPIC",
â”‚   â”‚                   "message": "Missing required webhook topic header",
â”‚   â”‚                   "details": {"expected_header": "X-Webhook-Topic"}
â”‚   â”‚               }
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       if len(topic) > 256:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail="X-Webhook-Topic too long (max 256 characters)"
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       webhook_id = request.headers.get("X-Webhook-Id")
â”‚   â”‚       if webhook_id and len(webhook_id) > 256:
â”‚   â”‚           raise HTTPException(
â”‚   â”‚               status_code=status.HTTP_400_BAD_REQUEST,
â”‚   â”‚               detail="X-Webhook-Id too long (max 256 characters)"
â”‚   â”‚           )
â”‚   â”‚       
â”‚   â”‚       return WebhookHeaders(
â”‚   â”‚           topic=topic,
â”‚   â”‚           webhook_id=webhook_id
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   WebhookHeadersDep = Annotated[WebhookHeaders, Depends(get_webhook_headers)]
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ health.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # glam-app/shared/api/health.py
â”‚   â”‚   
â”‚   â”‚   from fastapi import APIRouter, Request
â”‚   â”‚   from datetime import datetime, timezone
â”‚   â”‚   from shared.api.responses import success_response
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def create_health_router(service_name: str) -> APIRouter:
â”‚   â”‚       router = APIRouter()
â”‚   â”‚   
â”‚   â”‚       @router.get("/health", tags=["Health"])
â”‚   â”‚       async def health_check(request: Request):
â”‚   â”‚           """Basic health check endpoint with service name and timestamp"""
â”‚   â”‚           return success_response(
â”‚   â”‚               data={
â”‚   â”‚                   "status": "healthy",
â”‚   â”‚                   "service": service_name,
â”‚   â”‚                   "timestamp": datetime.now(timezone.utc).isoformat(),
â”‚   â”‚               },
â”‚   â”‚               request_id=getattr(request.state, "request_id", None),
â”‚   â”‚               correlation_id=getattr(request.state, "correlation_id", None),
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚       return router
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ middleware.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   # shared/api/middleware.py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   
â”‚   â”‚   """Simplified API middleware."""
â”‚   â”‚   
â”‚   â”‚   import time
â”‚   â”‚   import uuid
â”‚   â”‚   from typing import Callable
â”‚   â”‚   
â”‚   â”‚   from fastapi import Request, Response
â”‚   â”‚   from fastapi import FastAPI
â”‚   â”‚   from fastapi.responses import JSONResponse
â”‚   â”‚   from starlette.middleware.base import BaseHTTPMiddleware
â”‚   â”‚   from fastapi.exceptions import RequestValidationError, HTTPException
â”‚   â”‚   
â”‚   â”‚   from shared.utils.exceptions import GlamBaseError
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚   
â”‚   â”‚   from .responses import error_response
â”‚   â”‚   from .correlation import get_correlation_id, set_correlation_context
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class APIMiddleware(BaseHTTPMiddleware):
â”‚   â”‚       """Unified middleware for request/response handling."""
â”‚   â”‚       
â”‚   â”‚       def __init__(self, app, *, service_name: str = "glam-service"):
â”‚   â”‚           super().__init__(app)
â”‚   â”‚           self.service_name = service_name
â”‚   â”‚       
â”‚   â”‚       async def dispatch(self, request: Request, call_next: Callable) -> Response:
â”‚   â”‚           
â”‚   â”‚           # Generate IDs
â”‚   â”‚           request_id = request.headers.get("X-Request-ID", f"req_{uuid.uuid4().hex[:12]}")
â”‚   â”‚           
â”‚   â”‚           # Get correlation ID (this will check headers and generate if needed)
â”‚   â”‚           correlation_id = get_correlation_id(request)
â”‚   â”‚           
â”‚   â”‚           # Store in request state for easy access in the request
â”‚   â”‚           request.state.request_id = request_id
â”‚   â”‚           request.state.correlation_id = correlation_id
â”‚   â”‚           
â”‚   â”‚           # IMPORTANT: Set correlation context for async operations
â”‚   â”‚           # This makes correlation_id available throughout the request lifecycle
â”‚   â”‚           set_correlation_context(correlation_id)
â”‚   â”‚           
â”‚   â”‚           logger = request.app.state.logger
â”‚   â”‚           logger.set_request_context(
â”‚   â”‚               request_id=request_id,
â”‚   â”‚               correlation_id=correlation_id,
â”‚   â”‚               method=request.method,
â”‚   â”‚               path=request.url.path,
â”‚   â”‚               ip_client=request.headers.get("X-Forwarded-For", "").split(",")[0].strip() or 
â”‚   â”‚                        (request.client.host if request.client else "unknown")
â”‚   â”‚           )
â”‚   â”‚           
â”‚   â”‚           # Track timing
â”‚   â”‚           start_time = time.perf_counter()
â”‚   â”‚           
â”‚   â”‚           try:
â”‚   â”‚               response = await call_next(request)
â”‚   â”‚               
â”‚   â”‚               # Add standard headers
â”‚   â”‚               response.headers["X-Request-ID"] = request_id
â”‚   â”‚               response.headers["X-Correlation-ID"] = correlation_id
â”‚   â”‚               response.headers["X-Service-Name"] = self.service_name
â”‚   â”‚               
â”‚   â”‚               return response
â”‚   â”‚               
â”‚   â”‚           except Exception as exc:
â”‚   â”‚               # Convert to standard error response
â”‚   â”‚               error_resp = self._handle_exception(exc, request_id, correlation_id, logger)
â”‚   â”‚               
â”‚   â”‚               # Determine status code
â”‚   â”‚               status_code = 500
â”‚   â”‚               if isinstance(exc, GlamBaseError):
â”‚   â”‚                   status_code = exc.status
â”‚   â”‚               elif isinstance(exc, HTTPException):
â”‚   â”‚                   status_code = exc.status_code
â”‚   â”‚               elif isinstance(exc, RequestValidationError):
â”‚   â”‚                   status_code = 422
â”‚   â”‚               
â”‚   â”‚               # Log error
â”‚   â”‚               duration_ms = (time.perf_counter() - start_time) * 1000
â”‚   â”‚               logger.error(
â”‚   â”‚                   "Request failed",
â”‚   â”‚                   extra={
â”‚   â”‚                       "request_id": request_id,
â”‚   â”‚                       "correlation_id": correlation_id,
â”‚   â”‚                       "method": request.method,
â”‚   â”‚                       "path": request.url.path,
â”‚   â”‚                       "status": status_code,
â”‚   â”‚                       "duration_ms": round(duration_ms, 2),
â”‚   â”‚                       "error_code": error_resp.error.code if error_resp.error else "UNKNOWN",
â”‚   â”‚                       "service": self.service_name
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚               
â”‚   â”‚               response = JSONResponse(
â”‚   â”‚                   content=error_resp.model_dump(mode="json", exclude_none=True),
â”‚   â”‚                   status_code=status_code
â”‚   â”‚               )
â”‚   â”‚               
â”‚   â”‚               # Add standard headers
â”‚   â”‚               response.headers["X-Request-ID"] = request_id
â”‚   â”‚               response.headers["X-Correlation-ID"] = correlation_id
â”‚   â”‚               response.headers["X-Service-Name"] = self.service_name
â”‚   â”‚               
â”‚   â”‚               return response
â”‚   â”‚       
â”‚   â”‚       def _handle_exception(self, exc: Exception, request_id: str, correlation_id: str, logger: ServiceLogger):
â”‚   â”‚           """Convert exception to error response using the standard error_response function."""
â”‚   â”‚           
â”‚   â”‚           if isinstance(exc, GlamBaseError):
â”‚   â”‚               return error_response(
â”‚   â”‚                   code=exc.code,
â”‚   â”‚                   message=exc.message,
â”‚   â”‚                   details=exc.details,
â”‚   â”‚                   request_id=request_id,
â”‚   â”‚                   correlation_id=correlation_id
â”‚   â”‚               )
â”‚   â”‚           
â”‚   â”‚           elif isinstance(exc, RequestValidationError):
â”‚   â”‚               validation_errors = []
â”‚   â”‚               for error in exc.errors():
â”‚   â”‚                   field_path = ".".join(str(loc) for loc in error["loc"])
â”‚   â”‚                   validation_errors.append({
â”‚   â”‚                       "field": field_path,
â”‚   â”‚                       "message": error["msg"],
â”‚   â”‚                       "type": error["type"]
â”‚   â”‚                   })
â”‚   â”‚               
â”‚   â”‚               return error_response(
â”‚   â”‚                   code="VALIDATION_ERROR",
â”‚   â”‚                   message="Request validation failed",
â”‚   â”‚                   details={"validation_errors": validation_errors},
â”‚   â”‚                   request_id=request_id,
â”‚   â”‚                   correlation_id=correlation_id
â”‚   â”‚               )
â”‚   â”‚           
â”‚   â”‚           elif isinstance(exc, HTTPException):
â”‚   â”‚               # CRITICAL FIX: Properly extract structured details from HTTPException
â”‚   â”‚               if isinstance(exc.detail, dict):
â”‚   â”‚                   # Dependency raised HTTPException with structured detail
â”‚   â”‚                   return error_response(
â”‚   â”‚                       code=exc.detail.get("code", f"HTTP_{exc.status_code}"),
â”‚   â”‚                       message=exc.detail.get("message", str(exc.detail)),
â”‚   â”‚                       details=exc.detail.get("details", exc.detail),  # Pass ALL details
â”‚   â”‚                       request_id=request_id,
â”‚   â”‚                       correlation_id=correlation_id
â”‚   â”‚                   )
â”‚   â”‚               else:
â”‚   â”‚                   # Simple string detail
â”‚   â”‚                   return error_response(
â”‚   â”‚                       code=f"HTTP_{exc.status_code}",
â”‚   â”‚                       message=str(exc.detail),
â”‚   â”‚                       details=None,
â”‚   â”‚                       request_id=request_id,
â”‚   â”‚                       correlation_id=correlation_id
â”‚   â”‚                   )
â”‚   â”‚           
â”‚   â”‚           else:
â”‚   â”‚               # Unexpected errors - include actual error message
â”‚   â”‚               logger.critical(
â”‚   â”‚                   "Unhandled exception",
â”‚   â”‚                   extra={
â”‚   â”‚                       "request_id": request_id,
â”‚   â”‚                       "correlation_id": correlation_id,
â”‚   â”‚                       "error_type": type(exc).__name__,
â”‚   â”‚                       "error_str": str(exc)
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚               
â”‚   â”‚               return error_response(
â”‚   â”‚                   code="INTERNAL_ERROR",
â”‚   â”‚                   message=f"An unexpected error occurred: {str(exc)}",  # Include actual error
â”‚   â”‚                   details={"type": type(exc).__name__},
â”‚   â”‚                   request_id=request_id,
â”‚   â”‚                   correlation_id=correlation_id
â”‚   â”‚               )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def setup_middleware(
â”‚   â”‚       app: FastAPI,
â”‚   â”‚       *,
â”‚   â”‚       service_name: str
â”‚   â”‚   ):
â”‚   â”‚       """
â”‚   â”‚       Set up all standard middleware for a service.
â”‚   â”‚       
â”‚   â”‚       This sets up middleware in the correct order:
â”‚   â”‚       1. Prometheus metrics (if enabled) - captures all requests
â”‚   â”‚       2. API middleware - handles responses and errors
â”‚   â”‚       
â”‚   â”‚       Args:
â”‚   â”‚           app: FastAPI application
â”‚   â”‚           service_name: Name of the service
â”‚   â”‚           debug: Whether to include error details in responses
â”‚   â”‚       """
â”‚   â”‚   
â”‚   â”‚       # Add API middleware for standardized responses
â”‚   â”‚       app.add_middleware(APIMiddleware, service_name=service_name)
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   # shared/api/models.py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   Unified API response models for glam-app services.
â”‚   â”‚   Consolidates all response structures into a single, consistent pattern.
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   from typing import TypeVar, Generic, Optional, Any, Dict, List
â”‚   â”‚   from datetime import datetime, timezone
â”‚   â”‚   from pydantic import BaseModel, Field, ConfigDict
â”‚   â”‚   import uuid
â”‚   â”‚   
â”‚   â”‚   # Generic type for response data
â”‚   â”‚   T = TypeVar("T")
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class Meta(BaseModel):
â”‚   â”‚       """Metadata included in all responses."""
â”‚   â”‚       request_id: str = Field(description="Unique request identifier")
â”‚   â”‚       correlation_id: Optional[str] = Field(None, description="Distributed tracing ID")
â”‚   â”‚       timestamp: datetime = Field(
â”‚   â”‚           default_factory=lambda: datetime.now(timezone.utc),
â”‚   â”‚           description="Response timestamp in UTC"
â”‚   â”‚       )
â”‚   â”‚       
â”‚   â”‚       model_config = ConfigDict(
â”‚   â”‚           json_encoders={datetime: lambda v: v.isoformat()}
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class Pagination(BaseModel):
â”‚   â”‚       """Pagination metadata for list responses."""
â”‚   â”‚       page: int = Field(ge=1)
â”‚   â”‚       limit: int = Field(ge=1, le=1000)
â”‚   â”‚       total: int = Field(ge=0)
â”‚   â”‚       pages: int = Field(ge=0)
â”‚   â”‚       has_next: bool
â”‚   â”‚       has_previous: bool
â”‚   â”‚       
â”‚   â”‚       @classmethod
â”‚   â”‚       def create(cls, page: int, limit: int, total: int) -> "Pagination":
â”‚   â”‚           """Create pagination from parameters."""
â”‚   â”‚           pages = (total + limit - 1) // limit if total > 0 else 0
â”‚   â”‚           return cls(
â”‚   â”‚               page=page,
â”‚   â”‚               limit=limit,
â”‚   â”‚               total=total,
â”‚   â”‚               pages=pages,
â”‚   â”‚               has_next=page < pages,
â”‚   â”‚               has_previous=page > 1
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class Links(BaseModel):
â”‚   â”‚       """HATEOAS links for resource navigation."""
â”‚   â”‚       self: str
â”‚   â”‚       next: Optional[str] = None
â”‚   â”‚       previous: Optional[str] = None
â”‚   â”‚       first: Optional[str] = None
â”‚   â”‚       last: Optional[str] = None
â”‚   â”‚       
â”‚   â”‚       @classmethod
â”‚   â”‚       def create_paginated(
â”‚   â”‚           cls, 
â”‚   â”‚           base_url: str, 
â”‚   â”‚           page: int, 
â”‚   â”‚           limit: int, 
â”‚   â”‚           pages: int,
â”‚   â”‚           **query_params
â”‚   â”‚       ) -> "Links":
â”‚   â”‚           """Create pagination links."""
â”‚   â”‚           def build_url(page_num: int) -> str:
â”‚   â”‚               params = {**query_params, "page": page_num, "limit": limit}
â”‚   â”‚               query = "&".join(f"{k}={v}" for k, v in params.items())
â”‚   â”‚               return f"{base_url}?{query}"
â”‚   â”‚           
â”‚   â”‚           return cls(
â”‚   â”‚               self=build_url(page),
â”‚   â”‚               next=build_url(page + 1) if page < pages else None,
â”‚   â”‚               previous=build_url(page - 1) if page > 1 else None,
â”‚   â”‚               first=build_url(1) if pages > 0 else None,
â”‚   â”‚               last=build_url(pages) if pages > 0 else None
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ErrorDetail(BaseModel):
â”‚   â”‚       """Error information."""
â”‚   â”‚       code: str
â”‚   â”‚       message: str
â”‚   â”‚       details: Optional[Dict[str, Any]] = None
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ApiResponse(BaseModel, Generic[T]):
â”‚   â”‚       """
â”‚   â”‚       Unified API response structure.
â”‚   â”‚       Used for both success and error responses.
â”‚   â”‚       """
â”‚   â”‚       # For success responses
â”‚   â”‚       data: Optional[T] = None
â”‚   â”‚       
â”‚   â”‚       # For error responses
â”‚   â”‚       error: Optional[ErrorDetail] = None
â”‚   â”‚       
â”‚   â”‚       # Always present
â”‚   â”‚       meta: Meta
â”‚   â”‚       
â”‚   â”‚       # Optional for paginated responses
â”‚   â”‚       pagination: Optional[Pagination] = None
â”‚   â”‚       links: Optional[Links] = None
â”‚   â”‚       
â”‚   â”‚       model_config = ConfigDict(
â”‚   â”‚           json_encoders={datetime: lambda v: v.isoformat()}
â”‚   â”‚       )
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ responses.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   # shared/api/responses.py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   
â”‚   â”‚   """Response helper functions."""
â”‚   â”‚   
â”‚   â”‚   from typing import Optional, Dict, Any, List, Tuple
â”‚   â”‚   import uuid
â”‚   â”‚   from .models import ApiResponse, Meta, ErrorDetail, Pagination, Links, T
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def create_response(
â”‚   â”‚       data: Optional[T] = None,
â”‚   â”‚       error: Optional[ErrorDetail] = None,
â”‚   â”‚       request_id: Optional[str] = None,
â”‚   â”‚       correlation_id: Optional[str] = None,
â”‚   â”‚       pagination: Optional[Pagination] = None,
â”‚   â”‚       links: Optional[Links] = None
â”‚   â”‚   ) -> ApiResponse[T]:
â”‚   â”‚       """Create a unified API response."""
â”‚   â”‚       if request_id is None:
â”‚   â”‚           request_id = f"req_{uuid.uuid4().hex[:12]}"
â”‚   â”‚       
â”‚   â”‚       meta = Meta(request_id=request_id, correlation_id=correlation_id)
â”‚   â”‚       
â”‚   â”‚       return ApiResponse(
â”‚   â”‚           data=data,
â”‚   â”‚           error=error,
â”‚   â”‚           meta=meta,
â”‚   â”‚           pagination=pagination,
â”‚   â”‚           links=links
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def success_response(
â”‚   â”‚       data: T,
â”‚   â”‚       request_id: Optional[str] = None,
â”‚   â”‚       correlation_id: Optional[str] = None,
â”‚   â”‚       links: Optional[Links] = None
â”‚   â”‚   ) -> ApiResponse[T]:
â”‚   â”‚       """Create a success response."""
â”‚   â”‚       return create_response(
â”‚   â”‚           data=data,
â”‚   â”‚           request_id=request_id,
â”‚   â”‚           correlation_id=correlation_id,
â”‚   â”‚           links=links
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def error_response(
â”‚   â”‚       code: str,
â”‚   â”‚       message: str,
â”‚   â”‚       details: Optional[Dict[str, Any]] = None,
â”‚   â”‚       request_id: Optional[str] = None,
â”‚   â”‚       correlation_id: Optional[str] = None
â”‚   â”‚   ) -> ApiResponse[None]:
â”‚   â”‚       """Create an error response."""
â”‚   â”‚       error = ErrorDetail(code=code, message=message, details=details)
â”‚   â”‚       return create_response(
â”‚   â”‚           error=error,
â”‚   â”‚           request_id=request_id,
â”‚   â”‚           correlation_id=correlation_id
â”‚   â”‚       )
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def paginated_response(
â”‚   â”‚       data: List[T],
â”‚   â”‚       page: int,
â”‚   â”‚       limit: int,
â”‚   â”‚       total: int,
â”‚   â”‚       base_url: str,
â”‚   â”‚       request_id: Optional[str] = None,
â”‚   â”‚       correlation_id: Optional[str] = None,
â”‚   â”‚       **query_params
â”‚   â”‚   ) -> ApiResponse[List[T]]:
â”‚   â”‚       """Create a paginated response."""
â”‚   â”‚       pagination = Pagination.create(page, limit, total)
â”‚   â”‚       links = Links.create_paginated(base_url, page, limit, pagination.pages, **query_params)
â”‚   â”‚       
â”‚   â”‚       return create_response(
â”‚   â”‚           data=data,
â”‚   â”‚           request_id=request_id,
â”‚   â”‚           correlation_id=correlation_id,
â”‚   â”‚           pagination=pagination,
â”‚   â”‚           links=links
â”‚   â”‚       )
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â””â”€â”€ validation.py
â”‚       
â”‚       ```py
â”‚       # shared/api/validation.py
â”‚       from typing import Optional, Dict, Any
â”‚       from fastapi import HTTPException, status
â”‚       from shared.api.dependencies import ClientAuthContext, PlatformContext
â”‚       from shared.utils.logger import ServiceLogger
â”‚       
â”‚       
â”‚       def validate_shop_context(
â”‚           client_auth: ClientAuthContext,
â”‚           platform_ctx: PlatformContext,
â”‚           logger: ServiceLogger,
â”‚           body_platform: Optional[str] = None,
â”‚           body_domain: Optional[str] = None,
â”‚           expected_platform: Optional[str] = None,
â”‚           expected_scope: Optional[str] = None,
â”‚           webhook_payload: Optional[Dict[str, Any]] = None
â”‚       ) -> None:
â”‚           """
â”‚           Unified validation for shop context across auth, headers, body, and webhooks.
â”‚           
â”‚           Args:
â”‚               client_auth: JWT authentication context
â”‚               platform_ctx: Platform context from headers
â”‚               logger: Service logger
â”‚               body_platform: Platform from request body (if applicable)
â”‚               body_domain: Domain from request body (if applicable)
â”‚               expected_platform: Expected platform for this endpoint (e.g., "shopify")
â”‚               expected_scope: Expected JWT scope (e.g., "bff:call")
â”‚               webhook_payload: Webhook payload for platform-specific validation
â”‚           
â”‚           Raises:
â”‚               HTTPException: On any validation failure
â”‚           """
â”‚           
â”‚           # 1. Validate expected platform (for platform-specific endpoints)
â”‚           if expected_platform and platform_ctx.platform != expected_platform:
â”‚               logger.warning(
â”‚                   f"Invalid platform for {expected_platform}-only endpoint",
â”‚                   extra={
â”‚                       "received_platform": platform_ctx.platform,
â”‚                       "expected_platform": expected_platform
â”‚                   }
â”‚               )
â”‚               raise HTTPException(
â”‚                   status_code=status.HTTP_400_BAD_REQUEST,
â”‚                   detail={
â”‚                       "code": "INVALID_PLATFORM",
â”‚                       "message": f"This endpoint only accepts {expected_platform} requests",
â”‚                       "details": {
â”‚                           "received": platform_ctx.platform,
â”‚                           "expected": expected_platform
â”‚                       }
â”‚                   }
â”‚               )
â”‚           
â”‚           # 2. Validate JWT shop matches header domain
â”‚           if client_auth.shop != platform_ctx.domain:
â”‚               logger.warning(
â”‚                   "Shop domain mismatch between JWT and headers",
â”‚                   extra={
â”‚                       "jwt_shop": client_auth.shop,
â”‚                       "header_domain": platform_ctx.domain
â”‚                   }
â”‚               )
â”‚               raise HTTPException(
â”‚                   status_code=status.HTTP_401_UNAUTHORIZED,
â”‚                   detail={
â”‚                       "code": "SHOP_DOMAIN_MISMATCH",
â”‚                       "message": "Shop domain mismatch between JWT and headers",
â”‚                       "details": {
â”‚                           "jwt_shop": client_auth.shop,
â”‚                           "header_domain": platform_ctx.domain
â”‚                       }
â”‚                   }
â”‚               )
â”‚           
â”‚           # 3. Validate JWT scope if specified
â”‚           if expected_scope and client_auth.scope != expected_scope:
â”‚               logger.warning(
â”‚                   "Invalid JWT scope",
â”‚                   extra={
â”‚                       "received_scope": client_auth.scope,
â”‚                       "expected_scope": expected_scope
â”‚                   }
â”‚               )
â”‚               raise HTTPException(
â”‚                   status_code=status.HTTP_403_FORBIDDEN,
â”‚                   detail={
â”‚                       "code": "INVALID_SCOPE",
â”‚                       "message": f"Invalid JWT scope",
â”‚                       "details": {
â”‚                           "received": client_auth.scope,
â”‚                           "expected": expected_scope
â”‚                       }
â”‚                   }
â”‚               )
â”‚           
â”‚           # 4. Validate body domain if provided
â”‚           if body_domain and body_domain.lower() != platform_ctx.domain.lower():
â”‚               logger.warning(
â”‚                   "Domain mismatch between request body and header",
â”‚                   extra={
â”‚                       "body_domain": body_domain,
â”‚                       "header_domain": platform_ctx.domain
â”‚                   }
â”‚               )
â”‚               raise HTTPException(
â”‚                   status_code=status.HTTP_400_BAD_REQUEST,
â”‚                   detail={
â”‚                       "code": "BODY_DOMAIN_MISMATCH",
â”‚                       "message": "Domain mismatch between request body and header",
â”‚                       "details": {
â”‚                           "body_domain": body_domain,
â”‚                           "header_domain": platform_ctx.domain
â”‚                       }
â”‚                   }
â”‚               )
â”‚           
â”‚           # 5. Validate body platform if provided
â”‚           if body_platform and body_platform.lower() != platform_ctx.platform.lower():
â”‚               logger.warning(
â”‚                   "Platform mismatch between request body and header",
â”‚                   extra={
â”‚                       "body_platform": body_platform,
â”‚                       "header_platform": platform_ctx.platform
â”‚                   }
â”‚               )
â”‚               raise HTTPException(
â”‚                   status_code=status.HTTP_400_BAD_REQUEST,
â”‚                   detail={
â”‚                       "code": "PLATFORM_MISMATCH",
â”‚                       "message": "Platform mismatch between request body and header",
â”‚                       "details": {
â”‚                           "body_platform": body_platform,
â”‚                           "header_platform": platform_ctx.platform
â”‚                       }
â”‚                   }
â”‚               )
â”‚           
â”‚           # 6. Platform-specific webhook payload validation
â”‚           if webhook_payload:
â”‚               if platform_ctx.is_shopify:
â”‚                   # Shopify-specific validation
â”‚                   payload_domain = (
â”‚                       webhook_payload.get("myshopify_domain") or 
â”‚                       webhook_payload.get("domain") or 
â”‚                       ""
â”‚                   ).lower()
â”‚                   
â”‚                   if payload_domain and payload_domain != platform_ctx.domain:
â”‚                       logger.warning(
â”‚                           "Shopify webhook payload domain mismatch",
â”‚                           extra={
â”‚                               "payload_domain": payload_domain,
â”‚                               "header_domain": platform_ctx.domain
â”‚                           }
â”‚                       )
â”‚                       raise HTTPException(
â”‚                           status_code=status.HTTP_400_BAD_REQUEST,
â”‚                           detail={
â”‚                               "code": "WEBHOOK_DOMAIN_MISMATCH",
â”‚                               "message": "Webhook payload domain doesn't match header domain",
â”‚                               "details": {
â”‚                                   "payload_domain": payload_domain,
â”‚                                   "header_domain": platform_ctx.domain
â”‚                               }
â”‚                           }
â”‚                       )
â”‚               
â”‚               # Add other platform-specific validations as needed
â”‚               # elif platform_ctx.platform == "bigcommerce":
â”‚               #     ...
â”‚       
â”‚       # Usage patterns:
â”‚       
â”‚       # Minimal validation (just auth consistency)
â”‚       # validate_shop_context(client_auth, platform_ctx, logger)
â”‚       
â”‚       # # With body validation
â”‚       # validate_shop_context(
â”‚       #     client_auth, platform_ctx, logger,
â”‚       #     body_platform=body.platform,
â”‚       #     body_domain=body.domain
â”‚       # )
â”‚       
â”‚       # # Platform-specific endpoint
â”‚       # validate_shop_context(
â”‚       #     client_auth, platform_ctx, logger,
â”‚       #     expected_platform="shopify"
â”‚       # )
â”‚       
â”‚       # # Webhook with all validations
â”‚       # validate_shop_context(
â”‚       #     client_auth, platform_ctx, logger,
â”‚       #     expected_platform="shopify",
â”‚       #     expected_scope="bff:call",
â”‚       #     webhook_payload=payload
â”‚       # )
â”‚       ```
â”‚       
â”œâ”€â”€ messaging/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/messaging/__init__.py
â”‚   â”‚   """Shared messaging module for publisher, subscriber, event context, stream client, subject, and payloads."""
â”‚   â”‚   
â”‚   â”‚   from .publisher import Publisher
â”‚   â”‚   from .listener import Listener 
â”‚   â”‚   
â”‚   â”‚   from .jetstream_client import JetStreamClient
â”‚   â”‚   from .subjects import Subjects
â”‚   â”‚   
â”‚   â”‚   __all__ = [
â”‚   â”‚       "Publisher",
â”‚   â”‚       "Listener",
â”‚   â”‚       "JetStreamClient",
â”‚   â”‚       "Subjects",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ jetstream_client.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/shared/messaging/jetstream_client.py
â”‚   â”‚   """Pure JetStream client - only connection + stream management.
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   import os
â”‚   â”‚   from typing import List, Optional
â”‚   â”‚   
â”‚   â”‚   import nats
â”‚   â”‚   from nats.aio.client import Client
â”‚   â”‚   from nats.js import JetStreamContext
â”‚   â”‚   from nats.js.api import StreamConfig, RetentionPolicy, StorageType
â”‚   â”‚   from nats.js.errors import NotFoundError
â”‚   â”‚   
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class JetStreamClient:
â”‚   â”‚       """Pure JetStream client - only connection + stream management."""
â”‚   â”‚   
â”‚   â”‚       def __init__(self, logger: ServiceLogger) -> None:  # âœ” typed
â”‚   â”‚           self._client: Optional[Client] = None
â”‚   â”‚           self._js: Optional[JetStreamContext] = None
â”‚   â”‚           self.logger = logger
â”‚   â”‚   
â”‚   â”‚       # context-manager helpers --------------------------------------------------
â”‚   â”‚       async def __aenter__(self): return self
â”‚   â”‚       async def __aexit__(self, exc_t, exc, tb): await self.close()
â”‚   â”‚   
â”‚   â”‚       # public accessors ---------------------------------------------------------
â”‚   â”‚       @property
â”‚   â”‚       def client(self) -> Client:
â”‚   â”‚           if not self._client:
â”‚   â”‚               raise RuntimeError("NATS client not connected")
â”‚   â”‚           return self._client
â”‚   â”‚   
â”‚   â”‚       @property
â”‚   â”‚       def js(self) -> JetStreamContext:
â”‚   â”‚           if not self._js:
â”‚   â”‚               raise RuntimeError("JetStream not initialized")
â”‚   â”‚           return self._js
â”‚   â”‚   
â”‚   â”‚       # connection ---------------------------------------------------------------
â”‚   â”‚       async def connect(self, servers: List[str]) -> None:
â”‚   â”‚           opts = {
â”‚   â”‚               "servers": servers,
â”‚   â”‚               "max_reconnect_attempts": -1,
â”‚   â”‚               "reconnect_time_wait": 2,
â”‚   â”‚           }
â”‚   â”‚           if user := os.getenv("NATS_USER"):
â”‚   â”‚               opts.update(user=user, password=os.getenv("NATS_PASSWORD", ""))
â”‚   â”‚   
â”‚   â”‚           self._client = await nats.connect(**opts)
â”‚   â”‚           self._js = self._client.jetstream()
â”‚   â”‚           if self.logger:
â”‚   â”‚               self.logger.info("Connected to NATS %s", servers)
â”‚   â”‚   
â”‚   â”‚       async def close(self) -> None:
â”‚   â”‚           if self._client and not self._client.is_closed:
â”‚   â”‚               await self._client.close()
â”‚   â”‚               if self.logger:
â”‚   â”‚                   self.logger.info("NATS connection closed")
â”‚   â”‚   
â”‚   â”‚       def is_connected(self) -> bool:
â”‚   â”‚           return bool(self._client and self._client.is_connected)
â”‚   â”‚   
â”‚   â”‚       # stream helpers -----------------------------------------------------------
â”‚   â”‚       async def ensure_stream(
â”‚   â”‚           self,
â”‚   â”‚           name: str,
â”‚   â”‚           subjects: List[str],
â”‚   â”‚           **kw,
â”‚   â”‚       ) -> None:
â”‚   â”‚           if not self._js:
â”‚   â”‚               raise RuntimeError("JetStream not initialized")
â”‚   â”‚           
â”‚   â”‚           cfg = StreamConfig(
â”‚   â”‚               name=name,
â”‚   â”‚               subjects=subjects,
â”‚   â”‚               retention=kw.get("retention", RetentionPolicy.LIMITS),
â”‚   â”‚               max_age=kw.get("max_age", 24 * 60 * 60),
â”‚   â”‚               max_msgs=kw.get("max_msgs", 1_000_000),
â”‚   â”‚               storage=kw.get("storage", StorageType.FILE),
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚           try:
â”‚   â”‚               await self._js.stream_info(name)
â”‚   â”‚               if self.logger:
â”‚   â”‚                   self.logger.debug("Using existing stream: %s", name)
â”‚   â”‚           except NotFoundError:  
â”‚   â”‚               await self._js.add_stream(cfg)
â”‚   â”‚               if self.logger:
â”‚   â”‚                   self.logger.info("Created new stream: %s", name)
â”‚   â”‚               
â”‚   â”‚       async def delete_stream(self, name: str) -> None:
â”‚   â”‚           if not self._js:
â”‚   â”‚               raise RuntimeError("JetStream not initialized")
â”‚   â”‚           await self._js.delete_stream(name)
â”‚   â”‚           if self.logger:
â”‚   â”‚               self.logger.info("Deleted stream: %s", name)
â”‚   â”‚   
â”‚   â”‚       async def get_stream_info(self, name: str) -> dict:
â”‚   â”‚           if not self._js:
â”‚   â”‚               raise RuntimeError("JetStream not initialized")
â”‚   â”‚           info = await self._js.stream_info(name)
â”‚   â”‚           return {
â”‚   â”‚               "name": info.config.name,
â”‚   â”‚               "subjects": info.config.subjects,
â”‚   â”‚               "messages": info.state.messages,
â”‚   â”‚               "bytes": info.state.bytes,
â”‚   â”‚           }
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ listener.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/messaging/js_listener.py
â”‚   â”‚   """A thin, â€œsafeâ€ JetStream listener with JSON decode guard and error handling."""
â”‚   â”‚   
â”‚   â”‚   import asyncio, json
â”‚   â”‚   from abc import ABC, abstractmethod
â”‚   â”‚   from typing import Any, Dict, Optional
â”‚   â”‚   
â”‚   â”‚   from nats.js.api import AckPolicy, ConsumerConfig, DeliverPolicy
â”‚   â”‚   from nats.js.errors import NotFoundError
â”‚   â”‚   
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚   from .jetstream_client import JetStreamClient
â”‚   â”‚   # from .event_context import set_correlation_id, set_source_service
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class Listener(ABC):
â”‚   â”‚       """
â”‚   â”‚       A thin, â€œsafeâ€ JetStream listener:
â”‚   â”‚       â€¢ one subject
â”‚   â”‚       â€¢ JSON decode guard
â”‚   â”‚       â€¢ soft-fail vs. hard-fail error handling
â”‚   â”‚       """
â”‚   â”‚       
â”‚   â”‚       stream_name: str = "GLAM_EVENTS"
â”‚   â”‚       batch_size: int = 10
â”‚   â”‚       ack_wait_sec: int = 30
â”‚   â”‚       max_deliver: int = 3
â”‚   â”‚   
â”‚   â”‚       # ---- subclasses MUST fill these --------------------------------------
â”‚   â”‚       @property
â”‚   â”‚       @abstractmethod
â”‚   â”‚       def service_name(self) -> str:
â”‚   â”‚           """Name of the owning micro-service (used for durable name)."""
â”‚   â”‚           pass
â”‚   â”‚   
â”‚   â”‚       @property
â”‚   â”‚       @abstractmethod
â”‚   â”‚       def subject(self) -> str:
â”‚   â”‚           """Full NATS subject to consume, e.g. ``evt.email.sent.v1``."""
â”‚   â”‚           pass
â”‚   â”‚   
â”‚   â”‚       @property
â”‚   â”‚       @abstractmethod
â”‚   â”‚       def queue_group(self) -> str:
â”‚   â”‚           """Queue group so replicas share the workload."""
â”‚   â”‚           pass
â”‚   â”‚   
â”‚   â”‚       # ----------------------------------------------------------------------
â”‚   â”‚       def __init__(self, js_client: JetStreamClient, logger: ServiceLogger) -> None:
â”‚   â”‚           self._js = js_client.js
â”‚   â”‚           self.logger = logger
â”‚   â”‚           self._sub = None
â”‚   â”‚   
â”‚   â”‚       # ======================================================================
â”‚   â”‚       # public API
â”‚   â”‚       # ======================================================================
â”‚   â”‚       async def start(self) -> None:
â”‚   â”‚           await self._ensure_stream()
â”‚   â”‚           await self._ensure_consumer()
â”‚   â”‚           await self._create_subscription()
â”‚   â”‚           self.logger.info("Listening on %s", self.subject)
â”‚   â”‚           asyncio.create_task(self._poll_loop())
â”‚   â”‚   
â”‚   â”‚       async def stop(self) -> None:
â”‚   â”‚           if self._sub:
â”‚   â”‚               await self._sub.unsubscribe()
â”‚   â”‚   
â”‚   â”‚       # ======================================================================
â”‚   â”‚       # override in subclasses
â”‚   â”‚       # ======================================================================
â”‚   â”‚       @abstractmethod
â”‚   â”‚       async def on_message(self, data: Dict[str, Any]) -> None: ...
â”‚   â”‚   
â”‚   â”‚       # ======================================================================
â”‚   â”‚       # internals
â”‚   â”‚       # ======================================================================
â”‚   â”‚       # stream
â”‚   â”‚       async def _ensure_stream(self) -> None:
â”‚   â”‚           """Stream must exist and cover ``evt.*`` **and** ``cmd.*``."""
â”‚   â”‚           from nats.js.api import RetentionPolicy, StorageType, StreamConfig  # local to avoid circulars
â”‚   â”‚   
â”‚   â”‚           try:
â”‚   â”‚               await self._js.stream_info(self.stream_name)
â”‚   â”‚           except NotFoundError:
â”‚   â”‚               cfg = StreamConfig(
â”‚   â”‚                   name=self.stream_name,
â”‚   â”‚                   subjects=["evt.*", "cmd.*"],
â”‚   â”‚                   retention=RetentionPolicy.LIMITS,
â”‚   â”‚                   max_age=24 * 60 * 60,
â”‚   â”‚                   max_msgs=1_000_000,
â”‚   â”‚                   storage=StorageType.FILE,
â”‚   â”‚               )
â”‚   â”‚               await self._js.add_stream(cfg)
â”‚   â”‚               self.logger.info("Created stream %s", self.stream_name)
â”‚   â”‚           
â”‚   â”‚   
â”‚   â”‚       # consumer
â”‚   â”‚       async def _ensure_consumer(self) -> None:
â”‚   â”‚           durable = f"{self.service_name}-{self.queue_group}"
â”‚   â”‚           try:
â”‚   â”‚               await self._js.consumer_info(self.stream_name, durable)
â”‚   â”‚           except NotFoundError:
â”‚   â”‚               cfg = ConsumerConfig(
â”‚   â”‚                   durable_name=durable,
â”‚   â”‚                   deliver_policy=DeliverPolicy.ALL,
â”‚   â”‚                   ack_policy=AckPolicy.EXPLICIT,
â”‚   â”‚                   max_deliver=self.max_deliver,
â”‚   â”‚                   ack_wait=self.ack_wait_sec,
â”‚   â”‚                   filter_subject=self.subject,
â”‚   â”‚               )
â”‚   â”‚               await self._js.add_consumer(self.stream_name, cfg)
â”‚   â”‚   
â”‚   â”‚       # subscription
â”‚   â”‚       async def _create_subscription(self) -> None:
â”‚   â”‚           self._sub = await self._js.pull_subscribe(
â”‚   â”‚               self.subject,
â”‚   â”‚               durable=f"{self.service_name}-{self.queue_group}",
â”‚   â”‚               stream=self.stream_name,
â”‚   â”‚           )
â”‚   â”‚   
â”‚   â”‚       # polling loop
â”‚   â”‚       async def _poll_loop(self) -> None:
â”‚   â”‚           while True:
â”‚   â”‚               if not self._sub:
â”‚   â”‚                   self.logger.error("Subscription not initialized, skipping poll")
â”‚   â”‚                   await asyncio.sleep(1)
â”‚   â”‚                   continue
â”‚   â”‚               msgs = await self._sub.fetch(batch=10, timeout=1)
â”‚   â”‚               for m in msgs:
â”‚   â”‚                   await self._safe_handle(m)
â”‚   â”‚   
â”‚   â”‚       # safe handler
â”‚   â”‚       async def _safe_handle(self, msg) -> None:
â”‚   â”‚           try:
â”‚   â”‚               envelope = json.loads(msg.data.decode())
â”‚   â”‚           except json.JSONDecodeError:
â”‚   â”‚               self.logger.error("Bad JSON on %s", self.subject)
â”‚   â”‚               await msg.ack()
â”‚   â”‚               return
â”‚   â”‚   
â”‚   â”‚           # Envelope sanity
â”‚   â”‚           for f in ("event_id", "event_type", "data"):
â”‚   â”‚               if f not in envelope:
â”‚   â”‚                   self.logger.error("Missing %s; acking", f)
â”‚   â”‚                   await msg.ack()
â”‚   â”‚                   return
â”‚   â”‚           if envelope["event_type"] != self.subject.split(".", 1)[-1]:
â”‚   â”‚               await msg.ack()
â”‚   â”‚               return
â”‚   â”‚   
â”‚   â”‚           # Context vars
â”‚   â”‚           # set_correlation_id(envelope.get("correlation_id")) # TODO: figure out how to get correlation_id from context
â”‚   â”‚           # set_source_service(envelope.get("source_service"))
â”‚   â”‚   
â”‚   â”‚           # Business logic
â”‚   â”‚           try:
â”‚   â”‚               await self.on_message(envelope["data"])
â”‚   â”‚               await msg.ack()
â”‚   â”‚           except Exception as exc:
â”‚   â”‚               should_ack = await self.on_error(exc, envelope["data"])
â”‚   â”‚               await (msg.ack() if should_ack else msg.nack())
â”‚   â”‚   
â”‚   â”‚       # default hook
â”‚   â”‚       async def on_error(self, error: Exception, data: dict) -> bool:
â”‚   â”‚           self.logger.error("Error on %s: %s", self.subject, error, exc_info=True)
â”‚   â”‚           return False
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ publisher.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/messaging/publisher.py
â”‚   â”‚   """Publisher base class for domain events and commands."""
â”‚   â”‚   import json
â”‚   â”‚   from abc import ABC, abstractmethod
â”‚   â”‚   from datetime import datetime, timezone
â”‚   â”‚   from typing import Dict, Optional
â”‚   â”‚   from uuid import uuid4
â”‚   â”‚   
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚   from shared.api.correlation import get_correlation_id
â”‚   â”‚   from .jetstream_client import JetStreamClient
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class Publisher(ABC):
â”‚   â”‚       """Publishes domain facts (evt.*) and commands (cmd.*)"""
â”‚   â”‚   
â”‚   â”‚       @property
â”‚   â”‚       @abstractmethod
â”‚   â”‚       def service_name(self) -> str: ...
â”‚   â”‚       
â”‚   â”‚       def __init__(self, jetstream_client: JetStreamClient, logger: ServiceLogger) -> None:
â”‚   â”‚           self.js_client = jetstream_client
â”‚   â”‚           self.logger = logger
â”‚   â”‚   
â”‚   â”‚       async def publish_event(
â”‚   â”‚           self,
â”‚   â”‚           subject: str,
â”‚   â”‚           data: dict,
â”‚   â”‚           correlation_id: str,
â”‚   â”‚           metadata: Optional[Dict[str, dict]] = None,
â”‚   â”‚       ) -> str:
â”‚   â”‚           """Publish an event to JetStream"""
â”‚   â”‚           
â”‚   â”‚           self.logger.info("Publishing event %s", subject)
â”‚   â”‚           
â”‚   â”‚           if not (subject.startswith("evt.") or subject.startswith("cmd.")):
â”‚   â”‚               raise ValueError("subject must start with 'evt.' or 'cmd.'")
â”‚   â”‚           
â”‚   â”‚           event_id = str(uuid4())
â”‚   â”‚           
â”‚   â”‚           envelope = {
â”‚   â”‚               "event_id": event_id,
â”‚   â”‚               "event_type": subject,
â”‚   â”‚               "correlation_id": correlation_id,
â”‚   â”‚               "timestamp": datetime.now(timezone.utc).isoformat(),
â”‚   â”‚               "source_service": self.service_name,
â”‚   â”‚               "data": data,
â”‚   â”‚               "metadata": metadata or {},
â”‚   â”‚           }
â”‚   â”‚   
â”‚   â”‚           try:
â”‚   â”‚               # Publish directly - stream already exists
â”‚   â”‚               ack = await self.js_client.js.publish(
â”‚   â”‚                   subject, 
â”‚   â”‚                   json.dumps(envelope).encode()
â”‚   â”‚               )
â”‚   â”‚               
â”‚   â”‚               self.logger.info(
â”‚   â”‚                   "Published %s [event_id=%s, seq=%s]", 
â”‚   â”‚                   subject, 
â”‚   â”‚                   event_id,
â”‚   â”‚                   ack.seq if ack else "unknown"
â”‚   â”‚               )
â”‚   â”‚               return event_id
â”‚   â”‚               
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.logger.error(
â”‚   â”‚                   "Failed to publish event %s: %s", 
â”‚   â”‚                   subject, 
â”‚   â”‚                   str(e),
â”‚   â”‚                   exc_info=True
â”‚   â”‚               )
â”‚   â”‚               raise
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â””â”€â”€ subjects.py
â”‚       
â”‚       ```py
â”‚       # shared/shared/messaging/subjects.py
â”‚       """NATS subjects for microservices."""
â”‚       
â”‚       from enum import Enum
â”‚       
â”‚       class Subjects(str, Enum):
â”‚           """NATS subjects for the notification service"""
â”‚           EMAIL_SEND_REQUESTED = "cmd.email.send.requested.v1"
â”‚           EMAIL_SEND_COMPLETE = "evt.email.send.complete.v1"
â”‚           EMAIL_SEND_FAILED = "evt.email.send.failed.v1"
â”‚           EMAIL_SEND_BOUNCED = "evt.email.send.bounced.v1"
â”‚           EMAIL_SEND_BULK_REQUESTED = "cmd.email.send.bulk.requested.v1"
â”‚           EMAIL_SEND_BULK_STARTED = "evt.email.send.bulk.started.v1"
â”‚           EMAIL_SEND_BULK_COMPLETE = "evt.email.send.bulk.complete.v1"
â”‚           EMAIL_SEND_BULK_FAILED = "evt.email.send.bulk.failed.v1"
â”‚           
â”‚       ```
â”‚       
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   from .config_loader import merged_config, flatten_config
â”‚   â”‚   from .exceptions import GlamBaseError, ConfigurationError, InternalError, RequestTimeoutError, ServiceUnavailableError, RateLimitExceededError, ForbiddenError, UnauthorizedError, NotFoundError, ValidationError, DomainError, InfrastructureError
â”‚   â”‚   
â”‚   â”‚   from .logger import create_logger, ServiceLogger
â”‚   â”‚   from .idempotency_key import generate_idempotency_key
â”‚   â”‚   
â”‚   â”‚   __all__ = [
â”‚   â”‚       "merged_config",
â”‚   â”‚       "flatten_config",
â”‚   â”‚       "GlamBaseError",
â”‚   â”‚       "ConfigurationError",
â”‚   â”‚       "InternalError",
â”‚   â”‚       "RequestTimeoutError",  
â”‚   â”‚       "ServiceUnavailableError",
â”‚   â”‚       "RateLimitExceededError",
â”‚   â”‚       "ForbiddenError",
â”‚   â”‚       "UnauthorizedError",
â”‚   â”‚       "NotFoundError",
â”‚   â”‚       "ValidationError",
â”‚   â”‚       "DomainError",
â”‚   â”‚       "InfrastructureError",
â”‚   â”‚       "create_logger",
â”‚   â”‚       "ServiceLogger",
â”‚   â”‚       "generate_idempotency_key",
â”‚   â”‚   ]
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ config_loader.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/utils/config_loader.py
â”‚   â”‚   from __future__ import annotations
â”‚   â”‚   from pathlib import Path
â”‚   â”‚   from typing import Any, Dict, Iterable
â”‚   â”‚   import os
â”‚   â”‚   import yaml
â”‚   â”‚   from dotenv import load_dotenv
â”‚   â”‚   
â”‚   â”‚   # repo root
â”‚   â”‚   _REPO_ROOT = Path(__file__).resolve()
â”‚   â”‚   while _REPO_ROOT.name != "glam-app":
â”‚   â”‚       if _REPO_ROOT.parent == _REPO_ROOT:
â”‚   â”‚           raise RuntimeError("Unable to locate glam-app root directory")
â”‚   â”‚       _REPO_ROOT = _REPO_ROOT.parent
â”‚   â”‚   
â”‚   â”‚   _CONFIG_DIR = _REPO_ROOT / "config"
â”‚   â”‚   _SHARED_CONFIG = _CONFIG_DIR / "shared.yml"
â”‚   â”‚   _SVC_CFG_DIR = _CONFIG_DIR / "services"
â”‚   â”‚   
â”‚   â”‚   def _load_yaml(path: Path) -> Dict[str, Any]:
â”‚   â”‚       if not path.is_file():
â”‚   â”‚           return {}
â”‚   â”‚       with path.open() as f:
â”‚   â”‚           return yaml.safe_load(f) or {}
â”‚   â”‚   
â”‚   â”‚   def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
â”‚   â”‚       out = a.copy()
â”‚   â”‚       for k, v in b.items():
â”‚   â”‚           if k in out and isinstance(out[k], dict) and isinstance(v, dict):
â”‚   â”‚               out[k] = _deep_merge(out[k], v)
â”‚   â”‚           else:
â”‚   â”‚               out[k] = v
â”‚   â”‚       return out
â”‚   â”‚   
â”‚   â”‚   def merged_config(service: str) -> Dict[str, Any]:
â”‚   â”‚       """Load config: shared.yml < service.yml < ALL environment variables"""
â”‚   â”‚       
â”‚   â”‚       # Load root .env if not in Docker and not disabled
â”‚   â”‚       if not os.path.exists("/.dockerenv") and os.getenv("DISABLE_DOTENV") != "1":
â”‚   â”‚           root_env = _REPO_ROOT / ".env"
â”‚   â”‚           if root_env.is_file():
â”‚   â”‚               load_dotenv(root_env, override=False)
â”‚   â”‚       
â”‚   â”‚       # Merge YAML configs
â”‚   â”‚       cfg = _deep_merge(
â”‚   â”‚           _load_yaml(_SHARED_CONFIG),
â”‚   â”‚           _load_yaml(_SVC_CFG_DIR / f"{service}.yml"),
â”‚   â”‚       )
â”‚   â”‚       
â”‚   â”‚       # Add ALL environment variables
â”‚   â”‚       cfg.update(os.environ)
â”‚   â”‚       
â”‚   â”‚       return cfg
â”‚   â”‚   
â”‚   â”‚   def flatten_config(data: dict, parent_key: str = "", sep: str = ".") -> dict:
â”‚   â”‚       items: list[tuple[str, Any]] = []
â”‚   â”‚       for k, v in data.items():
â”‚   â”‚           nk = f"{parent_key}{sep}{k}" if parent_key else k
â”‚   â”‚           if isinstance(v, dict):
â”‚   â”‚               items.extend(flatten_config(v, nk, sep=sep).items())
â”‚   â”‚           else:
â”‚   â”‚               items.append((nk, v))
â”‚   â”‚       return dict(items)
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   # shared/errors/base.py
â”‚   â”‚   # -------------------------------
â”‚   â”‚   
â”‚   â”‚   """
â”‚   â”‚   Base error classes for the glam-app error hierarchy.
â”‚   â”‚   
â”‚   â”‚   This module defines the fundamental error types that all other
â”‚   â”‚   errors inherit from, following a three-tier model:
â”‚   â”‚   1. GlamBaseError - Root of all application errors
â”‚   â”‚   2. InfrastructureError - External system failures
â”‚   â”‚   3. DomainError - Business logic violations
â”‚   â”‚   """
â”‚   â”‚   
â”‚   â”‚   from typing import Any, Dict, Optional
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class GlamBaseError(Exception):
â”‚   â”‚       """
â”‚   â”‚       Base class for all glam-app errors.
â”‚   â”‚   
â”‚   â”‚       Attributes:
â”‚   â”‚           code: Stable error code for clients (e.g., "VALIDATION_ERROR")
â”‚   â”‚           status: HTTP status code (default 500)
â”‚   â”‚           message: Human-readable error message
â”‚   â”‚           details: Additional error context
â”‚   â”‚           __cause__: Original exception if wrapped
â”‚   â”‚       """
â”‚   â”‚   
â”‚   â”‚       code: str = "INTERNAL_ERROR"
â”‚   â”‚       status: int = 500
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           code: Optional[str] = None,
â”‚   â”‚           status: Optional[int] = None,
â”‚   â”‚           details: Optional[Dict[str, Any]] = None,
â”‚   â”‚           cause: Optional[Exception] = None
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message)
â”‚   â”‚   
â”‚   â”‚           if code is not None:
â”‚   â”‚               self.code = code
â”‚   â”‚           if status is not None:
â”‚   â”‚               self.status = status
â”‚   â”‚   
â”‚   â”‚           self.message = message
â”‚   â”‚           self.details = details or {}
â”‚   â”‚   
â”‚   â”‚           # Preserve the original exception chain
â”‚   â”‚           if cause is not None:
â”‚   â”‚               self.__cause__ = cause
â”‚   â”‚   
â”‚   â”‚       def to_dict(self) -> Dict[str, Any]:
â”‚   â”‚           """Convert error to dictionary for JSON serialization."""
â”‚   â”‚           result: Dict[str, Any] = {
â”‚   â”‚               "code": self.code,
â”‚   â”‚               "message": self.message,
â”‚   â”‚           }
â”‚   â”‚   
â”‚   â”‚           if self.details:
â”‚   â”‚               result["details"] = self.details
â”‚   â”‚   
â”‚   â”‚           return result
â”‚   â”‚   
â”‚   â”‚   class InfrastructureError(GlamBaseError):
â”‚   â”‚       """
â”‚   â”‚       Infrastructure/external system errors.
â”‚   â”‚   
â”‚   â”‚       These are failures in external dependencies like databases,
â”‚   â”‚       APIs, message queues, etc. They may be retryable.
â”‚   â”‚       """
â”‚   â”‚   
â”‚   â”‚       code = "INFRASTRUCTURE_ERROR"
â”‚   â”‚       status = 503  # Service Unavailable
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           service: Optional[str] = None,
â”‚   â”‚           retryable: bool = True,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if service:
â”‚   â”‚               self.details["service"] = service
â”‚   â”‚   
â”‚   â”‚           self.details["retryable"] = retryable
â”‚   â”‚           self.retryable = retryable
â”‚   â”‚   
â”‚   â”‚   class DomainError(GlamBaseError):
â”‚   â”‚       """
â”‚   â”‚       Domain/business logic errors.
â”‚   â”‚   
â”‚   â”‚       These represent violations of business rules or invalid
â”‚   â”‚       operations within the application domain.
â”‚   â”‚       """
â”‚   â”‚   
â”‚   â”‚       code = "DOMAIN_ERROR"
â”‚   â”‚       status = 400  # Bad Request
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   # Common domain errors used across services
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ValidationError(DomainError):
â”‚   â”‚       """Invalid request data or parameters."""
â”‚   â”‚   
â”‚   â”‚       code = "VALIDATION_ERROR"
â”‚   â”‚       status = 422  # Unprocessable Entity
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           field: Optional[str] = None,
â”‚   â”‚           value: Optional[Any] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if field:
â”‚   â”‚               self.details["field"] = field
â”‚   â”‚           if value is not None:
â”‚   â”‚               self.details["value"] = str(value)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class NotFoundError(DomainError):
â”‚   â”‚       """Requested resource not found."""
â”‚   â”‚   
â”‚   â”‚       code = "NOT_FOUND"
â”‚   â”‚       status = 404
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           resource: Optional[str] = None,
â”‚   â”‚           resource_id: Optional[Any] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if resource:
â”‚   â”‚               self.details["resource"] = resource
â”‚   â”‚           if resource_id is not None:
â”‚   â”‚               self.details["resource_id"] = str(resource_id)
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ConflictError(DomainError):
â”‚   â”‚       """Operation conflicts with current state."""
â”‚   â”‚   
â”‚   â”‚       code = "CONFLICT"
â”‚   â”‚       status = 409
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           conflicting_resource: Optional[str] = None,
â”‚   â”‚           current_state: Optional[str] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if conflicting_resource:
â”‚   â”‚               self.details["conflicting_resource"] = conflicting_resource
â”‚   â”‚           if current_state:
â”‚   â”‚               self.details["current_state"] = current_state
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class UnauthorizedError(DomainError):
â”‚   â”‚       """Authentication required or failed."""
â”‚   â”‚   
â”‚   â”‚       code = "UNAUTHORIZED"
â”‚   â”‚       status = 401
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str = "Authentication required",
â”‚   â”‚           *,
â”‚   â”‚           auth_type: Optional[str] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if auth_type:
â”‚   â”‚               self.details["auth_type"] = auth_type
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ForbiddenError(DomainError):
â”‚   â”‚       """Authenticated but insufficient permissions."""
â”‚   â”‚   
â”‚   â”‚       code = "FORBIDDEN"
â”‚   â”‚       status = 403
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str = "Insufficient permissions",
â”‚   â”‚           *,
â”‚   â”‚           required_permission: Optional[str] = None,
â”‚   â”‚           resource: Optional[str] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if required_permission:
â”‚   â”‚               self.details["required_permission"] = required_permission
â”‚   â”‚           if resource:
â”‚   â”‚               self.details["resource"] = resource
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class RateLimitExceededError(DomainError):
â”‚   â”‚       """Too many requests."""
â”‚   â”‚   
â”‚   â”‚       code = "RATE_LIMITED"
â”‚   â”‚       status = 429
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str = "Rate limit exceeded",
â”‚   â”‚           *,
â”‚   â”‚           limit: Optional[int] = None,
â”‚   â”‚           window: Optional[str] = None,
â”‚   â”‚           retry_after: Optional[int] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if limit:
â”‚   â”‚               self.details["limit"] = limit
â”‚   â”‚           if window:
â”‚   â”‚               self.details["window"] = window
â”‚   â”‚           if retry_after:
â”‚   â”‚               self.details["retry_after"] = retry_after
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class ServiceUnavailableError(InfrastructureError):
â”‚   â”‚       """Service temporarily unavailable."""
â”‚   â”‚   
â”‚   â”‚       code = "SERVICE_UNAVAILABLE"
â”‚   â”‚       status = 503
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class RequestTimeoutError(InfrastructureError):
â”‚   â”‚       """Operation timed out."""
â”‚   â”‚   
â”‚   â”‚       code = "TIMEOUT"
â”‚   â”‚       status = 504
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           timeout_seconds: Optional[float] = None,
â”‚   â”‚           operation: Optional[str] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if timeout_seconds:
â”‚   â”‚               self.details["timeout_seconds"] = timeout_seconds
â”‚   â”‚           if operation:
â”‚   â”‚               self.details["operation"] = operation
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   class InternalError(GlamBaseError):
â”‚   â”‚       """Unexpected internal server error."""
â”‚   â”‚   
â”‚   â”‚       code = "INTERNAL_ERROR"
â”‚   â”‚       status = 500
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str = "An unexpected error occurred",
â”‚   â”‚           *,
â”‚   â”‚           error_id: Optional[str] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           # Never expose internal details in production
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if error_id:
â”‚   â”‚               self.details["error_id"] = error_id
â”‚   â”‚               
â”‚   â”‚               
â”‚   â”‚   class ConfigurationError(GlamBaseError):
â”‚   â”‚       """Configuration errors in the application."""
â”‚   â”‚   
â”‚   â”‚       code = "CONFIGURATION_ERROR"
â”‚   â”‚       status = 500
â”‚   â”‚   
â”‚   â”‚       def __init__(
â”‚   â”‚           self,
â”‚   â”‚           message: str,
â”‚   â”‚           *,
â”‚   â”‚           config_key: Optional[str] = None,
â”‚   â”‚           expected_value: Optional[Any] = None,
â”‚   â”‚           **kwargs
â”‚   â”‚       ):
â”‚   â”‚           super().__init__(message, **kwargs)
â”‚   â”‚   
â”‚   â”‚           if config_key:
â”‚   â”‚               self.details["config_key"] = config_key
â”‚   â”‚           if expected_value is not None:
â”‚   â”‚               self.details["expected_value"] = expected_value
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â”œâ”€â”€ idempotency_key.py
â”‚   â”‚   
â”‚   â”‚   ```py
â”‚   â”‚   # shared/utils/idempotency.py
â”‚   â”‚   """Simple idempotency key generator."""
â”‚   â”‚   
â”‚   â”‚   from typing import Union, Optional
â”‚   â”‚   from uuid import UUID
â”‚   â”‚   
â”‚   â”‚   
â”‚   â”‚   def generate_idempotency_key(
â”‚   â”‚       system: str,
â”‚   â”‚       operation_type: str, 
â”‚   â”‚       identifier: Union[str, int, UUID],
â”‚   â”‚       extra: Optional[str] = None
â”‚   â”‚   ) -> str:
â”‚   â”‚       """
â”‚   â”‚       Generate idempotency key: SYSTEM_OPERATION_ID[_EXTRA]
â”‚   â”‚       
â”‚   â”‚       Examples:
â”‚   â”‚           generate_idempotency_key("SHOPIFY", "ORDER", "123456") 
â”‚   â”‚           â†’ "SHOPIFY_ORDER_123456"
â”‚   â”‚           
â”‚   â”‚           generate_idempotency_key("STRIPE", "PAYMENT", "pi_abc123")
â”‚   â”‚           â†’ "STRIPE_PAYMENT_pi_abc123"
â”‚   â”‚           
â”‚   â”‚           generate_idempotency_key("SHOPIFY", "ORDER", "123", "TESTSTORE")
â”‚   â”‚           â†’ "SHOPIFY_ORDER_123_TESTSTORE"
â”‚   â”‚       """
â”‚   â”‚       # Normalize inputs
â”‚   â”‚       system = str(system).upper().replace('-', '_').replace('.', '_')
â”‚   â”‚       operation_type = str(operation_type).upper().replace('-', '_').replace('.', '_')
â”‚   â”‚       identifier = str(identifier)
â”‚   â”‚       
â”‚   â”‚       # Build key
â”‚   â”‚       parts = [system, operation_type, identifier]
â”‚   â”‚       
â”‚   â”‚       if extra:
â”‚   â”‚           parts.append(str(extra).upper().replace('-', '_').replace('.', '_'))
â”‚   â”‚       
â”‚   â”‚       return '_'.join(parts)
â”‚   â”‚   ```
â”‚   â”‚   
â”‚   â””â”€â”€ logger.py
â”‚       
â”‚       ```py
â”‚       # shared/utils/logger.py
â”‚       import logging
â”‚       import sys
â”‚       from typing import Dict, Any
â”‚       
â”‚       class ServiceLogger:
â”‚           """Service logger that wraps Python's standard logger"""
â”‚           
â”‚           def __init__(self, service_name: str):
â”‚               self.service_name = service_name
â”‚               self.logger = logging.getLogger(service_name)
â”‚               self._request_context: Dict[str, Any] = {}
â”‚               
â”‚               # Only add handler if root logger has no handlers
â”‚               # This prevents duplicate handlers in reload
â”‚               if not logging.root.handlers:
â”‚                   handler = logging.StreamHandler(sys.stdout)
â”‚                   formatter = logging.Formatter(
â”‚                       '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
â”‚                       datefmt='%Y-%m-%d %H:%M:%S'
â”‚                   )
â”‚                   handler.setFormatter(formatter)
â”‚                   logging.root.addHandler(handler)
â”‚                   logging.root.setLevel(logging.INFO)
â”‚           
â”‚           def set_request_context(self, **kwargs):
â”‚               """Set request-scoped context"""
â”‚               self._request_context = kwargs
â”‚           
â”‚           def clear_request_context(self):
â”‚               """Clear request context"""
â”‚               self._request_context = {}
â”‚           
â”‚           def _add_context(self, extra: Dict = None) -> Dict:
â”‚               """Add request context to extra fields"""
â”‚               combined = self._request_context.copy()
â”‚               if extra:
â”‚                   combined.update(extra)
â”‚               return combined if combined else None
â”‚           
â”‚           def info(self, msg, *args, **kwargs):
â”‚               extra = kwargs.pop('extra', None)
â”‚               self.logger.info(msg, *args, extra=self._add_context(extra), **kwargs)
â”‚           
â”‚           def error(self, msg, *args, **kwargs):
â”‚               extra = kwargs.pop('extra', None)
â”‚               self.logger.error(msg, *args, extra=self._add_context(extra), **kwargs)
â”‚           
â”‚           def warning(self, msg, *args, **kwargs):
â”‚               extra = kwargs.pop('extra', None)
â”‚               self.logger.warning(msg, *args, extra=self._add_context(extra), **kwargs)
â”‚           
â”‚           def debug(self, msg, *args, **kwargs):
â”‚               extra = kwargs.pop('extra', None)
â”‚               self.logger.debug(msg, *args, extra=self._add_context(extra), **kwargs)
â”‚           
â”‚           def critical(self, msg, *args, **kwargs):
â”‚               extra = kwargs.pop('extra', None)
â”‚               self.logger.critical(msg, *args, extra=self._add_context(extra), **kwargs)
â”‚       
â”‚       def create_logger(service_name: str) -> ServiceLogger:
â”‚           return ServiceLogger(service_name)
â”‚       ```
â”‚       
â””â”€â”€ __init__.py
tests/
â””â”€â”€ __init__.py
.python-version
poetry.lock
pyproject.toml

```toml
# shared/pyproject.toml
[tool.poetry]
name = "shared"
version = "0.1.0"
description = "Shared utilities for GLAM system services"
authors = ["GLAM Team <team@glam.com>"]
package-mode = true

[tool.poetry.dependencies]
python = "^3.11"
nats-py = "^2.6.0"
pydantic = "^2.5.0"
python-json-logger = "^2.0.7"
tenacity = "^8.2.3"
pydantic-settings = "^2.10.1"
asyncio = "^3.4.3"
python-dotenv = "^1.1.1"
uuid7 = "^0.1.0"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
```

README.md

================================================================================
Output includes file contents
================================================================================