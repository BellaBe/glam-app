================================================================================
Directory Structure: /home/bellabe/glam-app/services/billing-service
================================================================================

billing-service/
prisma/
├── migrations/
│   ├── 20250819044228_code/
│   │   └── migration.sql
│   │
│   │       ```sql
│   │       -- CreateEnum
│   │       CREATE TYPE "PurchaseStatus" AS ENUM ('pending', 'completed', 'failed', 'expired');
│   │
│   │       -- CreateTable
│   │       CREATE TABLE "billing_records" (
│   │           "id" UUID NOT NULL,
│   │           "merchant_id" UUID NOT NULL,
│   │           "trial_available" BOOLEAN NOT NULL DEFAULT true,
│   │           "trial_started_at" TIMESTAMPTZ(3),
│   │           "trial_ends_at" TIMESTAMPTZ(3),
│   │           "total_credits_purchased" INTEGER NOT NULL DEFAULT 0,
│   │           "last_purchase_at" TIMESTAMPTZ(3),
│   │           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updated_at" TIMESTAMPTZ(3) NOT NULL,
│   │
│   │           CONSTRAINT "billing_records_pkey" PRIMARY KEY ("id")
│   │       );
│   │
│   │       -- CreateTable
│   │       CREATE TABLE "credit_purchases" (
│   │           "id" UUID NOT NULL,
│   │           "merchant_id" UUID NOT NULL,
│   │           "credits" INTEGER NOT NULL,
│   │           "amount" TEXT NOT NULL,
│   │           "status" "PurchaseStatus" NOT NULL DEFAULT 'pending',
│   │           "platform" TEXT,
│   │           "platform_charge_id" TEXT,
│   │           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "completed_at" TIMESTAMPTZ(3),
│   │           "expires_at" TIMESTAMPTZ(3),
│   │
│   │           CONSTRAINT "credit_purchases_pkey" PRIMARY KEY ("id")
│   │       );
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "billing_records_merchant_id_key" ON "billing_records"("merchant_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "billing_records_trial_ends_at_idx" ON "billing_records"("trial_ends_at");
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "credit_purchases_platform_charge_id_key" ON "credit_purchases"("platform_charge_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_purchases_merchant_id_idx" ON "credit_purchases"("merchant_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_purchases_status_idx" ON "credit_purchases"("status");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "credit_purchases_platform_charge_id_idx" ON "credit_purchases"("platform_charge_id");
│   │
│   │       -- AddForeignKey
│   │       ALTER TABLE "credit_purchases" ADD CONSTRAINT "credit_purchases_merchant_id_fkey" FOREIGN KEY ("merchant_id") REFERENCES "billing_records"("merchant_id") ON DELETE RESTRICT ON UPDATE CASCADE;
│   │       ```
│   │
│   └── migration_lock.toml
│
│       ```toml
│       # Please do not edit this file manually
│       # It should be added in your version-control system (i.e. Git)
│       provider = "postgresql"
│       ```
│
└── schema.prisma
src/
├── api/
│   ├── v1/
│   │   ├── __init__.py
│   │   │
│   │   │   ```py
│   │   │   # services/billing-service/src/api/v1/__init__.py
│   │   │   from fastapi import APIRouter
│   │   │
│   │   │   from .billing import billing_router
│   │   │   from .purchases import purchases_router
│   │   │   from .trials import trials_router
│   │   │
│   │   │   v1_router = APIRouter()
│   │   │   v1_router.include_router(billing_router, prefix="/billing", tags=["billing"])
│   │   │   v1_router.include_router(purchases_router, prefix="/billing/purchases", tags=["purchases"])
│   │   │   v1_router.include_router(trials_router, prefix="/billing/trials", tags=["trials"])
│   │   │   ```
│   │   │
│   │   ├── billing.py
│   │   │
│   │   │   ```py
│   │   │   from uuid import UUID
│   │   │
│   │   │   from fastapi import APIRouter
│   │   │
│   │   │   from shared.api import ApiResponse, success_response
│   │   │   from shared.api.dependencies import ClientAuthDep, PlatformContextDep, RequestContextDep
│   │   │
│   │   │   from ...dependencies import BillingServiceDep
│   │   │   from ...schemas.billing import BillingStatusOut
│   │   │
│   │   │   billing_router = APIRouter()
│   │   │
│   │   │
│   │   │   @billing_router.get(
│   │   │       "",
│   │   │       response_model=ApiResponse[BillingStatusOut],
│   │   │       summary="Get overall billing status",
│   │   │   )
│   │   │   async def get_billing_status(
│   │   │       billing_service: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       auth: ClientAuthDep,
│   │   │       platform: PlatformContextDep,
│   │   │   ):
│   │   │       """Get overall billing status for merchant"""
│   │   │       merchant_id = UUID(auth.shop)
│   │   │
│   │   │       result = await billing_service.get_billing_status(merchant_id)
│   │   │
│   │   │       return success_response(data=result, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │   │   ```
│   │   │
│   │   ├── purchases.py
│   │   │
│   │   │   ```py
│   │   │   from uuid import UUID
│   │   │
│   │   │   from fastapi import APIRouter, Body, Path, status
│   │   │
│   │   │   from shared.api import ApiResponse, success_response
│   │   │   from shared.api.dependencies import ClientAuthDep, PlatformContextDep, RequestContextDep
│   │   │
│   │   │   from ...dependencies import PurchaseServiceDep
│   │   │   from ...schemas.billing import PurchaseCreatedOut, PurchaseCreateIn, PurchaseOut
│   │   │
│   │   │   purchases_router = APIRouter(prefix="/purchases", tags=["Purchases"])
│   │   │
│   │   │
│   │   │   @purchases_router.post(
│   │   │       "",
│   │   │       response_model=ApiResponse[PurchaseCreatedOut],
│   │   │       status_code=status.HTTP_201_CREATED,
│   │   │       summary="Create credit purchase",
│   │   │   )
│   │   │   async def create_purchase(
│   │   │       purchase_service: PurchaseServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       auth: ClientAuthDep,
│   │   │       platform: PlatformContextDep,
│   │   │       body: PurchaseCreateIn = Body(...),
│   │   │   ):
│   │   │       """Create credit pack purchase"""
│   │   │       merchant_id = UUID(auth.shop)
│   │   │
│   │   │       result = await purchase_service.create_purchase(merchant_id=merchant_id, domain=platform.domain, data=body)
│   │   │
│   │   │       return success_response(data=result, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │   │
│   │   │
│   │   │   @purchases_router.get("", response_model=ApiResponse[list[PurchaseOut]], summary="List purchases")
│   │   │   async def list_purchases(
│   │   │       purchase_service: PurchaseServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       auth: ClientAuthDep,
│   │   │       platform: PlatformContextDep,
│   │   │   ):
│   │   │       """List purchases for merchant"""
│   │   │       merchant_id = UUID(auth.shop)
│   │   │
│   │   │       purchases = await purchase_service.list_purchases(merchant_id)
│   │   │
│   │   │       return success_response(data=purchases, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │   │
│   │   │
│   │   │   @purchases_router.get("/{purchase_id}", response_model=ApiResponse[PurchaseOut], summary="Get purchase")
│   │   │   async def get_purchase(
│   │   │       purchase_service: PurchaseServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       auth: ClientAuthDep,
│   │   │       purchase_id: UUID = Path(...),
│   │   │   ):
│   │   │       """Get single purchase by ID"""
│   │   │       result = await purchase_service.get_purchase(purchase_id)
│   │   │
│   │   │       return success_response(data=result, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │   │   ```
│   │   │
│   │   └── trials.py
│   │
│   │       ```py
│   │       from uuid import UUID
│   │
│   │       from fastapi import APIRouter, Body, status
│   │
│   │       from shared.api import ApiResponse, success_response
│   │       from shared.api.dependencies import ClientAuthDep, PlatformContextDep, RequestContextDep
│   │
│   │       from ...dependencies import BillingServiceDep
│   │       from ...schemas.billing import TrialActivatedOut, TrialActivateIn, TrialStatusOut
│   │
│   │       trials_router = APIRouter(prefix="/api/billing/trials", tags=["Trials"])
│   │
│   │
│   │       @trials_router.post(
│   │           "",
│   │           response_model=ApiResponse[TrialActivatedOut],
│   │           status_code=status.HTTP_201_CREATED,
│   │           summary="Activate trial",
│   │       )
│   │       async def activate_trial(
│   │           billing_service: BillingServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: ClientAuthDep,
│   │           platform: PlatformContextDep,
│   │           body: TrialActivateIn = Body(None),
│   │       ):
│   │           """Activate trial for merchant"""
│   │           # Use shop domain as merchant ID for now
│   │           merchant_id = UUID(auth.shop)  # In production, lookup merchant by domain
│   │
│   │           result = await billing_service.activate_trial(
│   │               merchant_id=merchant_id, idempotency_key=body.idempotency_key if body else None
│   │           )
│   │
│   │           return success_response(data=result, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │
│   │
│   │       @trials_router.get("", response_model=ApiResponse[TrialStatusOut], summary="Get trial status")
│   │       async def get_trial_status(
│   │           billing_service: BillingServiceDep,
│   │           ctx: RequestContextDep,
│   │           auth: ClientAuthDep,
│   │           platform: PlatformContextDep,
│   │       ):
│   │           """Get trial status for merchant"""
│   │           merchant_id = UUID(auth.shop)
│   │
│   │           result = await billing_service.get_trial_status(merchant_id)
│   │
│   │           return success_response(data=result, request_id=ctx.request_id, correlation_id=ctx.correlation_id)
│   │       ```
│   │
│   └── __init__.py
│
│       ```py
│       # services/billing-service/src/api/__init__.py
│
│       from fastapi import APIRouter
│
│       from .v1 import v1_router
│
│       api_router = APIRouter(prefix="/api")
│
│       # Include v1 routes
│       api_router.include_router(v1_router)
│       ```
│
├── events/
│   ├── __init__.py
│   ├── listeners.py
│   │
│   │   ```py
│   │   # services/billing-service/src/events/listeners.py
│   │   """NATS listeners for billing service events."""
│   │
│   │   from shared.messaging.jetstream_client import JetStreamClient
│   │   from shared.messaging.listener import Listener
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │   from ..schemas.billing import MerchantCreatedPayload, PurchaseWebhookPayload
│   │   from ..services.billing_service import BillingService
│   │   from ..services.purchase_service import PurchaseService
│   │
│   │
│   │   class MerchantCreatedListener(Listener):
│   │       """Listen for merchant created events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.merchant.created.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "billing-merchant-created"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "billing-service"
│   │
│   │       def __init__(
│   │           self,
│   │           js_client: JetStreamClient,
│   │           billing_service: BillingService,
│   │           logger: ServiceLogger,
│   │       ):
│   │           super().__init__(js_client, logger)
│   │           self.billing_service = billing_service
│   │
│   │       async def on_message(self, data: dict) -> None:
│   │           """Handle merchant created event"""
│   │           try:
│   │               payload = MerchantCreatedPayload(**data)
│   │               await self.billing_service.create_billing_record(payload.merchant_id)
│   │           except Exception as e:
│   │               self.logger.exception(f"Failed to process merchant created: {e}")
│   │               raise  # Will NACK for retry
│   │
│   │
│   │   class PurchaseWebhookListener(Listener):
│   │       """Listen for purchase webhook events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return "evt.webhook.app.purchase_updated.v1"
│   │
│   │       @property
│   │       def queue_group(self) -> str:
│   │           return "billing-purchase-webhook"
│   │
│   │       @property
│   │       def service_name(self) -> str:
│   │           return "billing-service"
│   │
│   │       def __init__(
│   │           self,
│   │           js_client: JetStreamClient,
│   │           purchase_service: PurchaseService,
│   │           logger: ServiceLogger,
│   │       ):
│   │           super().__init__(js_client, logger)
│   │           self.purchase_service = purchase_service
│   │
│   │       async def on_message(self, data: dict) -> None:
│   │           """Handle purchase webhook event"""
│   │           try:
│   │               payload = PurchaseWebhookPayload(**data)
│   │               await self.purchase_service.handle_purchase_webhook(
│   │                   charge_id=payload.charge_id,
│   │                   status=payload.status,
│   │                   merchant_id=payload.merchant_id,
│   │               )
│   │           except Exception as e:
│   │               self.logger.exception(f"Failed to process purchase webhook: {e}")
│   │               # Don't retry webhooks - they're usually duplicates
│   │               return
│   │   ```
│   │
│   └── publishers.py
│
│       ```py
│       # billing-service/src/events/publishers.py
│       from datetime import UTC, datetime
│
│       from shared.messaging.publisher import Publisher
│       from shared.messaging.subjects import Subjects
│
│       from ..schemas.billing import CreditsPurchasedPayload, TrialExpiredPayload, TrialStartedPayload
│
│
│       class BillingEventPublisher(Publisher):
│           """Publisher for billing domain events"""
│
│           @property
│           def service_name(self) -> str:
│               return "billing-service"
│
│           async def trial_started(self, payload: TrialStartedPayload) -> str:
│               """Publish trial started event"""
│               self.logger.info(
│                   "Publishing trial started event",
│                   extra={
│                       "merchant_id": payload.merchant_id,
│                       "trial_start_date": datetime.now(UTC).isoformat(),
│                   },
│               )
│               return await self.publish_event(subject=Subjects.BILLING_TRIAL_STARTED, data=payload.model_dump(mode="json"))
│
│           async def trial_expired(self, payload: TrialExpiredPayload) -> str:
│               """Publish trial expired event"""
│               self.logger.info(
│                   "Publishing trial expired event",
│                   extra={"merchant_id": payload.merchant_id, "trial_end_date": payload.expired_at.isoformat()},
│               )
│               return await self.publish_event(subject=Subjects.BILLING_TRIAL_EXPIRED, data=payload.model_dump(mode="json"))
│
│           async def credits_purchased(self, payload: CreditsPurchasedPayload) -> str:
│               """Publish credits purchased event"""
│               self.logger.info(
│                   "Publishing credits purchased event",
│                   extra={
│                       "merchant_id": payload.merchant_id,
│                       "credits": payload.credits,
│                       "amount": payload.amount,
│                       "platform": payload.platform,
│                   },
│               )
│               return await self.publish_event(
│                   subject=Subjects.BILLING_CREDITS_PURCHASED, data=payload.model_dump(mode="json")
│               )
│       ```
│
├── repositories/
│   ├── __init__.py
│   ├── billing_repository.py
│   │
│   │   ```py
│   │   from datetime import datetime, timedelta
│   │   from uuid import UUID
│   │
│   │   from prisma import Prisma  # type: ignore[attr-defined]
│   │   from prisma.models import BillingRecord
│   │
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │
│   │   class BillingRepository:
│   │       """Repository for billing record operations"""
│   │
│   │       def __init__(self, prisma: Prisma, logger: ServiceLogger):
│   │           self.prisma = prisma
│   │           self.logger = logger
│   │
│   │       async def create(self, merchant_id: UUID) -> BillingRecord:
│   │           """Create new billing record"""
│   │           return await self.prisma.billingrecord.create(
│   │               data={"merchant_id": str(merchant_id), "trial_available": True, "total_credits_purchased": 0}
│   │           )
│   │
│   │       async def find_by_merchant_id(self, merchant_id: UUID) -> BillingRecord | None:
│   │           """Find billing record by merchant ID"""
│   │           return await self.prisma.billingrecord.find_unique(where={"merchant_id": str(merchant_id)})
│   │
│   │       async def activate_trial(self, merchant_id: UUID, duration_days: int = 14) -> BillingRecord:
│   │           """Activate trial for merchant"""
│   │           now = datetime.utcnow()
│   │           ends_at = now + timedelta(days=duration_days)
│   │
│   │           return await self.prisma.billingrecord.update(
│   │               where={"merchant_id": str(merchant_id)},
│   │               data={"trial_available": False, "trial_started_at": now, "trial_ends_at": ends_at},
│   │           )
│   │
│   │       async def update_purchase_totals(self, merchant_id: UUID, credits: int) -> BillingRecord:
│   │           """Update purchase totals after successful purchase"""
│   │           return await self.prisma.billingrecord.update(
│   │               where={"merchant_id": str(merchant_id)},
│   │               data={"total_credits_purchased": {"increment": credits}, "last_purchase_at": datetime.utcnow()},
│   │           )
│   │
│   │       async def find_expired_trials(self) -> list[BillingRecord]:
│   │           """Find all expired trials that haven't been processed"""
│   │           return await self.prisma.billingrecord.find_many(
│   │               where={
│   │                   "trial_ends_at": {"lte": datetime.utcnow()},
│   │                   "trial_available": False,
│   │                   "trial_started_at": {"not": None},
│   │               }
│   │           )
│   │   ```
│   │
│   └── purchase_repository.py
│
│       ```py
│       from datetime import datetime, timedelta
│       from uuid import UUID
│
│       from prisma import Prisma  # type: ignore[attr-defined]
│       from prisma.enums import PurchaseStatus
│       from prisma.models import CreditPurchase
│
│       from shared.utils.logger import ServiceLogger
│
│
│       class PurchaseRepository:
│           """Repository for credit purchase operations"""
│
│           def __init__(self, prisma: Prisma, logger: ServiceLogger):
│               self.prisma = prisma
│               self.logger = logger
│
│           async def create(
│               self, merchant_id: UUID, credits: int, amount: str, platform: str, expiry_hours: int = 24
│           ) -> CreditPurchase:
│               """Create new purchase record"""
│               expires_at = datetime.utcnow() + timedelta(hours=expiry_hours)
│
│               return await self.prisma.creditpurchase.create(
│                   data={
│                       "merchant_id": str(merchant_id),
│                       "credits": credits,
│                       "amount": amount,
│                       "status": PurchaseStatus.pending,
│                       "platform": platform,
│                       "expires_at": expires_at,
│                   }
│               )
│
│           async def find_by_id(self, purchase_id: UUID) -> CreditPurchase | None:
│               """Find purchase by ID"""
│               return await self.prisma.creditpurchase.find_unique(where={"id": str(purchase_id)})
│
│           async def find_by_charge_id(self, charge_id: str) -> CreditPurchase | None:
│               """Find purchase by platform charge ID"""
│               return await self.prisma.creditpurchase.find_unique(where={"platform_charge_id": charge_id})
│
│           async def find_by_merchant(self, merchant_id: UUID, limit: int = 10) -> list[CreditPurchase]:
│               """Find purchases for merchant"""
│               return await self.prisma.creditpurchase.find_many(
│                   where={"merchant_id": str(merchant_id)}, order_by={"created_at": "desc"}, take=limit
│               )
│
│           async def update_platform_charge_id(self, purchase_id: UUID, charge_id: str) -> CreditPurchase:
│               """Update platform charge ID"""
│               return await self.prisma.creditpurchase.update(
│                   where={"id": str(purchase_id)}, data={"platform_charge_id": charge_id}
│               )
│
│           async def complete_purchase(self, purchase_id: UUID) -> CreditPurchase:
│               """Mark purchase as completed"""
│               return await self.prisma.creditpurchase.update(
│                   where={"id": str(purchase_id)}, data={"status": PurchaseStatus.completed, "completed_at": datetime.utcnow()}
│               )
│
│           async def fail_purchase(self, purchase_id: UUID) -> CreditPurchase:
│               """Mark purchase as failed"""
│               return await self.prisma.creditpurchase.update(
│                   where={"id": str(purchase_id)}, data={"status": PurchaseStatus.failed}
│               )
│
│           async def expire_pending_purchases(self) -> int:
│               """Expire all pending purchases past expiry time"""
│               result = await self.prisma.creditpurchase.update_many(
│                   where={"status": PurchaseStatus.pending, "expires_at": {"lte": datetime.utcnow()}},
│                   data={"status": PurchaseStatus.expired},
│               )
│               return result
│       ```
│
├── schemas/
│   ├── __init__.py
│   └── billing.py
│
│       ```py
│       from datetime import datetime
│       from enum import Enum
│       from uuid import UUID
│
│       from pydantic import BaseModel, ConfigDict
│
│
│       # ---------- ENUMS ----------
│       class CreditPack(str, Enum):
│           SMALL = "small"
│           MEDIUM = "medium"
│           LARGE = "large"
│
│
│       class Platform(str, Enum):
│           SHOPIFY = "shopify"
│           STRIPE = "stripe"
│           CUSTOM = "custom"
│
│
│       class PurchaseStatus(str, Enum):
│           PENDING = "pending"
│           COMPLETED = "completed"
│           FAILED = "failed"
│           EXPIRED = "expired"
│
│
│       # ---------- INPUT DTOs ----------
│       class TrialActivateIn(BaseModel):
│           """Input for activating trial"""
│
│           idempotency_key: str | None = None
│           model_config = ConfigDict(extra="forbid")
│
│
│       class PurchaseCreateIn(BaseModel):
│           """Input for creating credit purchase"""
│
│           pack: CreditPack
│           platform: Platform
│           return_url: str
│           idempotency_key: str | None = None
│           model_config = ConfigDict(extra="forbid")
│
│
│       # ---------- OUTPUT DTOs ----------
│       class TrialStatusOut(BaseModel):
│           """Trial status response"""
│
│           available: bool
│           active: bool
│           ends_at: datetime | None = None
│           started_at: datetime | None = None
│           model_config = ConfigDict(from_attributes=True)
│
│
│       class TrialActivatedOut(BaseModel):
│           """Trial activation response"""
│
│           success: bool = True
│           ends_at: datetime
│           credits_granted: int
│           model_config = ConfigDict(from_attributes=True)
│
│
│       class PurchaseOut(BaseModel):
│           """Credit purchase response"""
│
│           id: UUID
│           merchant_id: UUID
│           credits: int
│           amount: str
│           status: PurchaseStatus
│           platform: str | None = None
│           platform_charge_id: str | None = None
│           created_at: datetime
│           completed_at: datetime | None = None
│           expires_at: datetime | None = None
│           model_config = ConfigDict(from_attributes=True)
│
│
│       class PurchaseCreatedOut(BaseModel):
│           """Purchase creation response"""
│
│           purchase_id: UUID
│           checkout_url: str
│           expires_at: datetime
│           model_config = ConfigDict(from_attributes=True)
│
│
│       class BillingStatusOut(BaseModel):
│           """Overall billing status"""
│
│           trial: TrialStatusOut
│           credits_purchased: int
│           last_purchase_at: datetime | None = None
│           recent_purchases: list[PurchaseOut] = []
│           model_config = ConfigDict(from_attributes=True)
│
│
│       # ---------- EVENT PAYLOADS ----------
│       class TrialStartedPayload(BaseModel):
│           """Trial started event payload"""
│
│           merchant_id: UUID
│           ends_at: datetime
│           credits: int = 500
│
│
│       class TrialExpiredPayload(BaseModel):
│           """Trial expired event payload"""
│
│           merchant_id: UUID
│           expired_at: datetime
│
│
│       class CreditsPurchasedPayload(BaseModel):
│           """Credits purchased event payload"""
│
│           merchant_id: UUID
│           purchase_id: UUID
│           credits: int
│           amount: str
│           platform: str
│
│
│       class MerchantCreatedPayload(BaseModel):
│           """Merchant created event payload (consumed)"""
│
│           merchant_id: UUID
│           platform_name: str
│           platform_shop_id: str
│           domain: str
│           name: str
│           email: str
│           installed_at: datetime
│
│
│       class PurchaseWebhookPayload(BaseModel):
│           """Purchase webhook payload (consumed)"""
│
│           charge_id: str
│           status: str
│           merchant_id: UUID
│       ```
│
├── services/
│   ├── __init__.py
│   ├── billing_service.py
│   │
│   │   ```py
│   │   from datetime import datetime
│   │   from uuid import UUID
│   │
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │   from ..config import ServiceConfig
│   │   from ..events.publishers import BillingEventPublisher
│   │   from ..exceptions import MerchantNotFoundError, TrialAlreadyUsedError
│   │   from ..repositories.billing_repository import BillingRepository
│   │   from ..repositories.purchase_repository import PurchaseRepository
│   │   from ..schemas.billing import (
│   │       BillingStatusOut,
│   │       TrialActivatedOut,
│   │       TrialExpiredPayload,
│   │       TrialStartedPayload,
│   │       TrialStatusOut,
│   │   )
│   │
│   │
│   │   class BillingService:
│   │       """Service for billing operations"""
│   │
│   │       def __init__(
│   │           self,
│   │           config: ServiceConfig,
│   │           billing_repo: BillingRepository,
│   │           purchase_repo: PurchaseRepository,
│   │           publisher: BillingEventPublisher,
│   │           logger: ServiceLogger,
│   │       ):
│   │           self.config = config
│   │           self.billing_repo = billing_repo
│   │           self.purchase_repo = purchase_repo
│   │           self.publisher = publisher
│   │           # self.redis = redis_client
│   │           self.logger = logger
│   │
│   │       async def create_billing_record(self, merchant_id: UUID) -> None:
│   │           """Create billing record for new merchant"""
│   │           try:
│   │               existing = await self.billing_repo.find_by_merchant_id(merchant_id)
│   │               if existing:
│   │                   self.logger.info(f"Billing record already exists for merchant {merchant_id}")
│   │                   return
│   │
│   │               await self.billing_repo.create(merchant_id)
│   │               self.logger.info(f"Created billing record for merchant {merchant_id}")
│   │
│   │           except Exception as e:
│   │               self.logger.exception(f"Failed to create billing record: {e}")
│   │               raise
│   │
│   │       async def get_trial_status(self, merchant_id: UUID) -> TrialStatusOut:
│   │           """Get trial status for merchant"""
│   │           record = await self.billing_repo.find_by_merchant_id(merchant_id)
│   │           if not record:
│   │               raise MerchantNotFoundError(str(merchant_id))
│   │
│   │           # Determine if trial is active
│   │           active = (
│   │               not record.trial_available
│   │               and record.trial_started_at is not None
│   │               and record.trial_ends_at is not None
│   │               and record.trial_ends_at > datetime.utcnow()
│   │           )
│   │
│   │           return TrialStatusOut(
│   │               available=record.trial_available,
│   │               active=active,
│   │               started_at=record.trial_started_at,
│   │               ends_at=record.trial_ends_at,
│   │           )
│   │
│   │       async def activate_trial(self, merchant_id: UUID, idempotency_key: str | None = None) -> TrialActivatedOut:
│   │           """Activate trial for merchant"""
│   │           # Check idempotency
│   │           # if idempotency_key:
│   │           #     cache_key = f"trial:{idempotency_key}"
│   │           #     cached = await self.redis.get(cache_key)
│   │           #     if cached:
│   │           #         import json
│   │
│   │           #         return TrialActivatedOut(**json.loads(cached))
│   │
│   │           # Get billing record
│   │           record = await self.billing_repo.find_by_merchant_id(merchant_id)
│   │           if not record:
│   │               raise MerchantNotFoundError(str(merchant_id))
│   │
│   │           # Check if trial already used
│   │           if not record.trial_available:
│   │               raise TrialAlreadyUsedError(str(merchant_id))
│   │
│   │           # Activate trial
│   │           updated = await self.billing_repo.activate_trial(merchant_id, self.config.trial_duration_days)
│   │
│   │           # Publish event
│   │           await self.publisher.trial_started(
│   │               TrialStartedPayload(
│   │                   merchant_id=merchant_id, ends_at=updated.trial_ends_at, credits=self.config.trial_credits
│   │               )
│   │           )
│   │
│   │           # Create response
│   │           response = TrialActivatedOut(
│   │               success=True, ends_at=updated.trial_ends_at, credits_granted=self.config.trial_credits
│   │           )
│   │
│   │           # Cache for idempotency
│   │           # if idempotency_key:
│   │           #     cache_key = f"trial:{idempotency_key}"
│   │           #     await self.redis.setex(
│   │           #         cache_key,
│   │           #         86400,  # 24 hours
│   │           #         response.model_dump_json(),
│   │           #     )
│   │
│   │           return response
│   │
│   │       async def get_billing_status(self, merchant_id: UUID) -> BillingStatusOut:
│   │           """Get overall billing status"""
│   │           record = await self.billing_repo.find_by_merchant_id(merchant_id)
│   │           if not record:
│   │               raise MerchantNotFoundError(str(merchant_id))
│   │
│   │           # Get trial status
│   │           trial = await self.get_trial_status(merchant_id)
│   │
│   │           # Get recent purchases
│   │           purchases = await self.purchase_repo.find_by_merchant(merchant_id, limit=5)
│   │
│   │           return BillingStatusOut(
│   │               trial=trial,
│   │               credits_purchased=record.total_credits_purchased,
│   │               last_purchase_at=record.last_purchase_at,
│   │               recent_purchases=purchases,
│   │           )
│   │
│   │       async def check_expired_trials(self) -> None:
│   │           """Check and process expired trials (cron job)"""
│   │           expired_records = await self.billing_repo.find_expired_trials()
│   │
│   │           for record in expired_records:
│   │               try:
│   │                   payload = TrialExpiredPayload(merchant_id=UUID(record.merchant_id), expired_at=record.trial_ends_at)
│   │                   await self.publisher.trial_expired(payload)
│   │
│   │                   self.logger.info(f"Published trial expired event for merchant {record.merchant_id}")
│   │
│   │               except Exception as e:
│   │                   self.logger.exception(f"Failed to process expired trial: {e}")
│   │   ```
│   │
│   └── purchase_service.py
│
│       ```py
│       from uuid import UUID
│
│       from shared.utils.logger import ServiceLogger
│
│       from ..config import ServiceConfig
│       from ..events.publishers import BillingEventPublisher
│       from ..exceptions import InvalidCreditPackError, MerchantNotFoundError, PlatformCheckoutError, PurchaseNotFoundError
│       from ..repositories.billing_repository import BillingRepository
│       from ..repositories.purchase_repository import PurchaseRepository
│       from ..schemas.billing import CreditsPurchasedPayload, Platform, PurchaseCreatedOut, PurchaseCreateIn, PurchaseOut
│       from ..utils.credit_packs import CreditPackManager
│       from ..utils.shopify_client import ShopifyClient
│
│
│       class PurchaseService:
│           """Service for purchase operations"""
│
│           def __init__(
│               self,
│               config: ServiceConfig,
│               billing_repo: BillingRepository,
│               purchase_repo: PurchaseRepository,
│               pack_manager: CreditPackManager,
│               shopify_client: ShopifyClient,
│               publisher: BillingEventPublisher,
│               logger: ServiceLogger,
│           ):
│               self.config = config
│               self.billing_repo = billing_repo
│               self.purchase_repo = purchase_repo
│               self.pack_manager = pack_manager
│               self.shopify_client = shopify_client
│               self.publisher = publisher
│               self.logger = logger
│
│           async def create_purchase(self, merchant_id: UUID, domain: str, data: PurchaseCreateIn) -> PurchaseCreatedOut:
│               """Create credit purchase"""
│               # Validate merchant exists
│               billing_record = await self.billing_repo.find_by_merchant_id(merchant_id)
│               if not billing_record:
│                   raise MerchantNotFoundError(str(merchant_id))
│
│               # Get pack details
│               pack = self.pack_manager.get_pack(data.pack)
│               if not pack:
│                   raise InvalidCreditPackError(data.pack.value)
│
│               # Create purchase record
│               purchase = await self.purchase_repo.create(
│                   merchant_id=merchant_id,
│                   credits=pack["credits"],
│                   amount=pack["price"],
│                   platform=data.platform.value,
│                   expiry_hours=self.config.pending_purchase_expiry_hours,
│               )
│
│               # Create platform-specific checkout
│               checkout_url = None
│               charge_id = None
│
│               if data.platform == Platform.SHOPIFY:
│                   try:
│                       result = await self.shopify_client.create_charge(
│                           domain=domain,
│                           amount=pack["price"],
│                           name=f"{pack['credits']} Credits Pack",
│                           return_url=data.return_url,
│                       )
│                       checkout_url = result["confirmation_url"]
│                       charge_id = result["charge_id"]
│
│                       # Update purchase with charge ID
│                       await self.purchase_repo.update_platform_charge_id(UUID(purchase.id), charge_id)
│
│                   except Exception as e:
│                       # Mark purchase as failed
│                       await self.purchase_repo.fail_purchase(UUID(purchase.id))
│                       raise PlatformCheckoutError(data.platform.value, str(e)) from e
│               else:
│                   # Other platforms not implemented yet
│                   await self.purchase_repo.fail_purchase(UUID(purchase.id))
│                   raise PlatformCheckoutError(data.platform.value, "Platform not supported")
│
│               return PurchaseCreatedOut(
│                   purchase_id=UUID(purchase.id), checkout_url=checkout_url, expires_at=purchase.expires_at
│               )
│
│           async def get_purchase(self, purchase_id: UUID) -> PurchaseOut:
│               """Get purchase by ID"""
│               purchase = await self.purchase_repo.find_by_id(purchase_id)
│               if not purchase:
│                   raise PurchaseNotFoundError(str(purchase_id))
│
│               return PurchaseOut.model_validate(purchase)
│
│           async def list_purchases(self, merchant_id: UUID, limit: int = 10) -> list[PurchaseOut]:
│               """List purchases for merchant"""
│               purchases = await self.purchase_repo.find_by_merchant(merchant_id, limit)
│               return [PurchaseOut.model_validate(p) for p in purchases]
│
│           async def handle_purchase_webhook(self, charge_id: str, status: str, merchant_id: UUID) -> None:
│               """Handle purchase webhook from platform"""
│               # Find purchase by charge ID
│               purchase = await self.purchase_repo.find_by_charge_id(charge_id)
│               if not purchase:
│                   self.logger.warning(f"Purchase not found for charge {charge_id}")
│                   return
│
│               # Skip if already processed
│               if purchase.status != "pending":
│                   self.logger.info(f"Purchase {purchase.id} already processed")
│                   return
│
│               # Process based on status
│               if status == "accepted" or status == "active":
│                   # Mark as completed
│                   purchase = await self.purchase_repo.complete_purchase(UUID(purchase.id))
│
│                   # Update billing record totals
│                   await self.billing_repo.update_purchase_totals(UUID(purchase.merchant_id), purchase.credits)
│
│                   # Publish event
│                   await self.publisher.credits_purchased(
│                       CreditsPurchasedPayload(
│                           merchant_id=UUID(purchase.merchant_id),
│                           purchase_id=UUID(purchase.id),
│                           credits=purchase.credits,
│                           amount=purchase.amount,
│                           platform=purchase.platform,
│                       )
│                   )
│
│                   self.logger.info(f"Purchase {purchase.id} completed successfully")
│
│               else:
│                   # Mark as failed
│                   await self.purchase_repo.fail_purchase(UUID(purchase.id))
│                   self.logger.info(f"Purchase {purchase.id} failed with status {status}")
│
│           async def expire_pending_purchases(self) -> None:
│               """Expire pending purchases past expiry time (cron job)"""
│               count = await self.purchase_repo.expire_pending_purchases()
│               if count > 0:
│                   self.logger.info(f"Expired {count} pending purchases")
│       ```
│
├── utils/
│   ├── __init__.py
│   ├── credit_packs.py
│   │
│   │   ```py
│   │   from ..config import ServiceConfig
│   │   from ..schemas.billing import CreditPack
│   │
│   │
│   │   class CreditPackManager:
│   │       """Manages credit pack configurations"""
│   │
│   │       def __init__(self, config: ServiceConfig):
│   │           self.packs = {
│   │               CreditPack.SMALL: {"credits": config.small_pack_credits, "price": config.small_pack_price},
│   │               CreditPack.MEDIUM: {"credits": config.medium_pack_credits, "price": config.medium_pack_price},
│   │               CreditPack.LARGE: {"credits": config.large_pack_credits, "price": config.large_pack_price},
│   │           }
│   │
│   │       def get_pack(self, pack_type: CreditPack) -> dict | None:
│   │           """Get pack configuration"""
│   │           return self.packs.get(pack_type)
│   │
│   │       def get_credits(self, pack_type: CreditPack) -> int:
│   │           """Get credits for pack"""
│   │           pack = self.get_pack(pack_type)
│   │           return pack["credits"] if pack else 0
│   │
│   │       def get_price(self, pack_type: CreditPack) -> str:
│   │           """Get price for pack"""
│   │           pack = self.get_pack(pack_type)
│   │           return pack["price"] if pack else "0.00"
│   │   ```
│   │
│   └── shopify_client.py
│
│       ```py
│       import httpx
│
│       from shared.utils.logger import ServiceLogger
│
│       from ..config import ServiceConfig
│       from ..exceptions import PlatformCheckoutError
│
│
│       class ShopifyClient:
│           """Simplified Shopify API client for billing"""
│
│           def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│               self.config = config
│               self.logger = logger
│               self.api_version = config.shopify_api_version
│
│           async def create_charge(self, domain: str, amount: str, name: str, return_url: str) -> dict:
│               """Create Shopify recurring charge"""
│               try:
│                   # This is a simplified implementation
│                   # In production, you'd use proper Shopify API calls
│                   charge_data = {
│                       "recurring_application_charge": {
│                           "name": name,
│                           "price": str(amount),
│                           "return_url": return_url,
│                           "test": self.config.environment != "production",
│                       }
│                   }
│
│                   # Mock response for development
│                   if self.config.debug:
│                       return {
│                           "charge_id": f"charge_{domain}_{amount}",
│                           "confirmation_url": f"https://{domain}/admin/charges/confirm",
│                       }
│
│                   # Real Shopify API call would go here
│                   async with httpx.AsyncClient() as client:
│                       response = await client.post(
│                           f"https://{domain}/admin/api/{self.api_version}/recurring_application_charges.json",
│                           json=charge_data,
│                           headers={
│                               "X-Shopify-Access-Token": "shop_access_token",  # Would come from merchant record
│                               "Content-Type": "application/json",
│                           },
│                       )
│
│                       if response.status_code != 201:
│                           raise PlatformCheckoutError("shopify", response.text)
│
│                       data = response.json()
│                       return {
│                           "charge_id": data["recurring_application_charge"]["id"],
│                           "confirmation_url": data["recurring_application_charge"]["confirmation_url"],
│                       }
│
│               except httpx.RequestError as e:
│                   self.logger.exception(f"Shopify API error: {e}")
│                   raise PlatformCheckoutError("shopify", str(e)) from e
│       ```
│
├── __init__.py
├── config.py
│
│   ```py
│   # services/billing-service/src/config.py
│   import os
│   from functools import lru_cache
│
│   from pydantic import BaseModel, ConfigDict, Field, model_validator
│
│   from shared.utils import ConfigurationError, load_root_env
│
│
│   class ServiceConfig(BaseModel):
│       """Billing service configuration"""
│
│       model_config = ConfigDict(
│           extra="ignore",
│           populate_by_name=True,
│       )
│
│       # Service basics with defaults
│       service_name: str = "billing-service"
│       service_version: str = "1.0.0"
│       service_description: str = "Billing service for trial and credit pack management"
│       debug: bool = True
│
│       # Required from environment
│       environment: str = Field(..., alias="APP_ENV")
│       api_external_port: int = Field(..., alias="BILLING_API_EXTERNAL_PORT")
│       database_enabled: bool = Field(..., alias="BILLING_DB_ENABLED")
│
│       # Secrets from .env (required)
│       database_url: str = Field(..., alias="DATABASE_URL")
│       client_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
│       internal_jwt_secret: str = Field(..., alias="INTERNAL_JWT_SECRET")
│
│       # Shopify configuration
│       shopify_api_key: str = Field(..., alias="SHOPIFY_API_KEY")
│       shopify_api_secret: str = Field(..., alias="SHOPIFY_API_SECRET")
│       shopify_api_version: str = Field(default="2024-01", alias="SHOPIFY_API_VERSION")
│
│       # Optional with defaults
│       api_host: str = "0.0.0.0"
│       logging_level: str = "INFO"
│       logging_format: str = "json"
│
│       # Trial configuration
│       trial_duration_days: int = 14
│       trial_credits: int = 500
│
│       # Credit packs configuration
│       small_pack_credits: int = 100
│       small_pack_price: str = "9.99"
│       medium_pack_credits: int = 500
│       medium_pack_price: str = "39.99"
│       large_pack_credits: int = 1000
│       large_pack_price: str = "69.99"
│
│       # Purchase expiry
│       pending_purchase_expiry_hours: int = 24
│
│       @property
│       def nats_url(self) -> str:
│           """Dynamic NATS URL based on environment"""
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "nats://nats:4222"
│           return "nats://localhost:4222"
│
│       @property
│       def redis_url(self) -> str:
│           """Dynamic Redis URL based on environment"""
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "redis://redis:6379"
│           return "redis://localhost:6379"
│
│       @property
│       def api_port(self) -> int:
│           """Internal port (8000 in container, external port locally)"""
│           in_container = os.path.exists("/.dockerenv")
│           return 8000 if in_container else self.api_external_port
│
│       @model_validator(mode="after")
│       def _require_db_url_when_enabled(self):
│           """Validate database URL is provided when database is enabled"""
│           if self.database_enabled and not self.database_url:
│               raise ValueError("database_enabled=true requires DATABASE_URL")
│           return self
│
│
│   @lru_cache
│   def get_service_config() -> ServiceConfig:
│       """Load config - fail fast if anything is missing"""
│       try:
│           # Load .env file (for local development)
│           load_root_env()
│
│           # Create config from environment variables
│           return ServiceConfig(**os.environ)  # type: ignore[arg-type]
│       except Exception as e:
│           raise ConfigurationError(
│               f"Failed to load service configuration: {e}", config_key="billing-service", expected_value="valid config"
│           ) from e
│   ```
│
├── dependencies.py
│
│   ```py
│   # services/billing-service/src/dependencies.py
│   from typing import Annotated
│
│   from fastapi import Depends, HTTPException, Request
│
│   from shared.api.dependencies import CorrelationIdDep, PaginationDep, RequestContextDep, RequestIdDep
│
│   from .config import ServiceConfig
│   from .events.publishers import BillingEventPublisher
│   from .lifecycle import ServiceLifecycle
│   from .services.billing_service import BillingService
│   from .services.purchase_service import PurchaseService
│
│   # Re-export shared dependencies
│   __all__ = [
│       "BillingServiceDep",
│       "ConfigDep",
│       "CorrelationIdDep",
│       "LifecycleDep",
│       "PaginationDep",
│       "PublisherDep",
│       "PurchaseServiceDep",
│       "RequestContextDep",
│       "RequestIdDep",
│   ]
│
│
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       """Get service lifecycle from app state"""
│       return request.app.state.lifecycle
│
│
│   def get_config(request: Request) -> ServiceConfig:
│       """Get service config from app state"""
│       return request.app.state.config
│
│
│   # Type aliases for core dependencies
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
│
│
│   # Service dependencies
│   def get_billing_service(lifecycle: LifecycleDep) -> BillingService:
│       """Get billing service"""
│       if not lifecycle.billing_service:
│           raise HTTPException(500, "Billing service not initialized")
│       return lifecycle.billing_service
│
│
│   def get_purchase_service(lifecycle: LifecycleDep) -> PurchaseService:
│       """Get purchase service"""
│       if not lifecycle.purchase_service:
│           raise HTTPException(500, "Purchase service not initialized")
│       return lifecycle.purchase_service
│
│
│   def get_publisher(lifecycle: LifecycleDep) -> BillingEventPublisher:
│       """Get event publisher"""
│       if not lifecycle.event_publisher:
│           raise HTTPException(500, "Event publisher not initialized")
│       return lifecycle.event_publisher
│
│
│   # Type aliases
│   BillingServiceDep = Annotated[BillingService, Depends(get_billing_service)]
│   PurchaseServiceDep = Annotated[PurchaseService, Depends(get_purchase_service)]
│   PublisherDep = Annotated[BillingEventPublisher, Depends(get_publisher)]
│   ```
│
├── exceptions.py
│
│   ```py
│   from shared.utils.exceptions import ConflictError, DomainError, NotFoundError
│
│
│   class TrialAlreadyUsedError(ConflictError):
│       """Raised when trial has already been activated"""
│
│       def __init__(self, merchant_id: str):
│           super().__init__(message="Trial has already been activated", conflicting_resource="trial", current_state="used")
│           self.merchant_id = merchant_id
│
│
│   class InvalidCreditPackError(DomainError):
│       """Raised when invalid credit pack is selected"""
│
│       def __init__(self, pack: str):
│           super().__init__(message=f"Invalid credit pack: {pack}", code="INVALID_PACK")
│           self.pack = pack
│
│
│   class MerchantNotFoundError(NotFoundError):
│       """Raised when merchant billing record not found"""
│
│       def __init__(self, merchant_id: str):
│           super().__init__(message=f"Merchant {merchant_id} not found", resource="merchant", resource_id=merchant_id)
│
│
│   class PurchaseNotFoundError(NotFoundError):
│       """Raised when purchase not found"""
│
│       def __init__(self, purchase_id: str):
│           super().__init__(message=f"Purchase {purchase_id} not found", resource="purchase", resource_id=purchase_id)
│
│
│   class PlatformCheckoutError(DomainError):
│       """Raised when platform checkout creation fails"""
│
│       def __init__(self, platform: str, error_message: str):
│           super().__init__(message=f"Failed to create {platform} checkout: {error_message}", code="PLATFORM_ERROR")
│           self.platform = platform
│           self.error_message = error_message
│   ```
│
├── lifecycle.py
│
│   ```py
│   import asyncio
│
│   from prisma import Prisma  # type: ignore[attr-defined]
│
│   from shared.messaging.jetstream_client import JetStreamClient
│   from shared.utils.logger import ServiceLogger
│
│   from .config import ServiceConfig
│   from .events.listeners import MerchantCreatedListener, PurchaseWebhookListener
│   from .events.publishers import BillingEventPublisher
│   from .repositories.billing_repository import BillingRepository
│   from .repositories.purchase_repository import PurchaseRepository
│   from .services.billing_service import BillingService
│   from .services.purchase_service import PurchaseService
│   from .utils.credit_packs import CreditPackManager
│   from .utils.shopify_client import ShopifyClient
│
│
│   class ServiceLifecycle:
│       """Manages service lifecycle and dependencies"""
│
│       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│
│           # External connections
│           self.messaging_client: JetStreamClient | None = None
│           self.prisma: Prisma | None = None
│           # self.redis: redis.Redis | None = None
│           self._db_connected: bool = False
│
│           # Publishers / listeners
│           self.event_publisher: BillingEventPublisher | None = None
│           self._listeners: list = []
│
│           # Repositories
│           self.billing_repo: BillingRepository | None = None
│           self.purchase_repo: PurchaseRepository | None = None
│
│           # Services
│           self.billing_service: BillingService | None = None
│           self.purchase_service: PurchaseService | None = None
│
│           # Utils
│           self.pack_manager: CreditPackManager | None = None
│           self.shopify_client: ShopifyClient | None = None
│
│           # Tasks
│           self._tasks: list[asyncio.Task] = []
│           self._shutdown_event = asyncio.Event()
│
│       async def startup(self) -> None:
│           """Initialize all components"""
│           try:
│               self.logger.info("Starting service components...")
│
│               await self._init_messaging()
│               await self._init_database()
│               # await self._init_redis()
│               self._init_utils()
│               self._init_repositories()
│               self._init_local_services()
│               await self._init_listeners()
│
│               self.logger.info("%s started successfully", self.config.service_name)
│
│           except Exception:
│               self.logger.critical("Service failed to start", exc_info=True)
│               await self.shutdown()
│               raise
│
│       async def shutdown(self) -> None:
│           """Graceful shutdown of all components"""
│           self.logger.info("Shutting down %s", self.config.service_name)
│
│           # Cancel tasks
│           for t in self._tasks:
│               t.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│
│           # Stop listeners
│           for lst in self._listeners:
│               try:
│                   await lst.stop()
│               except Exception:
│                   self.logger.critical("Listener stop failed", exc_info=True)
│
│           # # Close connections
│           # if self.redis:
│           #     try:
│           #         await self.redis.close()
│           #         if hasattr(self.redis, "wait_closed"):
│           #             await self.redis.wait_closed()
│           #     except Exception:
│           #         self.logger.critical("Redis close failed", exc_info=True)
│
│           if self.messaging_client:
│               try:
│                   await self.messaging_client.close()
│               except Exception:
│                   self.logger.critical("Messaging client close failed", exc_info=True)
│
│           if self.prisma and self._db_connected:
│               try:
│                   await self.prisma.disconnect()
│               except Exception:
│                   self.logger.critical("Prisma disconnect failed", exc_info=True)
│
│           self.logger.info("%s shutdown complete", self.config.service_name)
│
│       async def _init_messaging(self) -> None:
│           """Initialize messaging client"""
│           self.messaging_client = JetStreamClient(self.logger)
│           await self.messaging_client.connect([self.config.nats_url])
│           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.>", "cmd.>"])
│
│           # Initialize publisher
│           self.event_publisher = BillingEventPublisher(
│               jetstream_client=self.messaging_client,
│               logger=self.logger,
│           )
│
│           self.logger.info("Messaging client and publisher initialized")
│
│       async def _init_database(self) -> None:
│           """Initialize Prisma client"""
│           if not self.config.database_enabled:
│               self.logger.info("Database disabled; skipping Prisma initialization")
│               return
│
│           self.prisma = Prisma()
│           if not self.prisma:
│               raise RuntimeError("Prisma client not initialized")
│
│           try:
│               await self.prisma.connect()
│               self._db_connected = True
│               self.logger.info("Prisma connected")
│           except Exception as e:
│               self.logger.exception("Prisma connect failed: %s", e, exc_info=True)
│               raise
│
│       # async def _init_redis(self) -> None:
│       #     """Initialize Redis client"""
│       #     self.redis = redis.from_url(self.config.redis_url)
│       #     await self.redis.ping()
│       #     self.logger.info("Redis connected")
│
│       def _init_utils(self) -> None:
│           """Initialize utility classes"""
│           self.pack_manager = CreditPackManager(self.config)
│           self.shopify_client = ShopifyClient(self.config, self.logger)
│           self.logger.info("Utilities initialized")
│
│       def _init_repositories(self) -> None:
│           """Initialize repositories"""
│           if self.config.database_enabled:
│               if not (self.prisma and self._db_connected):
│                   raise RuntimeError("Prisma client not initialized/connected")
│
│               self.billing_repo = BillingRepository(self.prisma, self.logger)
│               self.purchase_repo = PurchaseRepository(self.prisma, self.logger)
│               self.logger.info("Repositories initialized")
│           else:
│               self.billing_repo = None
│               self.purchase_repo = None
│
│       def _init_local_services(self) -> None:
│           """Initialize services"""
│           if not self.billing_repo or not self.purchase_repo:
│               raise RuntimeError("Repositories not initialized")
│
│           if not self.event_publisher:
│               raise RuntimeError("Event publisher not initialized")
│
│           # # Add checks for required dependencies
│           # if not self.redis:
│           #     raise RuntimeError("Redis client not initialized")
│
│           if not self.pack_manager:
│               raise RuntimeError("Credit pack manager not initialized")
│
│           if not self.shopify_client:
│               raise RuntimeError("Shopify client not initialized")
│
│           self.billing_service = BillingService(
│               config=self.config,
│               billing_repo=self.billing_repo,
│               purchase_repo=self.purchase_repo,
│               publisher=self.event_publisher,
│               logger=self.logger,
│           )
│
│           self.purchase_service = PurchaseService(
│               config=self.config,
│               billing_repo=self.billing_repo,
│               purchase_repo=self.purchase_repo,
│               pack_manager=self.pack_manager,
│               shopify_client=self.shopify_client,
│               publisher=self.event_publisher,
│               logger=self.logger,
│           )
│
│           self.logger.info("Services initialized")
│
│       async def _init_listeners(self) -> None:
│           """Initialize event listeners"""
│           if not self.messaging_client or not self.billing_service or not self.purchase_service:
│               raise RuntimeError("Required components not ready for listeners")
│
│           # Merchant created listener
│           merchant_listener = MerchantCreatedListener(
│               js_client=self.messaging_client, billing_service=self.billing_service, logger=self.logger
│           )
│           await merchant_listener.start()
│           self._listeners.append(merchant_listener)
│
│           # Purchase webhook listener
│           webhook_listener = PurchaseWebhookListener(
│               js_client=self.messaging_client, purchase_service=self.purchase_service, logger=self.logger
│           )
│           await webhook_listener.start()
│           self._listeners.append(webhook_listener)
│
│           self.logger.info("Event listeners started")
│
│       def add_task(self, coro) -> asyncio.Task:
│           """Add a background task"""
│           t = asyncio.create_task(coro)
│           self._tasks.append(t)
│           return t
│
│       async def wait_for_shutdown(self) -> None:
│           """Wait for shutdown signal"""
│           await self._shutdown_event.wait()
│
│       def signal_shutdown(self) -> None:
│           """Signal shutdown"""
│           self._shutdown_event.set()
│   ```
│
└── main.py

    ```py
    from contextlib import asynccontextmanager

    from fastapi import FastAPI

    from shared.api import setup_middleware
    from shared.api.health import create_health_router
    from shared.utils.logger import create_logger

    from .api import api_router
    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    # Global singletons
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)


    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """FastAPI lifespan adapter"""
        logger.info(
            f"Starting {config.service_name}",
            extra={
                "service_name": config.service_name,
                "version": config.service_version,
                "environment": config.environment,
                "api_host": config.api_host,
                "api_port": config.api_port,
            },
        )

        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()


    def create_application() -> FastAPI:
        """Create and configure the FastAPI application"""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            lifespan=lifespan,
            description="Billing service for trial and credit pack management",
        )

        # Setup middleware (critical - must be after logger in app.state)
        setup_middleware(
            app,
            service_name=config.service_name,
        )

        # Include routers
        app.include_router(create_health_router(config.service_name))
        app.include_router(api_router)

        return app


    app = create_application()


    if __name__ == "__main__":
        import uvicorn

        port = config.api_port
        uvicorn.run("src.main:app", host=config.api_host, port=port, reload=config.debug)
    ```

.python-version
Dockerfile

```
# services/billing-service/Dockerfile
# Stage 1 - Builder
FROM python:3.11-slim AS builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry
RUN poetry config virtualenvs.create false

# Install shared package dependencies
COPY shared /shared
WORKDIR /shared
RUN poetry install --no-dev

# Install service dependencies
WORKDIR /app
COPY services/billing-service/pyproject.toml services/billing-service/poetry.lock* ./
RUN poetry install --no-dev --no-interaction --no-ansi

# Copy Prisma schema and generate client
COPY services/billing-service/prisma ./prisma
RUN prisma generate

# Copy service code
COPY services/billing-service /app

# Copy config
COPY config /app/config

# Stage 2 - Runtime
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app /app
COPY --from=builder /shared /shared

ENV PYTHONPATH="/shared:/app"
ENV DOCKER_CONTAINER=1

WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run migrations and start server
CMD ["sh", "-c", "prisma migrate deploy && uvicorn src.main:app --host 0.0.0.0 --port 8000"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
[tool.poetry]
name = "billing-service"
version = "1.0.0"
description = "Billing service for trial and billing management"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
prisma = "^0.11.0"
nats-py = "^2.6.0"
shared = { path = "../../shared", develop = true }

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
ruff = "^0.1.9"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```


================================================================================
Output includes file contents
================================================================================
