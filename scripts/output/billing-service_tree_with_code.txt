================================================================================
Directory Structure: /home/bellabe/glam-app/services/billing-service
================================================================================

billing-service/
alembic/
├── alembic.ini
│
│   ```ini
│   # services/billing-service/alembic/alembic.ini
│   [alembic]
│   script_location = alembic
│   prepend_sys_path = .
│   version_path_separator = os
│
│   sqlalchemy.url = postgresql+asyncpg://billing:billing123@localhost:5432/billing_db
│
│   [post_write_hooks]
│
│   [loggers]
│   keys = root,sqlalchemy,alembic
│
│   [handlers]
│   keys = console
│
│   [formatters]
│   keys = generic
│
│   [logger_root]
│   level = WARN
│   handlers = console
│   qualname =
│
│   [logger_sqlalchemy]
│   level = WARN
│   handlers =
│   qualname = sqlalchemy.engine
│
│   [logger_alembic]
│   level = INFO
│   handlers =
│   qualname = alembic
│
│   [handler_console]
│   class = StreamHandler
│   args = (sys.stderr,)
│   level = NOTSET
│   formatter = generic
│
│   [formatter_generic]
│   format = %(levelname)-5.5s [%(name)s] %(message)s
│   datefmt = %H:%M:%S
│   ```
│
└── env.py

    ```py
    # services/billing-service/alembic/env.py
    import asyncio
    import os
    from logging.config import fileConfig

    from sqlalchemy import pool
    from sqlalchemy.engine import Connection
    from sqlalchemy.ext.asyncio import create_async_engine

    from alembic import context

    # Import all models to ensure they're registered with Base
    from src.models import *
    from shared.database.base import Base

    # This is the Alembic Config object
    config = context.config

    # Interpret the config file for Python logging
    if config.config_file_name is not None:
        fileConfig(config.config_file_name)

    # Set the target metadata
    target_metadata = Base.metadata

    def get_database_url() -> str:
        return os.getenv("BILLING_SERVICE_DATABASE_URL") or config.get_main_option("sqlalchemy.url")

    def run_migrations_offline() -> None:
        url = get_database_url()
        context.configure(
            url=url,
            target_metadata=target_metadata,
            literal_binds=True,
            dialect_opts={"paramstyle": "named"},
        )

        with context.begin_transaction():
            context.run_migrations()

    def do_run_migrations(connection: Connection) -> None:
        context.configure(connection=connection, target_metadata=target_metadata)

        with context.begin_transaction():
            context.run_migrations()

    async def run_async_migrations() -> None:
        connectable = create_async_engine(
            get_database_url(),
            poolclass=pool.NullPool,
        )

        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

        await connectable.dispose()

    def run_migrations_online() -> None:
        asyncio.run(run_async_migrations())

    if context.is_offline_mode():
        run_migrations_offline()
    else:
        run_migrations_online()
    ```

src/
├── api/
│   ├── v1/
│   │   ├── __init__.py
│   │   │
│   │   │   ```py
│   │   │   # glam-app/services/billing-service/src/api/v1/__init__.py
│   │   │   """API v1 package for billing service."""
│   │   │
│   │   │   from fastapi import APIRouter
│   │   │   from . import health, plans, subscriptions, payments, trials
│   │   │
│   │   │   router = APIRouter()
│   │   │
│   │   │   router.include_router(health.router, prefix="/billing")
│   │   │   router.include_router(plans.router, prefix="/billing")
│   │   │   router.include_router(subscriptions.router, prefix="/billing")
│   │   │   router.include_router(trials.router, prefix="/billing")
│   │   │   router.include_router(payments.router, prefix="/billing")
│   │   │
│   │   │   __all__ = ["router"]
│   │   │   ```
│   │   │
│   │   ├── health.py
│   │   │
│   │   │   ```py
│   │   │   # glam-app/services/credit-service/src/api/v1/health.py
│   │   │
│   │   │   from fastapi import APIRouter
│   │   │   from shared.api.health import create_health_router
│   │   │
│   │   │   router = APIRouter()
│   │   │
│   │   │   # Include reusable shared health routes for this service
│   │   │   health_router = create_health_router("billing-service")
│   │   │   router.include_router(health_router)
│   │   │   ```
│   │   │
│   │   ├── plans.py
│   │   │
│   │   │   ```py
│   │   │   # glam-app/services/billing-service/src/api/v1/plans.py
│   │   │   from typing import List
│   │   │   from fastapi import APIRouter, HTTPException, status, Body, Path
│   │   │
│   │   │   from shared.api import (
│   │   │       ApiResponse,
│   │   │       success_response,
│   │   │       RequestContextDep,
│   │   │   )
│   │   │
│   │   │   from ...dependencies import BillingServiceDep
│   │   │
│   │   │   from ...schemas import (
│   │   │       BillingPlanIn,
│   │   │       BillingPlanPatch,
│   │   │       BillingPlanOut,
│   │   │   )
│   │   │
│   │   │
│   │   │   router = APIRouter(prefix="/plans", tags=["Plans"])
│   │   │
│   │   │   @router.get("",
│   │   │               response_model=ApiResponse[List[BillingPlanOut]],
│   │   │               summary="List all billing plans",
│   │   │               status_code=status.HTTP_200_OK
│   │   │               )
│   │   │   async def list_plans(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep
│   │   │   ):
│   │   │       """List all available billing plans"""
│   │   │       plans = await svc.get_all_plans()
│   │   │       return success_response(
│   │   │           data=plans,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id
│   │   │       )
│   │   │
│   │   │   @router.get("/{plan_id}",
│   │   │               response_model=ApiResponse[BillingPlanOut],
│   │   │               summary="Get billing plan details",
│   │   │               status_code=status.HTTP_200_OK
│   │   │               )
│   │   │
│   │   │   async def get_plan(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       plan_id: str = Path(..., min_length=1, max_length=100)
│   │   │   ):
│   │   │       """Get details of a specific billing plan"""
│   │   │       plan = await svc.get_plan_by_id(plan_id)
│   │   │       if not plan:
│   │   │           raise HTTPException(status_code=404, detail="Plan not found")
│   │   │
│   │   │       return success_response(
│   │   │           data=plan,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id
│   │   │       )
│   │   │
│   │   │   @router.post(
│   │   │       "",
│   │   │       response_model=ApiResponse[BillingPlanOut],
│   │   │       summary="Create a new billing plan",
│   │   │       status_code=status.HTTP_201_CREATED,
│   │   │   )
│   │   │   async def create_plan(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       body: BillingPlanIn = Body(...)
│   │   │   ):
│   │   │       plan = await svc.create_plan(body)
│   │   │       return success_response(
│   │   │           data=plan,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │
│   │   │   @router.patch(
│   │   │       "/{plan_id}",
│   │   │       response_model=ApiResponse[BillingPlanOut],
│   │   │       summary="Partially update a billing plan",
│   │   │       status_code=status.HTTP_200_OK,
│   │   │   )
│   │   │   async def patch_plan(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       plan_id: str = Path(..., min_length=1, max_length=100),
│   │   │       patch: BillingPlanPatch = Body(...),
│   │   │   ):
│   │   │       plan = await svc.patch_plan(plan_id, patch)
│   │   │       if not plan:
│   │   │           raise HTTPException(status_code=404, detail="Plan not found")
│   │   │       return success_response(
│   │   │           data=plan,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │   ```
│   │   │
│   │   ├── purchases.py
│   │   │
│   │   │   ```py
│   │   │   # glam-app/services/billing-service/src/api/v1/purchases.py
│   │   │   from typing import List
│   │   │   from fastapi import APIRouter, status
│   │   │
│   │   │   from shared.api import (
│   │   │       ApiResponse,
│   │   │       success_response,
│   │   │       RequestContextDep,
│   │   │   )
│   │   │
│   │   │   from ...schemas import(
│   │   │       OneTimePurchaseIn, OneTimePurchaseOut
│   │   │   )
│   │   │
│   │   │   from ...dependencies import OneTimePurchaseServiceDep
│   │   │
│   │   │   router = APIRouter(prefix="/purchases", tags=["Purchases"])
│   │   │
│   │   │   @router.post("",
│   │   │                response_model=ApiResponse[OneTimePurchaseOut],
│   │   │                summary="Create one-time credit purchase",
│   │   │                status_code=status.HTTP_201_CREATED)
│   │   │   async def create_purchase(data: OneTimePurchaseIn, svc: OneTimePurchaseServiceDep, ctx: RequestContextDep):
│   │   │       """Create one-time credit purchase"""
│   │   │
│   │   │       result = await svc.create_purchase(data, ctx=ctx)
│   │   │
│   │   │       return success_response(
│   │   │           data=result,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id
│   │   │       )
│   │   │
│   │   │
│   │   │   ```
│   │   │
│   │   ├── subsriptions.py
│   │   │
│   │   │   ```py
│   │   │   # glam-app/services/billing-service/src/api/v1/subscriptions.py
│   │   │   from typing import List
│   │   │   from uuid import UUID
│   │   │
│   │   │   from fastapi import APIRouter, HTTPException, Path, Query, Body, status
│   │   │
│   │   │   from shared.api import ApiResponse, success_response, RequestContextDep
│   │   │   from ...dependencies import BillingServiceDep
│   │   │   from ...schemas import (
│   │   │       SubscriptionCreateIn,
│   │   │       SubscriptionCreateOut,
│   │   │       SubscriptionOut,
│   │   │   )
│   │   │
│   │   │   router = APIRouter(prefix="/subscriptions", tags=["Subscriptions"])
│   │   │
│   │   │   @router.post(
│   │   │       "",
│   │   │       response_model=ApiResponse[SubscriptionCreateOut],
│   │   │       status_code=status.HTTP_201_CREATED,
│   │   │       summary="Create a new subscription (initiates Shopify charge)",
│   │   │   )
│   │   │   async def create_subscription(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       body: SubscriptionCreateIn = Body(...),
│   │   │   ):
│   │   │       result = await svc.create_subscription(
│   │   │           merchant_id=body.merchant_id,
│   │   │           shop_id=body.shop_id,
│   │   │           plan_id=body.plan_id,
│   │   │           return_url=body.return_url,
│   │   │           test_mode=body.test_mode,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │
│   │   │       return success_response(
│   │   │           data=result,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │
│   │   │   @router.get(
│   │   │       "/{subscription_id}",
│   │   │       response_model=ApiResponse[SubscriptionOut],
│   │   │       summary="Get subscription details",
│   │   │       status_code=status.HTTP_200_OK,
│   │   │   )
│   │   │   async def get_subscription(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       subscription_id: UUID = Path(...),
│   │   │
│   │   │   ):
│   │   │       subscription = await svc.get_subscription(subscription_id)
│   │   │       if not subscription:
│   │   │           raise HTTPException(status_code=404, detail="Subscription not found")
│   │   │
│   │   │       return success_response(
│   │   │           data=subscription,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │
│   │   │   @router.get(
│   │   │       "/merchant/{merchant_id}",
│   │   │       response_model=ApiResponse[List[SubscriptionOut]],
│   │   │       summary="List a merchant’s subscriptions",
│   │   │   )
│   │   │   async def list_merchant_subscriptions(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       merchant_id: UUID = Path(..., description="The ID of the merchant"),
│   │   │   ):
│   │   │       subs = await svc.list_merchant_subscriptions(merchant_id)
│   │   │       return success_response(
│   │   │           data=subs,
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │
│   │   │   @router.delete(
│   │   │       "/{subscription_id}",
│   │   │       response_model=ApiResponse[dict],
│   │   │       summary="Cancel a subscription",
│   │   │   )
│   │   │   async def cancel_subscription(
│   │   │       svc: BillingServiceDep,
│   │   │       ctx: RequestContextDep,
│   │   │       subscription_id: UUID = Path(...),
│   │   │       immediate: bool = Query(False),
│   │   │       reason: str = Query("merchant_request"),
│   │   │
│   │   │   ):
│   │   │       # TODO: use `immediate` / `reason` once business rules are defined
│   │   │       await svc.cancel_subscription(subscription_id)
│   │   │
│   │   │       return success_response(
│   │   │           data={"message": "Subscription cancelled successfully"},
│   │   │           request_id=ctx.request_id,
│   │   │           correlation_id=ctx.correlation_id,
│   │   │       )
│   │   │   ```
│   │   │
│   │   └── trials.py
│   │
│   │       ```py
│   │       # services/billing-service/src/api/v1/trials.py
│   │       from datetime import datetime
│   │       from uuid import UUID
│   │
│   │       from fastapi import (
│   │           APIRouter,
│   │           HTTPException,
│   │           Path,
│   │           Body,
│   │           status,
│   │       )
│   │
│   │       from shared.api import ApiResponse, success_response, RequestContextDep
│   │       from ...services import TrialService
│   │       from ...schemas.trial_extension import (
│   │           TrialExtensionIn,
│   │           TrialExtensionOut,
│   │           TrialStatusOut,
│   │       )
│   │       from ...exceptions import ConflictError
│   │
│   │       router = APIRouter(prefix="/trials", tags=["Trials"])
│   │
│   │       @router.get(
│   │           "/{merchant_id}",
│   │           response_model=ApiResponse[TrialStatusOut],
│   │           status_code=status.HTTP_200_OK,
│   │           summary="Get current trial status",
│   │       )
│   │       async def get_trial_status(
│   │           svc: TrialService,
│   │           ctx: RequestContextDep,
│   │           merchant_id: UUID = Path(..., description="Merchant UUID"),
│   │       ):
│   │           """
│   │           Returns start date, end date, days remaining, and extension stats for a merchant’s trial.
│   │           """
│   │           status_out = await svc.get_trial_status(merchant_id)
│   │           return success_response(
│   │               data=status_out,
│   │               request_id=ctx.request_id,
│   │               correlation_id=ctx.correlation_id,
│   │           )
│   │
│   │       @router.post(
│   │           "/{merchant_id}/extend",
│   │           response_model=ApiResponse[TrialExtensionOut],
│   │           status_code=status.HTTP_201_CREATED,
│   │           summary="Extend a merchant's trial (admin only)",
│   │       )
│   │       async def extend_trial(
│   │           svc: TrialService,
│   │           ctx: RequestContextDep,
│   │           merchant_id: UUID = Path(..., description="Merchant UUID"),
│   │           body: TrialExtensionIn = Body(..., description="Extension payload"),
│   │       ):
│   │           """
│   │           Adds `additional_days` to the merchant’s trial period.
│   │           """
│   │           try:
│   │               out = await svc.extend_trial(
│   │                   merchant_id=merchant_id,
│   │                   additional_days=body.additional_days,
│   │                   reason=body.reason,
│   │                   extended_by=body.extended_by,
│   │               )
│   │               return success_response(
│   │                   data=out,
│   │                   request_id=ctx.request_id,
│   │                   correlation_id=ctx.correlation_id,
│   │               )
│   │           except ConflictError as e:
│   │               raise HTTPException(status_code=400, detail=str(e))
│   │       ```
│   │
│   └── __init__.py
│
│       ```py
│       # glam-app/services/billing-service/src/api/__init__.py
│       """API module for Billing Service."""
│       ```
│
├── events/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/events/__init__.py
│   │   """Event handling for billing service."""
│   │
│   │   from .publishers import BillingEventPublisher
│   │   from .subscribers import WebhookEventSubscriber, PurchaseWebhookSubscriber, AppUninstalledSubscriber
│   │   __all__ = [
│   │       "BillingEventPublisher",
│   │       "WebhookEventSubscriber",
│   │       "PurchaseWebhookSubscriber",
│   │       "AppUninstalledSubscriber",
│   │   ]
│   │   ```
│   │
│   ├── publishers.py
│   │
│   │   ```py
│   │   # services/billing-service/src/events/publishers.py
│   │   from shared.events import DomainEventPublisher, Streams
│   │
│   │
│   │   class BillingEventPublisher(DomainEventPublisher):
│   │       """Domain-specific event publisher for billing"""
│   │       domain_stream = Streams.BILLING
│   │       service_name_override = "billing-service"
│   │   ```
│   │
│   ├── subscribers.py
│   │
│   │   ```py
│   │   # services/billing-service/src/events/subscribers.py
│   │   from shared.events import DomainEventSubscriber
│   │
│   │
│   │   class WebhookEventSubscriber(DomainEventSubscriber):
│   │       """Subscribe to webhook events from other services"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return WebhookEvents.SUBSCRIPTION_UPDATED
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           return WebhookEvents.SUBSCRIPTION_UPDATED
│   │
│   │       @property
│   │       def durable_name(self) -> str:
│   │           return "billing-subscription-updated"
│   │
│   │       async def on_event(self, event: dict, headers=None):
│   │           """Process subscription payment webhook"""
│   │           billing_service = self.get_dependency("billing_service") # type: ignore
│   │           logger = self.get_dependency("logger")
│   │
│   │           payload = event["payload"]
│   │           correlation_id = event.get("correlation_id")
│   │
│   │           logger.info(
│   │               "Processing subscription payment webhook",
│   │               extra={
│   │                   "subject": self.subject,
│   │                   "correlation_id": correlation_id
│   │               }
│   │           )
│   │
│   │           # Process subscription activation
│   │           await billing_service.activate_subscription_after_payment(
│   │               shopify_subscription_id=payload["subscription_id"],
│   │               payment_data=payload,
│   │               correlation_id=correlation_id
│   │           )
│   │
│   │
│   │   class PurchaseWebhookSubscriber(DomainEventSubscriber):
│   │       """Subscribe to purchase webhook events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           """The subject pattern to subscribe to"""
│   │           return WebhookEvents.PURCHASE_UPDATED
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           """The expected subject for validation"""
│   │           return WebhookEvents.PURCHASE_UPDATED
│   │
│   │       @property
│   │       def durable_name(self) -> str:
│   │           """The durable consumer name"""
│   │           return "billing-purchase-updated"
│   │
│   │       async def on_event(self, event: dict, headers=None):
│   │           """Process purchase payment webhook"""
│   │           purchase_service = self.get_dependency("purchase_service") # type: ignore
│   │           logger = self.get_dependency("logger")
│   │
│   │           payload = event["payload"]
│   │           correlation_id = event.get("correlation_id")
│   │
│   │           logger.info(
│   │               "Processing purchase payment webhook",
│   │               extra={
│   │                   "subject": self.subject,
│   │                   "correlation_id": correlation_id
│   │               }
│   │           )
│   │
│   │           # Process purchase completion
│   │           await purchase_service.complete_purchase(
│   │               shopify_charge_id=payload["charge_id"],
│   │               payment_data=payload,
│   │               correlation_id=correlation_id
│   │           )
│   │
│   │
│   │   class AppUninstalledSubscriber(DomainEventSubscriber):
│   │       """Subscribe to app uninstallation events"""
│   │
│   │       @property
│   │       def subject(self) -> str:
│   │           """The expected subject for validation"""
│   │           return WebhookEvents.APP_UNINSTALLED
│   │       @property
│   │       def subject(self) -> str:
│   │           """The subject pattern to subscribe to"""
│   │           return WebhookEvents.APP_UNINSTALLED
│   │       @property
│   │       def durable_name(self) -> str:
│   │           """The durable consumer name"""
│   │           return "billing-app-uninstalled"
│   │
│   │       async def on_event(self, event: dict, headers=None):
│   │           """Cancel all subscriptions on app uninstall"""
│   │           billing_service = self.get_dependency("billing_service") # type: ignore
│   │           logger = self.get_dependency("logger")
│   │
│   │           payload = event["payload"]
│   │           correlation_id = event.get("correlation_id")
│   │
│   │           logger.info(
│   │               "Processing app uninstall",
│   │               extra={
│   │                   "shop_id": payload.get("shop_id"),
│   │                   "correlation_id": correlation_id
│   │               }
│   │           )
│   │           # Cancel all subscriptions for the shop
│   │           await billing_service.cancel_all_subscriptions(
│   │               shop_id=payload["shop_id"],
│   │               correlation_id=correlation_id
│   │           )
│   │
│   │
│   │   ```
│   │
│   └── types.py
│
│       ```py
│       # services/billing-service/src/events/types.py
│       class BillingEvents:
│           """Event type constants for billing service"""
│
│           # Subscription events
│           SUBSCRIPTION_CREATED = "evt.billing.subscription.created"
│           SUBSCRIPTION_ACTIVATED = "evt.billing.subscription.activated"
│           SUBSCRIPTION_CANCELLED = "evt.billing.subscription.cancelled"
│           SUBSCRIPTION_EXPIRED = "evt.billing.subscription.expired"
│
│           # Purchase events
│           PURCHASE_CREATED = "evt.billing.purchase.created"
│           PURCHASE_COMPLETED = "evt.billing.purchase.completed"
│           PURCHASE_FAILED = "evt.billing.purchase.failed"
│
│           # Trial events
│           TRIAL_EXTENDED = "evt.billing.trial.extended"
│           TRIAL_EXPIRED = "evt.billing.trial.expired"
│
│           # Notification events
│           NOTIFICATION_PAYMENT_FAILED = "evt.billing.notification.payment_failed"
│           NOTIFICATION_SUBSCRIPTION_ACTIVATED = "evt.billing.notification.subscription_activated"
│
│       ```
│
├── external/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/external/__init__.py
│   │   """External integrations for billing service."""
│   │   from .shopify_billing_client import ShopifyBillingClient
│   │   __all__ = [
│   │       "ShopifyBillingClient",
│   │   ]
│   │   ```
│   │
│   └── shopify_billing_client.py
│
│       ```py
│       # services/billing-service/src/external/shopify_billing_client.py
│       import httpx
│       from typing import Dict, Any
│       from decimal import Decimal
│
│       from ..models import BillingInterval
│       from ..exceptions import ShopifyBillingError
│
│       class ShopifyBillingClient:
│           """Shopify billing operations client"""
│
│           def __init__(self, api_key: str, api_secret: str):
│               self.api_key = api_key
│               self.api_secret = api_secret
│
│           async def create_subscription(
│               self,
│               shop_id: str,
│               plan_name: str,
│               amount: Decimal,
│               credits: int,
│               billing_interval: BillingInterval,
│               return_url: str,
│               test_mode: bool = False
│           ) -> Dict[str, Any]:
│               """Create recurring subscription charge via Shopify GraphQL"""
│               mutation = """
│               mutation AppSubscriptionCreate($name: String!, $lineItems: [AppSubscriptionLineItemInput!]!, $returnUrl: URL!, $test: Boolean) {
│                 appSubscriptionCreate(name: $name, lineItems: $lineItems, returnUrl: $returnUrl, test: $test) {
│                   appSubscription {
│                     id
│                     status
│                     createdAt
│                   }
│                   confirmationUrl
│                   userErrors {
│                     field
│                     message
│                   }
│                 }
│               }
│               """
│
│               variables = {
│                   "name": f"{plan_name} - {credits} Credits",
│                   "lineItems": [{
│                       "plan": {
│                           "appRecurringPricingDetails": {
│                               "price": {"amount": str(amount), "currencyCode": "USD"},
│                               "interval": billing_interval.value
│                           }
│                       }
│                   }],
│                   "returnUrl": return_url,
│                   "test": test_mode
│               }
│
│               response = await self._make_graphql_request(shop_id, mutation, variables)
│
│               if response["data"]["appSubscriptionCreate"]["userErrors"]:
│                   errors = response["data"]["appSubscriptionCreate"]["userErrors"]
│                   raise ShopifyBillingError(f"Subscription creation failed: {errors}")
│
│               return response["data"]["appSubscriptionCreate"]
│
│           async def create_one_time_charge(
│               self,
│               shop_id: str,
│               amount: Decimal,
│               description: str,
│               return_url: str,
│               test_mode: bool = False
│           ) -> Dict[str, Any]:
│               """Create one-time charge via Shopify GraphQL"""
│               mutation = """
│               mutation AppPurchaseOneTimeCreate($name: String!, $price: MoneyInput!, $returnUrl: URL!, $test: Boolean) {
│                 appPurchaseOneTimeCreate(name: $name, price: $price, returnUrl: $returnUrl, test: $test) {
│                   appPurchaseOneTime {
│                     id
│                     status
│                     createdAt
│                   }
│                   confirmationUrl
│                   userErrors {
│                     field
│                     message
│                   }
│                 }
│               }
│               """
│
│               variables = {
│                   "name": description,
│                   "price": {"amount": str(amount), "currencyCode": "USD"},
│                   "returnUrl": return_url,
│                   "test": test_mode
│               }
│
│               response = await self._make_graphql_request(shop_id, mutation, variables)
│
│               if response["data"]["appPurchaseOneTimeCreate"]["userErrors"]:
│                   errors = response["data"]["appPurchaseOneTimeCreate"]["userErrors"]
│                   raise ShopifyBillingError(f"One-time charge creation failed: {errors}")
│
│               return response["data"]["appPurchaseOneTimeCreate"]
│
│           async def _make_graphql_request(self, shop_id: str, query: str, variables: Dict) -> Dict:
│               """Make GraphQL request to Shopify"""
│               url = f"https://{shop_id}/admin/api/2024-01/graphql.json"
│
│               headers = {
│                   "Content-Type": "application/json",
│                   "X-Shopify-Access-Token": self.api_key,  # Simplified for example
│               }
│
│               payload = {
│                   "query": query,
│                   "variables": variables
│               }
│
│               async with httpx.AsyncClient() as client:
│                   response = await client.post(url, headers=headers, json=payload)
│                   response.raise_for_status()
│                   return response.json()
│       ```
│
├── mappers/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/mappers/__init__.py
│   │   """Mappers for billing service."""
│   │   from .billing_plan import BillingPlanMapper
│   │   from .subscription import SubscriptionMapper
│   │   from .one_time_purchase import OneTimePurchaseMapper
│   │   from .trial_extension import TrialExtensionMapper
│   │
│   │   __all__ = [
│   │       "BillingPlanMapper",
│   │       "SubscriptionMapper",
│   │       "OneTimePurchaseMapper",
│   │       "TrialExtensionMapper",
│   │   ]
│   │   ```
│   │
│   ├── billing_plan.py
│   │
│   │   ```py
│   │   # services/billing-service/src/mappers/billing_plan_mapper.py
│   │   """Mapper for billing plan model to response schemas."""
│   │
│   │
│   │   from ..models import BillingPlan
│   │   from ..schemas.billing_plan import BillingPlanIn, BillingPlanPatch, BillingPlanOut
│   │   from shared.mappers.crud_mapper import CRUDMapper
│   │
│   │   class BillingPlanMapper(CRUDMapper[
│   │       BillingPlan, BillingPlanIn, BillingPlanPatch, BillingPlanOut
│   │   ]):
│   │       model_cls  = BillingPlan
│   │       out_schema = BillingPlanOut
│   │   ```
│   │
│   ├── one_time_purchase.py
│   │
│   │   ```py
│   │   # services/billing-service/src/mappers/one_time_purchase_mapper.py
│   │   """Mapper for one-time purchase model to response schemas."""
│   │
│   │   from ..models import OneTimePurchase
│   │   from ..schemas.one_time_purchase import (
│   │       OneTimePurchaseIn,
│   │       OneTimePurchasePatch,
│   │       OneTimePurchaseOut,
│   │   )
│   │   from shared.mappers.crud_mapper import CRUDMapper
│   │
│   │   class OneTimePurchaseMapper(
│   │       CRUDMapper[OneTimePurchase, OneTimePurchaseIn, OneTimePurchasePatch, OneTimePurchaseOut]
│   │   ):
│   │       model_cls  = OneTimePurchase
│   │       out_schema = OneTimePurchaseOut
│   │   ```
│   │
│   ├── subscription.py
│   │
│   │   ```py
│   │   # services/billing-service/src/mappers/subscription_mapper.py
│   │   """Mapper for subscription model to response schemas."""
│   │
│   │   from shared.mappers.crud_mapper import CRUDMapper
│   │
│   │   from ..models import Subscription, BillingPlan
│   │   from ..schemas.subscription import SubscriptionIn, SubscriptionPatch, SubscriptionOut, SubscriptionCreateOut
│   │   from ..mappers import BillingPlanMapper
│   │
│   │   class SubscriptionMapper(CRUDMapper[
│   │       Subscription, SubscriptionIn, SubscriptionPatch, SubscriptionOut
│   │   ]):
│   │       model_cls = Subscription
│   │       out_schema = SubscriptionOut
│   │
│   │       @staticmethod
│   │       def to_create_out(subscription: Subscription, plan: BillingPlan, url: str) -> SubscriptionCreateOut:
│   │           return SubscriptionCreateOut(
│   │               subscription_id=subscription.id,
│   │               confirmation_url=url,
│   │               status=subscription.status,
│   │               plan_details=BillingPlanMapper().to_out(plan),
│   │           )
│   │   ```
│   │
│   └── trial_extension.py
│
│       ```py
│       # services/billing-service/src/mappers/trial_extension_mapper.py
│       """Mapper for trial extension model to response schemas."""
│
│       from ..models import TrialExtension
│       from ..schemas.trial_extension import TrialExtensionIn, TrialExtensionOut, TrialExtensionPatch
│       from shared.mappers.crud_mapper import CRUDMapper
│
│       class TrialExtensionMapper(
│           CRUDMapper[TrialExtension, TrialExtensionIn, TrialExtensionPatch, TrialExtensionOut]
│       ):
│           model_cls  = TrialExtension
│           out_schema = TrialExtensionOut
│       ```
│
├── models/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/models/__init__.py
│   │   """Database models for billing service."""
│   │   from shared.database.base import Base, TimestampedMixin
│   │   from shared.database.base import MerchantMixin
│   │   from .billing_plan import BillingPlan, BillingInterval
│   │   from .one_time_purchase import OneTimePurchase, PurchaseStatus
│   │   from .subscription import Subscription, SubscriptionStatus
│   │   from .trial_extension import TrialExtension, TrialExtensionReason
│   │
│   │
│   │   __all__ = [
│   │       # Base (from shared)
│   │       "Base",
│   │       "TimestampedMixin",
│   │       # Local mixins
│   │       "MerchantMixin",
│   │       # One-time purchase
│   │       "OneTimePurchase",
│   │       "PurchaseStatus",
│   │       # Subscription
│   │       "Subscription",
│   │       "SubscriptionStatus",
│   │       # Trial extension
│   │       "TrialExtension",
│   │       "TrialExtensionReason",
│   │       # Billing Plan
│   │       "BillingPlan",
│   │       "BillingInterval",
│   │   ]
│   │
│   │
│   │   ```
│   │
│   ├── billing_plan.py
│   │
│   │   ```py
│   │
│   │   # services/billing-service/src/models/subscription.py
│   │   """Subscription model for billing service."""
│   │
│   │   from shared.database.base import Base, TimestampedMixin
│   │   from decimal import Decimal
│   │   from typing import Optional, List
│   │   from sqlalchemy import String, Integer, Boolean, Numeric, JSON, Enum as SQLEnum, Index, Text
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   from sqlalchemy.ext.mutable import MutableList, MutableDict
│   │   from sqlalchemy.types import JSON
│   │
│   │   from .enums import BillingInterval
│   │
│   │
│   │   class BillingPlan(Base, TimestampedMixin):
│   │       """Available billing plans"""
│   │
│   │       __tablename__ = "billing_plans"
│   │
│   │       id: Mapped[str] = mapped_column(String(100), primary_key=True)  # plan_basic, plan_premium
│   │       name: Mapped[str] = mapped_column(String(255))
│   │       description: Mapped[str] = mapped_column(Text)
│   │       credits_included: Mapped[int] = mapped_column(Integer, default=0)
│   │       price_amount: Mapped[Decimal] = mapped_column(Numeric(10, 2))
│   │       billing_interval: Mapped[BillingInterval] = mapped_column(
│   │           SQLEnum(BillingInterval), default=BillingInterval.MONTHLY
│   │       )
│   │
│   │       # Features and Limits
│   │       features: Mapped[List[str]] = mapped_column(MutableList.as_mutable(JSON), default=list)
│   │       credit_rate_per_order: Mapped[int] = mapped_column(Integer, default=1)
│   │       max_monthly_orders: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
│   │
│   │       # Availability
│   │       is_active: Mapped[bool] = mapped_column(Boolean, default=True)
│   │       is_featured: Mapped[bool] = mapped_column(Boolean, default=False)
│   │       sort_order: Mapped[int] = mapped_column(Integer, default=0)
│   │       extra_metadata: Mapped[dict] = mapped_column(MutableDict.as_mutable(JSON), default=dict)
│   │
│   │       __table_args__ = (
│   │           Index("idx_plan_active_sort", "is_active", "sort_order"),
│   │       )
│   │   ```
│   │
│   ├── enums.py
│   │
│   │   ```py
│   │   from enum import Enum
│   │
│   │   class BillingInterval(str, Enum):
│   │       MONTHLY = "EVERY_30_DAYS"     # Shopify monthly interval
│   │       ANNUAL = "ANNUAL"             # Shopify annual interval
│   │
│   │   class TrialExtensionReason(str, Enum):
│   │       SUPPORT_REQUEST = "support_request"
│   │       TECHNICAL_ISSUE = "technical_issue"
│   │       ONBOARDING_ASSISTANCE = "onboarding_assistance"
│   │       ADMIN_DISCRETION = "admin_discretion"
│   │   ```
│   │
│   ├── one_time_purchase.py
│   │
│   │   ```py
│   │
│   │   # services/billing-service/src/models/one_time_purchase.py
│   │   from shared.database.base import Base, TimestampedMixin, MerchantMixin
│   │   from uuid import UUID, uuid4
│   │   from enum import Enum
│   │   from datetime import datetime
│   │   from decimal import Decimal
│   │   from typing import Optional
│   │   from sqlalchemy import String, Integer, DateTime, Numeric, JSON, Enum as SQLEnum, Index
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   from sqlalchemy.dialects.postgresql import UUID as PGUUID
│   │   from sqlalchemy.ext.mutable import MutableDict
│   │
│   │
│   │   class PurchaseStatus(str, Enum):
│   │       PENDING = "PENDING"           # Charge created but not completed
│   │       COMPLETED = "COMPLETED"       # Payment successful
│   │       CANCELLED = "CANCELLED"       # Charge cancelled
│   │       FAILED = "FAILED"             # Payment failed
│   │
│   │
│   │   class OneTimePurchase(Base, TimestampedMixin, MerchantMixin):
│   │       """One-time credit purchases"""
│   │
│   │       __tablename__ = "one_time_purchases"
│   │
│   │       id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True, default=uuid4)
│   │
│   │       # Shopify Integration
│   │       shopify_charge_id: Mapped[str] = mapped_column(String(255), unique=True, index=True)
│   │
│   │       # Purchase Details
│   │       credits_purchased: Mapped[int] = mapped_column(Integer, default=0)
│   │       price_amount: Mapped[Decimal] = mapped_column(Numeric(10, 2))
│   │       description: Mapped[str] = mapped_column(String(500))
│   │
│   │       # Status
│   │       status: Mapped[PurchaseStatus] = mapped_column(SQLEnum(PurchaseStatus), default=PurchaseStatus.PENDING, index=True)
│   │
│   │       # Timestamps
│   │       completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │
│   │       # Metadata
│   │       extra_metadata: Mapped[dict] = mapped_column(MutableDict.as_mutable(JSON), default=dict)
│   │
│   │       __table_args__ = (
│   │           Index("idx_purchase_merchant_status", "merchant_id", "status"),
│   │           Index("idx_purchase_shopify_id", "shopify_charge_id"),
│   │       )
│   │   ```
│   │
│   ├── subscription.py
│   │
│   │   ```py
│   │
│   │   # services/billing-service/src/models/subscription.py
│   │   from shared.database.base import Base, TimestampedMixin, MerchantMixin
│   │   from uuid import UUID, uuid4
│   │   from enum import Enum
│   │   from datetime import datetime
│   │   from decimal import Decimal
│   │   from typing import Optional
│   │   from sqlalchemy import String, Integer, Boolean, DateTime, Numeric, JSON, Enum as SQLEnum, Index, Text
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   from sqlalchemy.dialects.postgresql import UUID as PGUUID
│   │   from sqlalchemy.ext.mutable import MutableDict
│   │   from .enums import BillingInterval
│   │
│   │   class SubscriptionStatus(str, Enum):
│   │       PENDING = "PENDING"           # Created but not yet charged
│   │       ACTIVE = "ACTIVE"             # Successfully charged and active
│   │       CANCELLED = "CANCELLED"       # Cancelled by merchant or admin
│   │       EXPIRED = "EXPIRED"           # Billing failed or expired
│   │       FROZEN = "FROZEN"             # Temporarily suspended
│   │
│   │
│   │   class Subscription(Base, TimestampedMixin, MerchantMixin):
│   │       """Subscription model for recurring billing"""
│   │
│   │       __tablename__ = "subscriptions"
│   │
│   │       id: Mapped[UUID] = mapped_column(
│   │           PGUUID(as_uuid=True), primary_key=True, default=uuid4
│   │       )
│   │
│   │       # Shopify Integration
│   │       shopify_subscription_id: Mapped[str] = mapped_column(String(255), unique=True, index=True)
│   │       shopify_charge_id: Mapped[Optional[str]] = mapped_column(String(255), unique=True, nullable=True)
│   │
│   │       # Plan Details
│   │       plan_id: Mapped[str] = mapped_column(String(100), index=True)
│   │       plan_name: Mapped[str] = mapped_column(String(255))
│   │       plan_description: Mapped[str] = mapped_column(Text)
│   │       credits_included: Mapped[int] = mapped_column(Integer, default=0)
│   │       price_amount: Mapped[Decimal] = mapped_column(Numeric(10, 2))
│   │       billing_interval: Mapped[BillingInterval] = mapped_column(SQLEnum(BillingInterval), default=BillingInterval.MONTHLY)
│   │
│   │       # Status Management
│   │       status: Mapped[SubscriptionStatus] = mapped_column(
│   │           SQLEnum(SubscriptionStatus), default=SubscriptionStatus.PENDING, index=True
│   │       )
│   │
│   │       # Billing Cycle
│   │       trial_start_date: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
│   │       trial_end_date: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │       activated_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │       next_billing_date: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │       cancelled_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │       expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
│   │
│   │       # Configuration
│   │       auto_renewal: Mapped[bool] = mapped_column(Boolean, default=True)
│   │       proration_enabled: Mapped[bool] = mapped_column(Boolean, default=True)
│   │
│   │       # Metadata
│   │       extra_metadata: Mapped[dict] = mapped_column(MutableDict.as_mutable(JSON), default=dict)
│   │
│   │       __table_args__ = (
│   │           Index("idx_subscription_merchant_status", "merchant_id", "status"),
│   │           Index("idx_subscription_shopify_id", "shopify_subscription_id"),
│   │           Index("idx_subscription_next_billing", "next_billing_date"),
│   │       )
│   │   ```
│   │
│   └── trial_extension.py
│
│       ```py
│       # services/billing-service/src/models/subscription.py
│       from shared.database.base import Base, TimestampedMixin, MerchantMixin
│       from enum import Enum
│       from uuid import UUID, uuid4
│       from datetime import datetime
│       from sqlalchemy import String, Integer, DateTime, Index, Enum as SQLEnum, Boolean
│       from sqlalchemy.orm import Mapped, mapped_column
│       from sqlalchemy.dialects.postgresql import UUID as PGUUID
│
│       from .enums import TrialExtensionReason
│
│
│
│       class TrialExtension(Base, TimestampedMixin, MerchantMixin):
│           """Trial period extensions"""
│
│           __tablename__ = "trial_extensions"
│
│           id: Mapped[UUID] = mapped_column(
│               PGUUID(as_uuid=True), primary_key=True, default=uuid4
│           )
│
│           # Extension Details
│           days_added: Mapped[int] = mapped_column(Integer)
│           reason: Mapped[TrialExtensionReason] = mapped_column(SQLEnum(TrialExtensionReason), nullable=False)
│           extended_by: Mapped[str] = mapped_column(String(255))  # admin_user_id or "system"
│
│           # Dates
│           original_trial_end: Mapped[datetime] = mapped_column(DateTime(timezone=True))
│           new_trial_end: Mapped[datetime] = mapped_column(DateTime(timezone=True))
│
│           revoked: Mapped[bool] = mapped_column(Boolean, default=False)
│
│           __table_args__ = (
│               Index("idx_extension_merchant_created", "merchant_id", "created_at"),
│           )
│       ```
│
├── repositories/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/repositories/__init__.py
│   │   """Repositories for billing service."""
│   │   from .billing_plan import BillingPlanRepository
│   │   from .trial_extension import TrialExtensionRepository
│   │   from .one_time_purchase import OneTimePurchaseRepository
│   │   from .subscription import SubscriptionRepository
│   │
│   │   __all__ = [
│   │       "BillingPlanRepository",
│   │       "TrialExtensionRepository",
│   │       "OneTimePurchaseRepository",
│   │       "SubscriptionRepository",
│   │   ]
│   │
│   │
│   │   ```
│   │
│   ├── billing_plan.py
│   │
│   │   ```py
│   │   # services/billing-service/src/repositories/billing_repository.py
│   │   from shared.database import Repository
│   │   from sqlalchemy import select
│   │   from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
│   │   from typing import List
│   │
│   │   from ..models import BillingPlan
│   │   from ..exceptions import BillingPlanNotFoundError
│   │
│   │
│   │   class BillingPlanRepository(Repository[BillingPlan]):
│   │       """Repository for billing plan operations"""
│   │
│   │       def __init__(self,
│   │                   model_class: type[BillingPlan],
│   │                   session_factory: async_sessionmaker[AsyncSession]):
│   │           """Initialize the repository with model class and session factory"""
│   │           super().__init__(model_class, session_factory)
│   │
│   │       async def create(self, plan_data: BillingPlan) -> BillingPlan | None:
│   │           """Create a new billing plan"""
│   │           async for session in self._session():
│   │               session.add(plan_data)
│   │               await session.commit()
│   │               await session.refresh(plan_data)
│   │               return plan_data
│   │
│   │       async def patch(self, plan_id: str, patch_data: BillingPlan) -> BillingPlan | None:
│   │           """Patch an existing billing plan"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(self.model.id == plan_id)
│   │               result = await session.execute(stmt)
│   │               plan = result.scalar_one_or_none()
│   │               if not plan:
│   │                   raise BillingPlanNotFoundError(f"Billing plan {plan_id} not found")
│   │
│   │               for key, value in patch_data.__dict__.items():
│   │                   setattr(plan, key, value)
│   │
│   │               await session.commit()
│   │               await session.refresh(plan)
│   │               return plan
│   │
│   │       async def get_all_plans(self) -> List[BillingPlan] | None:
│   │           """Get all billing plans"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).order_by(self.model.sort_order, self.model.name)
│   │               result = await session.execute(stmt)
│   │               return list(result.scalars().all())
│   │
│   │       async def find_active_plans(self) -> List[BillingPlan]:
│   │           """Find all active plans ordered by sort_order"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   self.model.is_active == True
│   │               ).order_by(self.model.sort_order, self.model.name)
│   │               result = await session.execute(stmt)
│   │               return list(result.scalars().all())
│   │           return []
│   │
│   │       async def find_plan_by_id(self, plan_id: str) -> BillingPlan:
│   │           """Find a billing plan by its ID"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   self.model.id == plan_id
│   │               )
│   │               result = await session.execute(stmt)
│   │               plan = result.scalar_one_or_none()
│   │               if plan:
│   │                   return plan
│   │
│   │           # Ensure an exception is raised if no plan is found
│   │           raise BillingPlanNotFoundError(f"Billing plan {plan_id} not found")
│   │   ```
│   │
│   ├── one_time_purchase.py
│   │
│   │   ```py
│   │   # services/billing-service/src/repositories/one_time_purchase_repository.py
│   │   from shared.database import Repository
│   │   from sqlalchemy import select
│   │   from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
│   │   from typing import Optional, List
│   │
│   │   from ..models import OneTimePurchase
│   │   from uuid import UUID
│   │
│   │
│   │   class OneTimePurchaseRepository(Repository[OneTimePurchase]):
│   │       """Repository for one-time purchase operations"""
│   │
│   │       def __init__(self,
│   │                   model_class: type[OneTimePurchase],
│   │                   session_factory: async_sessionmaker[AsyncSession]):
│   │           super().__init__(model_class, session_factory)
│   │
│   │       async def find_by_shopify_id(self, shopify_charge_id: str) -> Optional[OneTimePurchase]:
│   │           """Find purchase by Shopify charge ID"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   self.model.shopify_charge_id == shopify_charge_id
│   │               )
│   │               result = await session.execute(stmt)
│   │               return result.scalar_one_or_none()
│   │
│   │       async def find_by_merchant(self, merchant_id: UUID) -> List[OneTimePurchase]:
│   │           """Find all purchases for merchant"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   self.model.merchant_id == merchant_id
│   │               ).order_by(self.model.created_at.desc())
│   │               result = await session.execute(stmt)
│   │               return list(result.scalars().all())
│   │           return []
│   │   ```
│   │
│   ├── subscription.py
│   │
│   │   ```py
│   │   # services/billing-service/src/repositories/subscription_repository.py
│   │   from shared.database import Repository
│   │   from sqlalchemy import select, and_
│   │   from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
│   │   from typing import Optional, List
│   │
│   │   from ..models import Subscription, SubscriptionStatus
│   │   from uuid import UUID
│   │
│   │
│   │   class SubscriptionRepository(Repository[Subscription]):
│   │       """Repository for subscription operations"""
│   │
│   │       def __init__(self,
│   │                   model_class: type[Subscription],
│   │                   session_factory: async_sessionmaker[AsyncSession]):
│   │           super().__init__(model_class, session_factory)
│   │
│   │       async def find_by_shopify_id(self, shopify_subscription_id: str) -> Optional[Subscription]:
│   │           """Find subscription by Shopify ID"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   self.model.shopify_subscription_id == shopify_subscription_id
│   │               )
│   │               result = await session.execute(stmt)
│   │               return result.scalar_one_or_none()
│   │
│   │       async def find_active_by_merchant(self, merchant_id: UUID) -> Optional[Subscription]:
│   │           """Find active subscription for merchant"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   and_(
│   │                       self.model.merchant_id == merchant_id,
│   │                       self.model.status == SubscriptionStatus.ACTIVE
│   │                   )
│   │               )
│   │               result = await session.execute(stmt)
│   │               return result.scalar_one_or_none()
│   │
│   │       async def find_by_merchant(self, merchant_id: UUID) -> List[Subscription]:
│   │           """Find all subscriptions for merchant"""
│   │           async for session in self._session():
│   │               stmt = select(self.model).where(
│   │                   self.model.merchant_id == merchant_id
│   │               ).order_by(self.model.created_at.desc())
│   │               result = await session.execute(stmt)
│   │               return list(result.scalars().all())
│   │           return []
│   │   ```
│   │
│   └── trial_extension.py
│
│       ```py
│       from __future__ import annotations
│
│       from datetime import datetime
│       from typing import List
│       from uuid import UUID
│
│       from sqlalchemy import select, func
│       from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
│
│       from shared.database import Repository
│       from ..models import TrialExtension
│
│
│       class TrialExtensionRepository(Repository[TrialExtension]):
│           """DB helpers for trial‑extension rows."""
│
│           def __init__(self, model_class: type[TrialExtension], session_factory: async_sessionmaker[AsyncSession]):
│               super().__init__(model_class, session_factory)
│
│           async def find_by_merchant_id(self, merchant_id: UUID) -> List[TrialExtension]:
│               """All non‑revoked extensions (oldest‑>newest)."""
│               async for session in self._session():
│                   stmt = (
│                       select(self.model)
│                       .where(
│                           self.model.merchant_id == merchant_id,
│                           self.model.revoked.is_(False),
│                       )
│                       .order_by(self.model.created_at)
│                   )
│                   result = await session.execute(stmt)
│                   return list(result.scalars().all())
│               return []
│
│           async def count_by_merchant_id(self, merchant_id: UUID) -> int:
│               async for session in self._session():
│                   stmt = (
│                       select(func.count())
│                       .select_from(self.model)
│                       .where(
│                           self.model.merchant_id == merchant_id,
│                           self.model.revoked.is_(False),
│                       )
│                   )
│                   result = await session.execute(stmt)
│                   return int(result.scalar_one())
│               return 0
│
│           async def latest_trial_end(self, merchant_id: UUID) -> datetime | None:
│               """Return the most recently effective trial‑end date, or None."""
│               async for session in self._session():
│                   stmt = (
│                       select(func.max(self.model.new_trial_end))
│                       .where(
│                           self.model.merchant_id == merchant_id,
│                           self.model.revoked.is_(False),
│                       )
│                   )
│                   result = await session.execute(stmt)
│                   return result.scalar_one()
│               return None
│       ```
│
├── schemas/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/schemas/__init__.py
│   │   """Schemas for billing service."""
│   │   from .billing_plan import BillingPlanIn, BillingPlanPatch, BillingPlanOut
│   │   from .subscription import (
│   │       SubscriptionIn,
│   │       SubscriptionCreateIn,
│   │       SubscriptionPatch,
│   │       SubscriptionOut,
│   │       SubscriptionCreateOut,
│   │
│   │   )
│   │   from .one_time_purchase import OneTimePurchaseIn, OneTimePurchaseOut
│   │   from .trial_extension import TrialExtensionIn, TrialExtensionOut
│   │
│   │   __all__ = [
│   │       "BillingPlanIn",
│   │       "BillingPlanPatch",
│   │       "BillingPlanOut",
│   │       "SubscriptionIn",
│   │       "SubscriptionCreateIn",
│   │       "SubscriptionPatch",
│   │       "SubscriptionOut",
│   │       "SubscriptionCreateOut",
│   │       "OneTimePurchaseIn",
│   │       "OneTimePurchaseOut",
│   │       "TrialExtensionIn",
│   │       "TrialExtensionOut",
│   │   ]
│   │   ```
│   │
│   ├── billing_plan.py
│   │
│   │   ```py
│   │   # services/billing-service/src/schemas/billing_plan.py
│   │   """Schemas for billing plans."""
│   │
│   │   from pydantic import BaseModel, Field, ConfigDict
│   │   from typing import Optional, List
│   │   from decimal import Decimal
│   │   from datetime import datetime
│   │   from ..models import BillingInterval
│   │
│   │   # ---------- IN ---------- #
│   │   class BillingPlanIn(BaseModel):
│   │       id: str = Field(..., max_length=100)          # e.g. "plan_basic"
│   │       name: str = Field(..., max_length=255)
│   │       description: str = Field(..., max_length=1000)
│   │       credits_included: int = Field(..., ge=0)
│   │       price_amount: Decimal = Field(..., ge=0)
│   │       billing_interval: BillingInterval = BillingInterval.MONTHLY
│   │       features: List[str] = []
│   │       credit_rate_per_order: int = Field(1, ge=1)
│   │       max_monthly_orders: Optional[int] = Field(None, ge=1)
│   │       is_active: bool = True
│   │       is_featured: bool = False
│   │       sort_order: int = 0
│   │
│   │       model_config = ConfigDict(extra="forbid")
│   │
│   │   # ---------- PATCH ---------- #
│   │   class BillingPlanPatch(BaseModel):
│   │       name: str | None = Field(None, max_length=255)
│   │       description: str | None = Field(None, max_length=1000)
│   │       price_amount: Decimal | None = Field(None, ge=0)
│   │       is_active: bool | None = None
│   │       is_featured: bool | None = None
│   │       sort_order: int | None = None
│   │
│   │       model_config = ConfigDict(extra="forbid")
│   │
│   │   # ---------- OUT ---------- #
│   │   class BillingPlanOut(BaseModel):
│   │       id: str
│   │       name: str
│   │       description: str
│   │       credits_included: int
│   │       price_amount: Decimal
│   │       billing_interval: BillingInterval
│   │       features: List[str]
│   │       credit_rate_per_order: int
│   │       max_monthly_orders: Optional[int]
│   │       is_active: bool
│   │       is_featured: bool
│   │       sort_order: int
│   │       created_at: datetime
│   │       updated_at: datetime
│   │
│   │       model_config = ConfigDict(from_attributes=True)
│   │   ```
│   │
│   ├── one_time_purchase.py
│   │
│   │   ```py
│   │   # services/billing-service/src/schemas/one_time_purchase.py
│   │   """Schemas for one-time purchase model."""
│   │
│   │   from pydantic import BaseModel, Field, ConfigDict
│   │   from uuid import UUID
│   │   from decimal import Decimal
│   │   from datetime import datetime
│   │   from typing import Optional
│   │   from ..models import PurchaseStatus
│   │
│   │   # ---------- IN ---------- #
│   │   class OneTimePurchaseIn(BaseModel):
│   │       merchant_id: UUID
│   │       merchant_domain: str = Field(..., max_length=255)
│   │       shopify_charge_id: str = Field(..., max_length=255)
│   │       credits_purchased: int = Field(..., ge=1)
│   │       price_amount: Decimal = Field(..., ge=0)
│   │       description: str = Field(..., max_length=500)
│   │       status: PurchaseStatus = PurchaseStatus.PENDING
│   │       completed_at: Optional[datetime] = None
│   │       extra_metadata: dict = {}
│   │
│   │       model_config = ConfigDict(extra="forbid")
│   │
│   │   # ---------- OUT ---------- #
│   │   class OneTimePurchaseOut(BaseModel):
│   │       id: UUID
│   │       merchant_id: UUID
│   │       shopify_charge_id: str
│   │       credits_purchased: int
│   │       price_amount: Decimal
│   │       description: str
│   │       status: PurchaseStatus
│   │       completed_at: Optional[datetime]
│   │       metadata: dict
│   │       created_at: datetime
│   │       updated_at: datetime
│   │
│   │       model_config = ConfigDict(from_attributes=True)
│   │   ```
│   │
│   ├── subscription.py
│   │
│   │   ```py
│   │   # services/billing-service/src/schemas/subscription.py
│   │   from pydantic import BaseModel, Field, ConfigDict
│   │   from uuid import UUID
│   │   from decimal import Decimal
│   │   from datetime import datetime
│   │   from ..models import BillingInterval, SubscriptionStatus
│   │   from ..schemas.billing_plan import BillingPlanOut
│   │
│   │   # ---------- IN ---------- #
│   │   class SubscriptionIn(BaseModel):
│   │       merchant_id: UUID
│   │       merchant_domain: str = Field(..., max_length=255)
│   │       shopify_subscription_id: str = Field(..., max_length=255)
│   │       shopify_charge_id: str | None = Field(None, max_length=255)
│   │       plan_id: str = Field(..., max_length=100)
│   │       plan_name: str
│   │       plan_description: str | None = None
│   │       credits_included: int = Field(..., ge=0)
│   │       price_amount: Decimal = Field(..., ge=0)
│   │       billing_interval: BillingInterval = BillingInterval.MONTHLY
│   │       status: SubscriptionStatus = SubscriptionStatus.PENDING
│   │       trial_start_date: datetime | None = None
│   │       trial_end_date:   datetime | None = None
│   │       auto_renewal: bool = True
│   │       proration_enabled: bool = True
│   │       extra_metadata: dict = {}
│   │
│   │       model_config = ConfigDict(extra='forbid')
│   │
│   │   # ---------- PATCH ---------- #
│   │   class SubscriptionPatch(BaseModel):
│   │       plan_id: str | None = Field(None, max_length=100)
│   │       status: SubscriptionStatus | None = None
│   │       cancelled_at: datetime | None = None
│   │       expires_at:   datetime | None = None
│   │       next_billing_date: datetime | None = None
│   │       auto_renewal: bool | None = None
│   │       proration_enabled: bool | None = None
│   │
│   │       model_config = ConfigDict(extra='forbid')
│   │
│   │   # ---------- OUT ---------- #
│   │   class SubscriptionOut(BaseModel):
│   │       id: UUID
│   │       merchant_id: UUID
│   │       shopify_subscription_id: str
│   │       plan_id: str
│   │       plan_name: str
│   │       credits_included: int
│   │       price_amount: Decimal
│   │       billing_interval: BillingInterval
│   │       status: SubscriptionStatus
│   │       trial_start_date: datetime | None
│   │       trial_end_date:   datetime | None
│   │       activated_at:    datetime | None
│   │       next_billing_date: datetime | None
│   │       cancelled_at: datetime | None
│   │       expires_at:   datetime | None
│   │       auto_renewal: bool
│   │       proration_enabled: bool
│   │       metadata: dict
│   │       created_at: datetime
│   │       updated_at: datetime
│   │
│   │       model_config = ConfigDict(from_attributes=True)
│   │
│   │   class SubscriptionCreateIn(BaseModel):
│   │       """Payload sent by the storefront to start a new subscription"""
│   │       merchant_id: UUID
│   │       shop_id: str = Field(..., max_length=255)
│   │       plan_id: str = Field(..., max_length=100)
│   │       return_url: str
│   │       test_mode: bool = False
│   │
│   │       model_config = ConfigDict(extra="forbid")
│   │
│   │   class SubscriptionCreateOut(BaseModel):
│   │       subscription_id: UUID
│   │       confirmation_url: str
│   │       status: SubscriptionStatus
│   │       plan_details: BillingPlanOut
│   │
│   │       model_config = ConfigDict(from_attributes=True)
│   │   ```
│   │
│   └── trial_extension.py
│
│       ```py
│       # services/billing-service/src/schemas/trial_extension.py
│       from pydantic import BaseModel, Field, ConfigDict
│       from datetime import datetime
│       from uuid import UUID
│       from ..models.enums import TrialExtensionReason
│
│       # ---------- IN ----------
│       class TrialExtensionIn(BaseModel):
│           merchant_id: UUID
│           additional_days: int = Field(..., ge=1, le=30)
│           reason: TrialExtensionReason
│           extended_by: str = Field(..., max_length=255)
│
│           model_config = ConfigDict(extra="forbid")
│
│       # ---------- OUT ----------
│       class TrialExtensionOut(BaseModel):
│           id: UUID
│           merchant_id: UUID
│           days_added: int
│           reason: TrialExtensionReason
│           extended_by: str
│           original_trial_end: datetime
│           new_trial_end: datetime
│           created_at: datetime
│           updated_at: datetime
│
│           model_config = ConfigDict(from_attributes=True)
│
│       # ---------- STATUS ----------
│       class TrialStatusOut(BaseModel):
│           merchant_id: UUID
│           is_trial_active: bool
│           trial_start_date: datetime
│           trial_end_date: datetime
│           days_remaining: int
│           total_extensions: int
│           total_extension_days: int
│       ```
│
├── services/
│   ├── __init__.py
│   │
│   │   ```py
│   │   # services/billing-service/src/services/__init__.py
│   │   """Repositories for billing service."""
│   │   from .billing import BillingService
│   │   from .trial_extension import TrialService
│   │   from .one_time_purchase import OneTimePurchaseService
│   │
│   │   __all__ = [
│   │       "BillingService",
│   │       "TrialService",
│   │       "OneTimePurchaseService",
│   │   ]
│   │   ```
│   │
│   ├── billing.py
│   │
│   │   ```py
│   │   # services/billing-service/src/services/billing_service.py
│   │   """Main billing service for subscription and payment management."""
│   │
│   │   from __future__ import annotations
│   │   from datetime import datetime, timedelta, timezone
│   │   from typing import List
│   │   from uuid import UUID
│   │   import redis.asyncio as redis
│   │
│   │   from shared.utils.logger import ServiceLogger
│   │
│   │   from ..config import BillingServiceConfig
│   │   from ..events import BillingEventPublisher
│   │   from ..external import ShopifyBillingClient
│   │   from ..exceptions import (
│   │       BillingPlanNotFoundError,
│   │       SubscriptionNotFoundError,
│   │       ConflictError,
│   │   )
│   │   from ..mappers.billing_plan import BillingPlanMapper
│   │   from ..mappers.subscription import SubscriptionMapper
│   │   from ..models import BillingInterval, SubscriptionStatus, Subscription
│   │   from ..repositories import BillingPlanRepository, SubscriptionRepository
│   │   from ..schemas.billing_plan import BillingPlanOut, BillingPlanIn, BillingPlanPatch
│   │   from ..schemas import (
│   │       SubscriptionOut,
│   │       SubscriptionCreateOut,
│   │   )
│   │
│   │
│   │   class BillingService:
│   │       """Main billing service for subscription and payment management"""
│   │
│   │       def __init__(
│   │           self,
│   │           subscription_repo: SubscriptionRepository,
│   │           plan_repo: BillingPlanRepository,
│   │           shopify_client: ShopifyBillingClient,
│   │           event_publisher: BillingEventPublisher,
│   │           billing_mapper: BillingPlanMapper,
│   │           subscription_mapper: SubscriptionMapper,
│   │           redis_client: redis.Redis,
│   │           logger: ServiceLogger,
│   │           config: BillingServiceConfig,
│   │       ):
│   │           self.subscription_repo = subscription_repo
│   │           self.plan_repo = plan_repo
│   │           self.shopify_client = shopify_client
│   │           self.event_publisher = event_publisher
│   │           self.billing_mapper = billing_mapper
│   │           self.subscription_mapper = subscription_mapper
│   │           self.redis_client = redis_client
│   │           self.logger = logger
│   │           self.config = config
│   │
│   │
│   │       async def create_plan(self, plan_data: BillingPlanIn) -> BillingPlanOut:
│   │           """Create a new billing plan"""
│   │           self.logger.info("Creating new billing plan", extra={"plan_data": plan_data})
│   │
│   │           plan = self.billing_mapper.to_model(plan_data)
│   │           plan = await self.plan_repo.create(plan)
│   │           if not plan:
│   │               raise ConflictError("Plan with this ID already exists")
│   │           return self.billing_mapper.to_out(plan)
│   │
│   │       async def patch_plan(self, plan_id: str, patch_data: BillingPlanPatch) -> BillingPlanOut:
│   │           """Partially update an existing billing plan."""
│   │
│   │           self.logger.info(
│   │               "Patching billing plan",
│   │               extra={"plan_id": plan_id, "patch_data": patch_data.model_dump(exclude_unset=True)},
│   │           )
│   │
│   │           plan = await self.plan_repo.find_plan_by_id(plan_id)
│   │           if not plan:
│   │               raise BillingPlanNotFoundError(f"Billing plan {plan_id} not found")
│   │
│   │           self.billing_mapper.patch_model(plan, patch_data)
│   │
│   │           await self.plan_repo.save(plan)
│   │
│   │           return self.billing_mapper.to_out(plan)
│   │
│   │
│   │       async def create_subscription(
│   │           self,
│   │           merchant_id: UUID,
│   │           shop_id: str,
│   │           plan_id: str,
│   │           return_url: str,
│   │           correlation_id: str,
│   │           test_mode: bool = False,
│   │       ) -> SubscriptionCreateOut:
│   │           """Create new subscription and initiate Shopify charge."""
│   │
│   │           self.logger.set_request_context(
│   │               merchant_id=str(merchant_id),
│   │               correlation_id=correlation_id,
│   │           )
│   │           self.logger.info(
│   │               "Creating subscription",
│   │               extra={"plan_id": plan_id, "shop_id": shop_id},
│   │           )
│   │
│   │           # ----------------------------------------------------------------
│   │           # 1. Plan & conflict checks
│   │           # ----------------------------------------------------------------
│   │           plan = await self.plan_repo.find_plan_by_id(plan_id)
│   │           existing = await self.subscription_repo.find_active_by_merchant(merchant_id)
│   │           if existing:
│   │               raise ConflictError("Merchant already has an active subscription")
│   │
│   │           # ----------------------------------------------------------------
│   │           # 2. Shopify side
│   │           # ----------------------------------------------------------------
│   │           shopify_result = await self.shopify_client.create_subscription(
│   │               shop_id=shop_id,
│   │               plan_name=plan.name,
│   │               amount=plan.price_amount,
│   │               credits=plan.credits_included,
│   │               billing_interval=plan.billing_interval,
│   │               return_url=return_url,
│   │               test_mode=test_mode,
│   │           )
│   │
│   │           # ----------------------------------------------------------------
│   │           # 3. Local DB record
│   │           # ----------------------------------------------------------------
│   │           subscription = Subscription(
│   │               merchant_id=merchant_id,
│   │               shopify_subscription_id=shopify_result["appSubscription"]["id"],
│   │               plan_id=plan_id,
│   │               plan_name=plan.name,
│   │               plan_description=plan.description,
│   │               credits_included=plan.credits_included,
│   │               price_amount=plan.price_amount,
│   │               billing_interval=plan.billing_interval,
│   │               status=SubscriptionStatus.PENDING,
│   │           )
│   │           await self.subscription_repo.save(subscription)
│   │
│   │           # ----------------------------------------------------------------
│   │           # 4. Publish domain event
│   │           # ----------------------------------------------------------------
│   │           await self.event_publisher.publish_event(
│   │               "evt.billing.subscription.created",
│   │               payload={
│   │                   "subscription_id": str(subscription.id),
│   │                   "merchant_id": str(merchant_id),
│   │                   "shop_id": shop_id,
│   │                   "plan_id": plan_id,
│   │                   "shopify_subscription_id": shopify_result["appSubscription"]["id"],
│   │                   "confirmation_url": shopify_result["confirmationUrl"],
│   │                   "status": SubscriptionStatus.PENDING,
│   │                   "created_at": subscription.created_at.isoformat(),
│   │               },
│   │               correlation_id=correlation_id,
│   │           )
│   │
│   │           self.logger.info(
│   │               "Subscription created successfully",
│   │               extra={"subscription_id": str(subscription.id)},
│   │           )
│   │
│   │           return SubscriptionCreateOut(
│   │               subscription_id=subscription.id,
│   │               confirmation_url=shopify_result["confirmationUrl"],
│   │               status=subscription.status,
│   │               plan_details=self.billing_mapper.to_out(plan),
│   │           )
│   │
│   │       async def activate_subscription_after_payment(
│   │           self,
│   │           shopify_subscription_id: str,
│   │           payment_data: dict,
│   │           correlation_id: str,
│   │       ) -> None:
│   │           """Mark subscription ACTIVE after successful Shopify payment."""
│   │
│   │           subscription = await self.subscription_repo.find_by_shopify_id(
│   │               shopify_subscription_id
│   │           )
│   │           if not subscription:
│   │               raise SubscriptionNotFoundError(
│   │                   f"Subscription {shopify_subscription_id} not found"
│   │               )
│   │
│   │           subscription.status = SubscriptionStatus.ACTIVE
│   │           subscription.activated_at = datetime.now(timezone.utc)
│   │           subscription.next_billing_date = self._calculate_next_billing_date(subscription)
│   │           await self.subscription_repo.save(subscription)
│   │
│   │           # Credits added event
│   │           await self.event_publisher.publish_event(
│   │               "evt.billing.subscription.activated",
│   │               payload={
│   │                   "subscription_id": str(subscription.id),
│   │                   "merchant_id": str(subscription.merchant_id),
│   │                   "credits_to_add": subscription.credits_included,
│   │                   "transaction_type": "SUBSCRIPTION",
│   │                   "reference_id": shopify_subscription_id,
│   │                   "activated_at": subscription.activated_at,
│   │               },
│   │               correlation_id=correlation_id,
│   │           )
│   │
│   │           # Notification event
│   │           await self.event_publisher.publish_event(
│   │               "evt.billing.notification.subscription_activated",
│   │               payload={
│   │                   "merchant_id": str(subscription.merchant_id),
│   │                   "subscription_id": str(subscription.id),
│   │                   "plan_name": subscription.plan_name,
│   │                   "credits_added": subscription.credits_included,
│   │                   "next_billing_date": subscription.next_billing_date,
│   │               },
│   │               correlation_id=correlation_id,
│   │           )
│   │
│   │       # ------------------------------------------------------------------ #
│   │       # Queries
│   │       # ------------------------------------------------------------------ #
│   │       async def get_all_plans(self) -> List[BillingPlanOut]:
│   │           plans = await self.plan_repo.find_active_plans()
│   │           return self.billing_mapper.list_to_out(plans)
│   │
│   │       async def get_plan_by_id(self, plan_id: str) -> BillingPlanOut:
│   │           plan = await self.plan_repo.find_plan_by_id(plan_id)
│   │           if not plan:
│   │               raise BillingPlanNotFoundError(f"Billing plan {plan_id} not found")
│   │           return self.billing_mapper.to_out(plan)
│   │
│   │       async def get_subscription(self, subscription_id: UUID) -> SubscriptionOut:
│   │           sub = await self.subscription_repo.find_by_id(subscription_id)
│   │           if not sub:
│   │               raise SubscriptionNotFoundError(f"Subscription {subscription_id} not found")
│   │           return self.subscription_mapper.to_out(sub)
│   │
│   │       async def list_merchant_subscriptions(self, merchant_id: UUID) -> List[SubscriptionOut]:
│   │           subs = await self.subscription_repo.find_by_merchant(merchant_id)
│   │           return self.subscription_mapper.list_to_out(subs)
│   │
│   │       # ------------------------------------------------------------------ #
│   │       # Commands
│   │       # ------------------------------------------------------------------ #
│   │       async def cancel_subscription(self, subscription_id: UUID) -> None:
│   │           sub = await self.subscription_repo.find_by_id(subscription_id)
│   │           if not sub:
│   │               raise SubscriptionNotFoundError(f"Subscription {subscription_id} not found")
│   │           await self.subscription_repo.delete(sub)
│   │
│   │       # ------------------------------------------------------------------ #
│   │       # helpers
│   │       # ------------------------------------------------------------------ #
│   │       def _calculate_next_billing_date(self, subscription: Subscription) -> datetime:
│   │           now = datetime.now(timezone.utc)
│   │           if subscription.billing_interval == BillingInterval.MONTHLY:
│   │               return now + timedelta(days=30)
│   │           if subscription.billing_interval == BillingInterval.ANNUAL:
│   │               return now + timedelta(days=365)
│   │           return now + timedelta(days=30)
│   │   ```
│   │
│   ├── one_time_purchase.py
│   │
│   │   ```py
│   │   # services/billing-service/src/services/one_time_purchase_service.py
│   │   """Service for one-time credit purchases."""
│   │
│   │   from datetime import datetime, timezone
│   │   from typing import Optional
│   │
│   │   from shared.api.dependencies import RequestContextDep
│   │   from shared.utils.logger import ServiceLogger
│   │   from ..events import BillingEventPublisher
│   │   from ..external import ShopifyBillingClient
│   │   from ..models import OneTimePurchase, PurchaseStatus
│   │   from ..repositories import OneTimePurchaseRepository
│   │   from ..config import BillingServiceConfig
│   │   from ..exceptions import ConflictError
│   │   from ..mappers import OneTimePurchaseMapper
│   │   from ..schemas import OneTimePurchaseIn, OneTimePurchaseOut
│   │
│   │   class OneTimePurchaseService:
│   │       """Service for one-time credit purchases"""
│   │
│   │       def __init__(
│   │           self,
│   │           purchase_repo: OneTimePurchaseRepository,
│   │           shopify_client: ShopifyBillingClient,
│   │           event_publisher: BillingEventPublisher,
│   │           logger: ServiceLogger,
│   │           config: BillingServiceConfig
│   │       ):
│   │           self.purchase_repo = purchase_repo
│   │           self.shopify_client = shopify_client
│   │           self.event_publisher = event_publisher
│   │           self.logger = logger
│   │           self.config = config
│   │           self.mapper = OneTimePurchaseMapper()
│   │
│   │       async def create_purchase(
│   │           self,
│   │           data: OneTimePurchaseIn,
│   │           ctx: RequestContextDep
│   │       ) -> OneTimePurchaseOut:
│   │           """Create one-time credit purchase"""
│   │
│   │           self.logger.set_request_context(
│   │               merchant_id=str(data.merchant_id),
│   │               correlation_id=ctx.correlation_id
│   │           )
│   │           self.logger.info("Creating one-time purchase", extra={
│   │               "merchant_id": str(data.merchant_id),
│   │               "credits_purchased": data.credits_purchased,
│   │               "description": data.description
│   │           })
│   │
│   │           # Generate return URL for Shopify
│   │           return_url = f"{self.config.frontend_url}/billing/purchase/confirmation?merchant_id={data.merchant_id}&correlation_id={ctx.correlation_id}"
│   │
│   │
│   │           # Create Shopify charge
│   │           shopify_result = await self.shopify_client.create_one_time_charge(
│   │               shop_id=str(data.merchant_id),
│   │               amount=data.price_amount,
│   │               description=data.description,
│   │               return_url=return_url,
│   │               test_mode=self.config.shopify_test_mode
│   │           )
│   │
│   │           # Create local purchase record
│   │           purchase = OneTimePurchase(
│   │               merchant_id=data.merchant_id,
│   │               shopify_charge_id=shopify_result["appPurchaseOneTime"]["id"],
│   │               credits_purchased=credits,
│   │               price_amount=data.price_amount,
│   │               description=data.description,
│   │               status=PurchaseStatus.PENDING
│   │           )
│   │
│   │           await self.purchase_repo.save(purchase)
│   │
│   │           # Publish purchase created event
│   │           await self.event_publisher.publish_event(
│   │               "evt.billing.purchase.created",
│   │               payload={
│   │                   "purchase_id": str(purchase.id),
│   │                   "merchant_id": str(data.merchant_id),
│   │                   "credits_purchased": data.credits_purchased,
│   │                   "price_amount": str(data.price_amount),
│   │                   "confirmation_url": shopify_result["confirmationUrl"],
│   │                   "status": PurchaseStatus.PENDING
│   │               },
│   │               correlation_id=ctx.correlation_id
│   │           )
│   │
│   │           return self.mapper.to_out(purchase)
│   │
│   │       async def complete_purchase(
│   │           self,
│   │           shopify_charge_id: str,
│   │           payment_data: dict,
│   │           correlation_id: Optional[str] = None
│   │       ) -> None:
│   │           """Complete purchase after successful payment"""
│   │
│   │           purchase = await self.purchase_repo.find_by_shopify_id(shopify_charge_id)
│   │           if not purchase:
│   │               raise ConflictError(f"Purchase not found for charge ID {shopify_charge_id}")
│   │
│   │           # Update purchase status
│   │           purchase.status = PurchaseStatus.COMPLETED
│   │           purchase.completed_at = datetime.now(timezone.utc)
│   │
│   │           await self.purchase_repo.save(purchase)
│   │
│   │           # Publish completion event (Credit Service will add credits)
│   │           await self.event_publisher.publish_event(
│   │               "evt.billing.purchase.completed",
│   │               payload={
│   │                   "purchase_id": str(purchase.id),
│   │                   "merchant_id": str(purchase.merchant_id),
│   │                   "credits_purchased": purchase.credits_purchased,
│   │                   "amount_paid": str(purchase.price_amount),
│   │                   "completed_at": purchase.completed_at
│   │               },
│   │               correlation_id=correlation_id
│   │           )
│   │
│   │   ```
│   │
│   └── trial_extension.py
│
│       ```py
│       # services/billing-service/src/services/trial_extension.py
│       """Business logic for trial extensions."""
│
│       from __future__ import annotations
│
│       from datetime import datetime, timedelta, timezone
│       from uuid import UUID
│
│       from shared.utils.logger import ServiceLogger
│
│       from ..config import BillingServiceConfig
│       from ..events import BillingEventPublisher
│       from ..exceptions import ConflictError
│       from ..models import TrialExtension, TrialExtensionReason
│       from ..repositories import TrialExtensionRepository
│       from ..mappers.trial_extension import TrialExtensionMapper
│       from ..schemas.trial_extension import TrialStatusOut, TrialExtensionOut
│
│
│       class TrialService:
│           """Business logic for trials & extensions."""
│
│           def __init__(
│               self,
│               extension_repo: TrialExtensionRepository,
│               extension_mapper: TrialExtensionMapper,
│               event_publisher: BillingEventPublisher,
│               logger: ServiceLogger,
│               config: BillingServiceConfig,
│           ):
│               self.extension_repo = extension_repo
│               self.extension_mapper = extension_mapper
│               self.event_publisher = event_publisher
│               self.logger = logger
│               self.config = config
│
│           async def _compute_trial_window(self, merchant_id: UUID) -> tuple[datetime, datetime, int]:
│               """
│               Returns (trial_start, trial_end, total_extension_days).
│               Uses the earliest extension record as anchor; if none exists,
│               assumes the trial started exactly `trial_period_days` ago.
│               """
│               extensions = await self.extension_repo.find_by_merchant_id(merchant_id)
│
│               if extensions:
│                   earliest_original_end = min(e.original_trial_end for e in extensions)
│                   trial_start = earliest_original_end - timedelta(days=self.config.trial_period_days)
│                   total_ext_days = sum(e.days_added for e in extensions)
│               else:
│                   trial_start = datetime.now(timezone.utc) - timedelta(days=self.config.trial_period_days)
│                   total_ext_days = 0
│
│               trial_end = trial_start + timedelta(
│                   days=self.config.trial_period_days + total_ext_days
│               )
│               return trial_start, trial_end, total_ext_days
│
│           async def get_trial_status(self, merchant_id: UUID) -> TrialStatusOut:
│               trial_start, trial_end, total_ext_days = await self._compute_trial_window(
│                   merchant_id
│               )
│               now = datetime.now(timezone.utc)
│               days_remaining = max(0, (trial_end - now).days)
│
│               return TrialStatusOut(
│                   merchant_id=merchant_id,
│                   is_trial_active=days_remaining > 0,
│                   trial_start_date=trial_start,
│                   trial_end_date=trial_end,
│                   days_remaining=days_remaining,
│                   total_extensions=await self.extension_repo.count_by_merchant_id(
│                       merchant_id
│                   ),
│                   total_extension_days=total_ext_days,
│               )
│
│           async def extend_trial(
│               self,
│               merchant_id: UUID,
│               additional_days: int,
│               reason: TrialExtensionReason,
│               extended_by: str,
│           ) -> TrialExtensionOut:
│               if not (1 <= additional_days <= self.config.max_extension_days):
│                   raise ConflictError(
│                       f"Extension must be between 1‑{self.config.max_extension_days} days"
│                   )
│
│               if (
│                   await self.extension_repo.count_by_merchant_id(merchant_id)
│                   >= self.config.max_trial_extensions
│               ):
│                   raise ConflictError("Maximum trial extensions reached")
│
│               # Current end = existing max(new_trial_end) OR nominal end of base window
│               latest = await self.extension_repo.latest_trial_end(merchant_id)
│               if latest is None:
│                   # base window ends trial_period_days after assumed start
│                   latest = (datetime.now(timezone.utc) - timedelta(days=self.config.trial_period_days)) + timedelta(
│                       days=self.config.trial_period_days
│                   )
│
│               extension = TrialExtension(
│                   merchant_id=merchant_id,
│                   days_added=additional_days,
│                   reason=reason,
│                   extended_by=extended_by,
│                   original_trial_end=latest,
│                   new_trial_end=latest + timedelta(days=additional_days),
│               )
│               await self.extension_repo.save(extension)
│
│               await self.event_publisher.publish_event(
│                   "evt.billing.trial.extended",
│                   payload={
│                       "merchant_id": str(merchant_id),
│                       "extension_id": str(extension.id),
│                       "days_added": additional_days,
│                       "new_trial_end": extension.new_trial_end.isoformat(),
│                       "reason": reason.value,
│                       "extended_by": extended_by,
│                   },
│               )
│
│               return self.extension_mapper.to_out(extension)
│       ```
│
├── __init__.py
├── config.py
│
│   ```py
│   # services/billing-service/src/config.py
│   import os
│   from functools import lru_cache
│   from pydantic import BaseModel, Field, SecretStr
│   from shared.config.loader import merged_config, flatten_config
│   from shared.database import DatabaseConfig, create_database_config
│
│
│   class BillingServiceConfig(BaseModel):
│       """Billing service configuration from YAML + environment"""
│
│       # Service Identity (from shared + service YAML)
│       service_name: str = Field(..., alias="service.name")
│       service_version: str = Field(..., alias="service.version")
│       environment: str
│       debug: bool
│
│       # API Configuration - BOTH PORTS
│       api_host: str = Field(..., alias="api.host")
│       api_port: int = Field(..., alias="api.port")                    # Internal/container port
│       api_external_port: int = Field(..., alias="api.external_port")  # Local development port
│       api_cors_origins: list = Field(..., alias="api.cors_origins")
│
│       # Infrastructure (from shared YAML)
│       infrastructure_nats_url: str = Field(..., alias="infrastructure.nats_url")
│       infrastructure_redis_url: str = Field(..., alias="infrastructure.redis_url")
│
│       # Database Configuration
│       db_enabled: bool = Field(..., alias="database.enabled")
│
│       # Logging (from shared YAML)
│       logging_level: str = Field(..., alias="logging.level")
│       logging_format: str = Field(..., alias="logging.format")
│
│       # Rate Limiting (from shared YAML)
│       rate_limiting_enabled: bool = Field(..., alias="rate_limiting.enabled")
│       rate_limiting_window_seconds: int = Field(..., alias="rate_limiting.window_seconds")
│
│       # Monitoring (from shared YAML)
│       monitoring_metrics_enabled: bool = Field(..., alias="monitoring.metrics_enabled")
│       monitoring_tracing_enabled: bool = Field(..., alias="monitoring.tracing_enabled")
│
│       # Cache (service override of shared defaults)
│       cache_enabled: bool = Field(..., alias="cache.enabled")
│       cache_ttl_seconds: int = Field(..., alias="cache.ttl_seconds")
│
│       # Features from service YAML
│       max_retries: int = Field(alias="features.max_retries", default=3)
│       timeout_seconds: int = Field(alias="features.timeout_seconds", default=30)
│
│       # Billing business rules
│       trial_period_days: int = Field(alias="billing.trial_period_days", default=14)
│       max_trial_extensions: int = Field(alias="billing.max_trial_extensions", default=2)
│       max_extension_days: int = Field(alias="billing.max_extension_days", default=30)
│
│       # Frontend URL for redirects
│       frontend_url: str = Field(alias="frontend.url", default="http://localhost:3000")
│
│       # Shopify configuration
│       shopify_api_version: str = Field(alias="shopify.api_version", default="2024-01")
│       shopify_test_mode: bool = Field(alias="shopify.test_mode", default=False)
│
│       # Secrets from environment (.env)
│       shopify_api_key: SecretStr
│       shopify_api_secret: SecretStr
│
│       @property
│       def database_config(self) -> DatabaseConfig:
│           """Get database configuration"""
│           cfg = create_database_config(prefix="CREDIT_")
│           return cfg
│
│       @property
│       def effective_port(self) -> int:
│           """
│           Get the effective port to use based on environment.
│
│           Logic:
│           - Local development (not in Docker): use external_port
│           - Docker/container environment: use internal port
│           - Environment override: CREDIT_USE_EXTERNAL_PORT=true forces external_port
│           """
│           # Check if explicitly requested to use external port
│           use_external = os.getenv("CREDIT_USE_EXTERNAL_PORT", "false").lower() == "true"
│
│           # Check if running in container (common Docker environment variables)
│           in_container = any([
│               os.getenv("DOCKER_CONTAINER"),
│               os.getenv("HOSTNAME", "").startswith("credit-service"),
│               os.path.exists("/.dockerenv")
│           ])
│
│           if use_external or (not in_container and self.environment == "development"):
│               return self.api_external_port
│           else:
│               return self.api_port
│
│
│   @lru_cache
│   def get_service_config() -> BillingServiceConfig:
│       """Load and cache service configuration"""
│       cfg_dict = merged_config("billing", env_prefix="BILLING")
│       flattened = flatten_config(cfg_dict)
│       return BillingServiceConfig(**flattened)
│   ```
│
├── dependencies.py
│
│   ```py
│   # services/billing-service/src/dependencies.py
│   from typing import Annotated
│   from fastapi import Depends, Request, HTTPException
│   import redis.asyncio as redis
│
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   from .lifecycle import ServiceLifecycle
│   from .config import BillingServiceConfig
│
│   from .services import (
│       BillingService,
│       TrialService,
│       OneTimePurchaseService,
│   )
│
│   from .repositories import (
│       SubscriptionRepository,
│       OneTimePurchaseRepository,
│       BillingPlanRepository,
│       TrialExtensionRepository,
│   )
│
│   from .events import BillingEventPublisher
│
│   from .mappers import (
│       BillingPlanMapper,
│       SubscriptionMapper,
│       OneTimePurchaseMapper,
│       TrialExtensionMapper,
│   )
│
│
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       return request.app.state.lifecycle
│
│
│   def get_config(request: Request) -> BillingServiceConfig:
│       return request.app.state.config
│
│   # Type aliases for core dependencies
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[BillingServiceConfig, Depends(get_config)]
│
│   # Messaging dependencies
│   def get_messaging_wrapper(lifecycle: LifecycleDep) -> JetStreamWrapper:
│       """Get messaging wrapper from lifecycle"""
│       if not lifecycle.messaging_wrapper:
│           raise HTTPException(500, "Messaging not initialized")
│       return lifecycle.messaging_wrapper
│
│
│   def get_event_publisher(
│       wrapper: Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)],
│   ) -> BillingEventPublisher:
│       """Get billing event publisher"""
│       pub = wrapper.get_publisher(BillingEventPublisher)
│       if not pub:
│           raise HTTPException(500, "BillingEventPublisher not initialized")
│       return pub
│
│   # Type aliases for messaging dependencies
│   MessagingDep = Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)]
│   PublisherDep = Annotated[BillingEventPublisher, Depends(get_event_publisher)]
│
│   # Repositories
│   def get_billing_plan_repository(
│       lifecycle: LifecycleDep,
│   ) -> BillingPlanRepository:
│       """Get billing plan repository"""
│       if not lifecycle.plan_repo:
│           raise HTTPException(500, "BillingPlanRepository not initialized")
│       return lifecycle.plan_repo
│
│   def get_subscription_repository(
│       lifecycle: LifecycleDep,
│   ) -> SubscriptionRepository:
│       """Get subscription repository"""
│       if not lifecycle.subscription_repo:
│           raise HTTPException(500, "SubscriptionRepository not initialized")
│       return lifecycle.subscription_repo
│
│   def get_one_time_purchase_repository(
│       lifecycle: LifecycleDep,
│   ) -> OneTimePurchaseRepository:
│       """Get one-time purchase repository"""
│       if not lifecycle.purchase_repo:
│           raise HTTPException(500, "OneTimePurchaseRepository not initialized")
│       return lifecycle.purchase_repo
│
│   def get_trial_extension_repository(
│       lifecycle: LifecycleDep,
│   ) -> TrialExtensionRepository:
│       """Get trial extension repository"""
│       if not lifecycle.extension_repo:
│           raise HTTPException(500, "TrialExtensionRepository not initialized")
│       return lifecycle.extension_repo
│
│   # Type aliases for repositories
│   BillingPlanRepoDep = Annotated[BillingPlanRepository, Depends(get_billing_plan_repository)]
│   SubscriptionRepoDep = Annotated[SubscriptionRepository, Depends(get_subscription_repository)]
│   OneTimePurchaseRepoDep = Annotated[OneTimePurchaseRepository, Depends(get_one_time_purchase_repository)]
│   TrialExtensionRepoDep = Annotated[TrialExtensionRepository, Depends(get_trial_extension_repository)]
│
│   # Services
│   def get_billing_service(lifecycle: LifecycleDep) -> BillingService:
│       """Get billing service"""
│       if not lifecycle.billing_service:
│           raise HTTPException(500, "BillingService not initialized")
│       return lifecycle.billing_service
│
│   def get_trial_service(lifecycle: LifecycleDep) -> TrialService:
│       """Get trial service"""
│       if not lifecycle.trial_service:
│           raise HTTPException(500, "TrialService not initialized")
│       return lifecycle.trial_service
│
│   def get_one_time_purchase_service(lifecycle: LifecycleDep) -> OneTimePurchaseService:
│       """Get one-time purchase service"""
│       if not lifecycle.purchase_service:
│           raise HTTPException(500, "OneTimePurchaseService not initialized")
│       return lifecycle.purchase_service
│
│   # Type aliases for services
│   BillingServiceDep = Annotated[BillingService, Depends(get_billing_service)]
│   TrialServiceDep = Annotated[TrialService, Depends(get_trial_service)]
│   OneTimePurchaseServiceDep = Annotated[OneTimePurchaseService, Depends(get_one_time_purchase_service)]
│
│   # Mappers
│   def get_billing_plan_mapper() -> BillingPlanMapper:
│       """Get billing plan mapper"""
│       return BillingPlanMapper()
│   def get_subscription_mapper() -> SubscriptionMapper:
│       """Get subscription mapper"""
│       return SubscriptionMapper()
│   def get_one_time_purchase_mapper() -> OneTimePurchaseMapper:
│       """Get one-time purchase mapper"""
│       return OneTimePurchaseMapper()
│   def get_trial_extension_mapper() -> TrialExtensionMapper:
│       """Get trial extension mapper"""
│       return TrialExtensionMapper()
│
│   # Type aliases for mappers
│   BillingPlanMapperDep = Annotated[BillingPlanMapper, Depends(get_billing_plan_mapper)]
│   SubscriptionMapperDep = Annotated[SubscriptionMapper, Depends(get_subscription_mapper)]
│   OneTimePurchaseMapperDep = Annotated[OneTimePurchaseMapper, Depends(get_one_time_purchase_mapper)]
│   TrialExtensionMapperDep = Annotated[TrialExtensionMapper, Depends(get_trial_extension_mapper)]
│
│
│   # Utility dependencies
│   def get_redis_client(lifecycle: LifecycleDep) -> redis.Redis:
│       """Get Redis client"""
│       if not lifecycle.redis_client:
│           raise HTTPException(500, "Redis client not initialized")
│       return lifecycle.redis_client
│
│   # Type alias for Redis client
│   RedisClientDep = Annotated[redis.Redis, Depends(get_redis_client)]
│   ```
│
├── exceptions.py
│
│   ```py
│   # services/billing-service/src/exceptions.py
│   """Billing service exceptions using shared error classes.
│   All exceptions are re-exported from shared.errors for consistency
│   across the platform.
│   """
│
│   from shared.errors import (
│       # Base exceptions
│       DomainError,
│       ValidationError,
│       NotFoundError,
│       ConflictError,
│
│       # HTTP exceptions
│       UnauthorizedError,
│       ForbiddenError,
│       ServiceUnavailableError,
│
│       # Database exceptions
│       DatabaseError,
│   )
│
│   class BillingServiceError(DomainError):
│       """Base class for all billing service errors"""
│       pass
│
│   # Billing-specific exceptions
│   class BillingPlanNotFoundError(NotFoundError):
│       """Raised when billing plan is not found"""
│       pass
│
│   class SubscriptionNotFoundError(NotFoundError):
│       """Raised when subscription is not found"""
│       pass
│
│   class InvalidBillingIntervalError(ValidationError):
│       """Raised when billing interval is invalid"""
│       pass
│   class ShopifyBillingError(DomainError):
│       """Raised for errors from Shopify billing API"""
│       pass
│
│   class SubscriptionCreationError(DomainError):
│       """Raised when subscription creation fails"""
│       pass
│
│   class InvalidReturnUrlError(ValidationError):
│       """Raised when return URL is invalid"""
│       pass
│
│   class BillingServiceConfigError(ValidationError):
│       """Raised when billing service configuration is invalid"""
│       pass
│
│   # Export all exceptions
│   __all__ = [
│       "BillingServiceError",
│       "BillingPlanNotFoundError",
│       "SubscriptionNotFoundError",
│       "InvalidBillingIntervalError",
│       "ShopifyBillingError",
│       "SubscriptionCreationError",
│       "InvalidReturnUrlError",
│       "BillingServiceConfigError",
│       # Re-export all shared exceptions
│       "DomainError",
│       "ValidationError",
│       "NotFoundError",
│       "ConflictError",
│       "UnauthorizedError",
│       "ForbiddenError",
│       "ServiceUnavailableError",
│       "DatabaseError",
│   ]
│   ```
│
├── lifecycle.py
│
│   ```py
│   # services/billing-service/src/lifecycle.py
│   from __future__ import annotations
│
│   import asyncio
│   from typing import List, Optional, cast
│   import redis.asyncio as redis
│   from nats.js.api import StreamConfig, RetentionPolicy, StorageType
│
│   from shared.utils.logger import ServiceLogger
│   from shared.database import DatabaseSessionManager, set_database_manager
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│
│   from .config import BillingServiceConfig
│   from .repositories import (
│       SubscriptionRepository,
│       OneTimePurchaseRepository,
│       BillingPlanRepository,
│       TrialExtensionRepository,
│   )
│   from .services import (
│       BillingService,
│       TrialService,
│       OneTimePurchaseService,
│   )
│   from .events import BillingEventPublisher
│   from .clients.shopify import ShopifyBillingClient
│   from .subscribers import (
│       WebhookEventSubscriber,
│       PurchaseWebhookSubscriber,
│       AppUninstalledSubscriber,
│   )
│   from .mappers import (
│       BillingPlanMapper,
│       SubscriptionMapper,
│       OneTimePurchaseMapper,
│       TrialExtensionMapper,
│   )
│
│   from .models import (
│       Subscription,
│       OneTimePurchase,
│       BillingPlan,
│       TrialExtension,
│   )
│
│   from .exceptions import BillingServiceError
│
│
│
│
│   class ServiceLifecycle:
│       """Manages billing service lifecycle and dependencies"""
│
│       def __init__(self, config: BillingServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│
│           # External connections
│           self.messaging_wrapper: Optional[JetStreamWrapper] = None
│           self.db_manager: Optional[DatabaseSessionManager] = None
│           self.redis_client: Optional[redis.Redis] = None
│
│           # Repositories
│           self.subscription_repo: Optional[SubscriptionRepository] = None
│           self.purchase_repo: Optional[OneTimePurchaseRepository] = None
│           self.plan_repo: Optional[BillingPlanRepository] = None
│           self.extension_repo: Optional[TrialExtensionRepository] = None
│
│           # External services
│           self.shopify_client: Optional[ShopifyBillingClient] = None
│
│           # Services
│           self.billing_service: Optional[BillingService] = None
│           self.trial_service: Optional[TrialService] = None
│           self.purchase_service: Optional[OneTimePurchaseService] = None
│
│           # Mappers
│           self.plan_mapper: BillingPlanMapper = BillingPlanMapper()
│           self.subscription_mapper: SubscriptionMapper = SubscriptionMapper()
│           self.purchase_mapper: OneTimePurchaseMapper = OneTimePurchaseMapper()
│           self.extension_mapper: TrialExtensionMapper = TrialExtensionMapper()
│
│           # Event handling
│           self.event_publisher: Optional[BillingEventPublisher] = None
│
│           # bookkeeping
│           self._tasks: List[asyncio.Task] = []
│           self._shutdown_event = asyncio.Event()
│
│       async def startup(self) -> None:
│           """Start all service components"""
│
│           try:
│               self.logger.info("Starting service components...")
│
│               # 1. Initialize database
│               await self._init_database()
│
│               # 2. Initialize Redis
│               await self._init_redis()
│
│               # 3. Initialize messaging
│               await self._init_messaging()
│
│               # 4. Initialize repositories
│               self._init_repositories()
│
│               # 5. Initialize mappers
│               self._init_mappers()
│
│               # 6. Initialize services
│               self._init_local_services()
│
│               # 7. Start subscribers
│               await self._init_subscribers()
│
│               self.logger.info("All service components started successfully")
│
│           except Exception as e:
│               self.logger.error(f"Failed to start service: {e}", exc_info=True)
│               await self.shutdown()
│               raise
│
│       async def shutdown(self) -> None:
│           """Shutdown all service components"""
│
│           self.logger.info("Shutting down service components...")
│
│           # Stop background tasks
│           for t in self._tasks:
│               t.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│
│           # Close Redis
│           if self.redis_client:
│               try:
│                   await self.redis_client.close()
│                   self.logger.info("Redis connection closed")
│               except Exception as e:
│                   self.logger.warning(f"Error closing Redis: {e}")
│
│           # Close messaging
│           if self.messaging_wrapper:
│               try:
│                   await self.messaging_wrapper.close()
│                   self.logger.info("Messaging connection closed")
│               except Exception as e:
│                   self.logger.warning(f"Error closing messaging: {e}")
│
│           # Close database
│           if self.db_manager:
│               try:
│                   await self.db_manager.close()
│                   self.logger.info("Database connection closed")
│               except Exception as e:
│                   self.logger.warning(f"Error closing database: {e}")
│
│           self.logger.info("Service shutdown complete")
│           """Graceful shutdown of all components"""
│           self.logger.info(f"Shutting down {self.config.service_name}")
│
│           # Cancel background tasks
│           for task in self._tasks:
│               task.cancel()
│
│           # Close connections
│           if self.messaging:
│               await self.messaging.close()
│           if self.db_manager:
│               await self.db_manager.close()
│           if self.redis_client:
│               await self.redis_client.close()
│
│           self.logger.info(f"{self.config.service_name} shutdown complete")
│
│       async def _init_messaging(self) -> None:
│           self.messaging_wrapper = JetStreamWrapper(self.logger)
│           await self.messaging_wrapper.connect([self.config.infrastructure_nats_url])
│           self.logger.info("Connected to NATS %s", self.config.infrastructure_nats_url)
│
│           js = self.messaging_wrapper.js
│           cfg = StreamConfig(
│               name      = "BILLING",
│               subjects  = ["cmd.billing.*", "evt.billing.*"],
│               retention = RetentionPolicy.LIMITS,
│               max_age   = 7 * 24 * 60 * 60,
│               max_msgs  = 1_000_000,
│               max_bytes = 1_024 ** 3,
│               storage   = StorageType.FILE,
│               duplicate_window = 60,
│           )
│           try:
│               await js.stream_info("BILLING")
│           except Exception:
│               await js.add_stream(cfg)
│               self.logger.info("Created BILLING stream")
│
│
│       async def _init_database(self) -> None:
│           if not (self.config.db_enabled and self.config.database_config):
│               self.logger.warning("DB disabled; repositories will not be initialised")
│               return
│
│           print("Database URL:", self.config.database_config.database_url)
│
│           self.db_manager = DatabaseSessionManager(
│               database_url=self.config.database_config.database_url,
│               echo=self.config.database_config.DB_ECHO,
│               pool_size=self.config.database_config.DB_POOL_SIZE,
│               max_overflow=self.config.database_config.DB_MAX_OVERFLOW,
│           )
│           await self.db_manager.init()
│           set_database_manager(self.db_manager)
│           self.logger.info("Connected to DB")
│
│           from shared.database.base import Base
│           async with self.db_manager.engine.begin() as conn:
│               await conn.run_sync(Base.metadata.create_all)
│
│       async def _init_redis(self) -> None:
│           """Initialize Redis connection"""
│
│           self.logger.info("Setting up Redis...")
│
│           if not self.config.infrastructure_redis_url:
│               self.logger.warning("INFRASTRUCTURE_REDIS_URL not configured, skipping Redis setup")
│               return
│
│           self.redis_client = redis.from_url(
│               self.config.infrastructure_redis_url,
│               decode_responses=True,
│               retry_on_timeout=True,
│               health_check_interval=30
│           )
│
│           # Test connection
│           await self.redis_client.ping()
│
│           self.logger.info("Redis setup complete")
│
│
│       def _init_repositories(self) -> None:
│           """Initialize repositories"""
│
│           if not self.db_manager:
│               self.logger.warning("DB manager not initialized, repositories will not be set up")
│               return
│
│           self.logger.info("Setting up repositories...")
│
│           session_factory = self.db_manager.session_factory
│
│           self.subscription_repo = SubscriptionRepository(
│               model_class=Subscription,
│               session_factory=session_factory
│           )
│           self.purchase_repo = OneTimePurchaseRepository(
│               model_class=OneTimePurchase,
│               session_factory=session_factory
│           )
│           self.plan_repo = BillingPlanRepository(
│               model_class=BillingPlan,
│               session_factory=session_factory
│           )
│           self.extension_repo = TrialExtensionRepository(
│               model_class=TrialExtension,
│               session_factory=session_factory
│           )
│           self.logger.info("Repositories initialized successfully")
│
│       def _init_mappers(self) -> None:
│           """Initialize mappers"""
│
│           self.logger.info("Setting up mappers...")
│
│           self.plan_mapper = BillingPlanMapper()
│           self.subscription_mapper = SubscriptionMapper()
│           self.purchase_mapper = OneTimePurchaseMapper()
│           self.extension_mapper = TrialExtensionMapper()
│
│           self.logger.info("Mappers initialized successfully")
│
│       async def _init_subscribers(self) -> None:
│           if not self.messaging_wrapper:
│               raise RuntimeError("Messaging wrapper not initialized")
│
│           # ⚠️ Register deps BEFORE launching subscribers – they may receive a
│           # message immediately after pull_subscribe().
│           self.messaging_wrapper.register_dependency(
│               "subscription_repo", self.subscription_repo
│           )
│           self.messaging_wrapper.register_dependency(
│               "purchase_repo", self.purchase_repo
│           )
│           self.messaging_wrapper.register_dependency(
│               "plan_repo", self.plan_repo
│           )
│           self.messaging_wrapper.register_dependency(
│               "extension_repo", self.extension_repo
│           )
│           self.messaging_wrapper.register_dependency("logger", self.logger)
│
│           # Start all subscribers with registered dependencies
│           subscribers = [
│               WebhookEventSubscriber,
│               PurchaseWebhookSubscriber,
│               AppUninstalledSubscriber,
│           ]
│
│           for subscriber_class in subscribers:
│               await self.messaging_wrapper.start_subscriber(subscriber_class)
│
│
│       def _init_local_services(self) -> None:
│           """Initialize local services"""
│
│           self.logger.info("Setting up local services...")
│
│           self.shopify_client = ShopifyBillingClient(
│               api_key=self.config.shopify_api_key,
│               api_secret=self.config.shopify_api_secret,
│               app_url=self.config.shopify_app_url,
│               logger=self.logger
│           )
│
│           if not self.messaging_wrapper:
│               raise RuntimeError("Messaging wrapper is not initialized")
│
│           self.event_publisher = cast(BillingEventPublisher, self.messaging_wrapper.create_publisher(BillingEventPublisher))
│
│           if not self.event_publisher:
│               raise RuntimeError("Event publisher is not initialized")
│
│           if not self.redis_client:
│               raise RuntimeError("Redis client is not initialized")
│
│           if not self.subscription_repo:
│               raise RuntimeError("Subscription repository is not initialized")
│
│           if not self.plan_repo:
│               raise RuntimeError("Billing plan repository is not initialized")
│
│           if not self.purchase_repo:
│               raise RuntimeError("One-time purchase repository is not initialized")
│
│           if not self.extension_repo:
│               raise RuntimeError("Trial extension repository is not initialized")
│
│           if not self.shopify_client:
│               raise RuntimeError("Shopify client is not initialized")
│
│           # Initialize services with dependencies
│           self.logger.info("Initializing local services...")
│
│           self.billing_service = BillingService(
│               subscription_repo=self.subscription_repo,
│               plan_repo=self.plan_repo,
│               shopify_client=self.shopify_client,
│               event_publisher=self.event_publisher,
│               redis_client=self.redis_client,
│               logger=self.logger,
│               config=self.config
│           )
│
│           self.trial_service = TrialService(
│               extension_repo=self.extension_repo,
│               event_publisher=self.event_publisher,
│               logger=self.logger,
│               config=self.config
│           )
│
│           self.purchase_service = OneTimePurchaseService(
│               purchase_repo=self.purchase_repo,
│               event_publisher=self.event_publisher,
│               shopify_client=self.shopify_client,
│               logger=self.logger,
│               config=self.config
│           )
│
│           self.logger.info("Local services initialized successfully")
│
│       def add_task(self, coro) -> asyncio.Task:
│           t = asyncio.create_task(coro)
│           self._tasks.append(t)
│           return t
│
│       async def wait_for_shutdown(self) -> None:
│           await self._shutdown_event.wait()
│
│       def signal_shutdown(self) -> None:
│           self._shutdown_event.set()
│   ```
│
└── main.py

    ```py
    # services/billing-service/src/main.py
    from fastapi import FastAPI
    from contextlib import asynccontextmanager

    from shared.api import setup_middleware
    from shared.utils.logger import create_logger

    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    from .api.v1 import health, plans, subscriptions, payments, trials


    # Create lifecycle manager
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)

    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Application lifespan management"""

        logger.info(
            f"Starting {config.service_name}",
            extra={
                "version": config.service_version,
                "environment": config.environment,
                "api_host": config.api_host,
                "api_port": config.effective_port,
            }
        )

        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger

        try:
            await lifecycle.startup()
            logger.info("Billing Service started successfully")
            yield
        finally:
            logger.info("Shutting down Billing Service")
            await lifecycle.shutdown()
            logger.info("Billing Service stopped")

    def create_application() -> FastAPI:

        # Create FastAPI app
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            lifespan=lifespan,
            description="Billing management service for merchant subscriptions, plans, and purchases",
            exception_handlers={}  # Use shared middleware for exception handling
        )

        setup_middleware(
            app,
            service_name=config.service_name,
            enable_metrics=True
        )

        # Include routers
        app.include_router(health.router, prefix="/api/v1", tags=["Health"])
        app.include_router(plans.router, prefix="/api/v1", tags=["Plans"])
        app.include_router(subscriptions.router, prefix="/api/v1", tags=["Subscriptions"])
        app.include_router(payments.router, prefix="/api/v1", tags=["Payments"])
        app.include_router(trials.router, prefix="/api/v1", tags=["Trials"])

        return app

    app = create_application()

    if __name__ == "__main__":
        import uvicorn

        # Smart port selection
        port = config.effective_port

        logger.info(f"Starting server", extra={
            "internal_port": config.api_port,
            "external_port": config.api_external_port,
            "effective_port": port,
            "environment": config.environment
        })

        uvicorn.run(
            "src.main:app",
            host=config.api_host,
            port=port,
            reload=config.debug
        )
    ```

tests/
└── __init__.py
.python-version
Dockerfile

```
FROM python:3.11-slim AS base

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Install Poetry
RUN pip install poetry==1.6.1
RUN poetry config virtualenvs.create false

# Copy dependency files
COPY pyproject.toml poetry.lock ./

# Copy shared package (relative to service directory)
COPY ../../shared /shared

# Install dependencies
RUN poetry install --no-dev --no-root

# Copy application
COPY . .

# Install application
RUN poetry install --no-dev

# Runtime stage
FROM python:3.11-slim

WORKDIR /app

# Copy from build stage
COPY --from=base /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=base /app /app

# Copy config directory structure (non-secret configs)
COPY config /app/config

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8016/health').raise_for_status()"

# Run application
CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8016"]
```

poetry.lock
pyproject.toml

```toml
[tool.poetry]
name = "billing-service"
version = "1.0.0"
description = "Billing service for subscription and payment management"
authors = ["GlamYouUp Team"]
packages = [{include = "src"}]

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.104.1"
uvicorn = {extras = ["standard"], version = "^0.24.0"}
sqlalchemy = "^2.0.23"
asyncpg = "^0.29.0"
alembic = "^1.12.1"
redis = "^5.0.1"
pydantic = {extras = ["email"], version = "^2.5.0"}
httpx = "^0.25.2"
prometheus-client = "^0.19.0"
nats-py = "^2.6.0"
shared = {path = "../../shared", develop = true}

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
isort = "^5.12.0"
mypy = "^1.7.1"
ruff = "^0.1.6"
httpx = "^0.25.2"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 100
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 100

[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.ruff]
target-version = "py311"
line-length = 100
```

README.md

================================================================================
Output includes file contents
================================================================================
