================================================================================
Directory Structure: /home/bellabe/glam-app/services/token-service
================================================================================

token-service/
prisma/
â””â”€â”€ schema.prisma
src/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ tokens.py
â”‚   â”‚
â”‚   â”‚       ```py
â”‚   â”‚       # services/token-service/src/api/v1/tokens.py
â”‚   â”‚
â”‚   â”‚       from typing import Optional
â”‚   â”‚       from fastapi import APIRouter, Body, Query, status, Request
â”‚   â”‚       from shared.api import ApiResponse, success_response
â”‚   â”‚       from shared.api.dependencies import (
â”‚   â”‚           RequestContextDep,
â”‚   â”‚           ClientAuthDep,
â”‚   â”‚           InternalAuthDep,
â”‚   â”‚           ClientIpDep
â”‚   â”‚       )
â”‚   â”‚       from shared.api.validation import validate_shop_context, validate_service_context
â”‚   â”‚       from shared.utils.exceptions import UnauthorizedError, ValidationError
â”‚   â”‚       from ...dependencies import TokenServiceDep, LoggerDep
â”‚   â”‚       from ...schemas.token import (
â”‚   â”‚           StoreTokenRequest,
â”‚   â”‚           TokenListResponse,
â”‚   â”‚           StoreTokenResponse,
â”‚   â”‚           DeleteTokenResponse
â”‚   â”‚       )
â”‚   â”‚       from ...utils.constants import ALLOWED_READER_SERVICES
â”‚   â”‚
â”‚   â”‚       router = APIRouter(prefix="/api/v1/tokens", tags=["Tokens"])
â”‚   â”‚
â”‚   â”‚       @router.post(
â”‚   â”‚           "",
â”‚   â”‚           response_model=ApiResponse[StoreTokenResponse],
â”‚   â”‚           status_code=status.HTTP_201_CREATED,
â”‚   â”‚           summary="Store or update token"
â”‚   â”‚       )
â”‚   â”‚       async def store_token(
â”‚   â”‚           svc: TokenServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           auth: ClientAuthDep,
â”‚   â”‚           logger: LoggerDep,
â”‚   â”‚           body: StoreTokenRequest = Body(...)
â”‚   â”‚       ):
â”‚   â”‚           """
â”‚   â”‚           Store or update platform token (requires client auth).
â”‚   â”‚           Used by BFF after OAuth callback.
â”‚   â”‚           """
â”‚   â”‚
â”‚   â”‚           # Validate domain matches JWT
â”‚   â”‚           if body.domain != auth.shop:
â”‚   â”‚               raise UnauthorizedError(
â”‚   â”‚                   "Domain mismatch",
â”‚   â”‚                   details={
â”‚   â”‚                       "jwt_domain": auth.shop,
â”‚   â”‚                       "request_domain": body.domain
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           # Store token
â”‚   â”‚           token_id = await svc.store_token(
â”‚   â”‚               request=body,
â”‚   â”‚               correlation_id=ctx.correlation_id
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           return success_response(
â”‚   â”‚               data=StoreTokenResponse(
â”‚   â”‚                   token_id=token_id,
â”‚   â”‚                   status="stored"
â”‚   â”‚               ),
â”‚   â”‚               request_id=ctx.request_id,
â”‚   â”‚               correlation_id=ctx.correlation_id
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚       @router.get(
â”‚   â”‚           "/{merchant_id}",
â”‚   â”‚           response_model=ApiResponse[TokenListResponse],
â”‚   â”‚           summary="Get tokens for merchant"
â”‚   â”‚       )
â”‚   â”‚       async def get_tokens(
â”‚   â”‚           merchant_id: str,
â”‚   â”‚           svc: TokenServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           auth: InternalAuthDep,
â”‚   â”‚           logger: LoggerDep,
â”‚   â”‚           ip: ClientIpDep,
â”‚   â”‚           platform: Optional[str] = Query(None, description="Filter by platform")
â”‚   â”‚       ):
â”‚   â”‚           """
â”‚   â”‚           Retrieve tokens for a merchant (requires internal auth).
â”‚   â”‚           Used by Platform Connector and other internal services.
â”‚   â”‚           """
â”‚   â”‚
â”‚   â”‚           # Validate service is allowed to retrieve tokens
â”‚   â”‚           validate_service_context(
â”‚   â”‚               internal_auth=auth,
â”‚   â”‚               logger=logger,
â”‚   â”‚               allowed_services=ALLOWED_READER_SERVICES,
â”‚   â”‚               operation="retrieve_tokens"
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           # Get tokens
â”‚   â”‚           tokens = await svc.get_tokens(
â”‚   â”‚               merchant_id=merchant_id,
â”‚   â”‚               platform=platform,
â”‚   â”‚               requesting_service=auth.service,
â”‚   â”‚               correlation_id=ctx.correlation_id,
â”‚   â”‚               ip_address=ip
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           return success_response(
â”‚   â”‚               data=TokenListResponse(tokens=tokens),
â”‚   â”‚               request_id=ctx.request_id,
â”‚   â”‚               correlation_id=ctx.correlation_id
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚       @router.delete(
â”‚   â”‚           "/{merchant_id}/{platform}",
â”‚   â”‚           response_model=ApiResponse[DeleteTokenResponse],
â”‚   â”‚           summary="Delete specific token"
â”‚   â”‚       )
â”‚   â”‚       async def delete_token(
â”‚   â”‚           merchant_id: str,
â”‚   â”‚           platform: str,
â”‚   â”‚           svc: TokenServiceDep,
â”‚   â”‚           ctx: RequestContextDep,
â”‚   â”‚           auth: ClientAuthDep,
â”‚   â”‚           logger: LoggerDep
â”‚   â”‚       ):
â”‚   â”‚           """
â”‚   â”‚           Delete a specific token (requires client auth).
â”‚   â”‚           Used when merchant disconnects a platform.
â”‚   â”‚           """
â”‚   â”‚
â”‚   â”‚           # In production, verify merchant ownership
â”‚   â”‚           # For now, just ensure JWT is valid
â”‚   â”‚           if not auth.shop:
â”‚   â”‚               raise UnauthorizedError("Invalid authentication")
â”‚   â”‚
â”‚   â”‚           # Delete token
â”‚   â”‚           deleted = await svc.delete_token(
â”‚   â”‚               merchant_id=merchant_id,
â”‚   â”‚               platform=platform,
â”‚   â”‚               correlation_id=ctx.correlation_id
â”‚   â”‚           )
â”‚   â”‚
â”‚   â”‚           if not deleted:
â”‚   â”‚               logger.warning(
â”‚   â”‚                   f"Token not found for deletion",
â”‚   â”‚                   extra={
â”‚   â”‚                       "merchant_id": merchant_id,
â”‚   â”‚                       "platform": platform
â”‚   â”‚                   }
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚           return success_response(
â”‚   â”‚               data=DeleteTokenResponse(status="deleted"),
â”‚   â”‚               request_id=ctx.request_id,
â”‚   â”‚               correlation_id=ctx.correlation_id
â”‚   â”‚           )
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ listeners.py
â”‚   â””â”€â”€ publishers.py
â”œâ”€â”€ external/
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ token_repository.py
â”‚
â”‚       ```py
â”‚       # services/token-service/src/repositories/token_repository.py
â”‚
â”‚       from typing import Optional, List, Dict, Any
â”‚       from datetime import datetime
â”‚       from uuid import UUID
â”‚       from prisma import Prisma
â”‚       from prisma.models import PlatformToken, TokenAccessLog
â”‚       from shared.utils.logger import ServiceLogger
â”‚
â”‚       class TokenRepository:
â”‚           """Repository for token operations"""
â”‚
â”‚           def __init__(self, prisma: Prisma, logger: ServiceLogger):
â”‚               self.prisma = prisma
â”‚               self.logger = logger
â”‚
â”‚           async def upsert(self, data: Dict[str, Any]) -> PlatformToken:
â”‚               """Create or update token"""
â”‚               return await self.prisma.platformtoken.upsert(
â”‚                   where={
â”‚                       "merchant_id_platform_name": {
â”‚                           "merchant_id": data["merchant_id"],
â”‚                           "platform_name": data["platform_name"]
â”‚                       }
â”‚                   },
â”‚                   update={
â”‚                       "platform_shop_id": data["platform_shop_id"],
â”‚                       "domain": data["domain"],
â”‚                       "encrypted_token": data["encrypted_token"],
â”‚                       "encryption_key_id": data["encryption_key_id"],
â”‚                       "token_type": data["token_type"],
â”‚                       "expires_at": data.get("expires_at"),
â”‚                       "scopes": data.get("scopes"),
â”‚                       "updated_at": datetime.utcnow()
â”‚                   },
â”‚                   create=data
â”‚               )
â”‚
â”‚           async def find_by_merchant(self, merchant_id: str) -> List[PlatformToken]:
â”‚               """Find all tokens for a merchant"""
â”‚               return await self.prisma.platformtoken.find_many(
â”‚                   where={"merchant_id": merchant_id}
â”‚               )
â”‚
â”‚           async def find_by_merchant_platform(
â”‚               self,
â”‚               merchant_id: str,
â”‚               platform_name: str
â”‚           ) -> List[PlatformToken]:
â”‚               """Find tokens for merchant and platform"""
â”‚               return await self.prisma.platformtoken.find_many(
â”‚                   where={
â”‚                       "merchant_id": merchant_id,
â”‚                       "platform_name": platform_name
â”‚                   }
â”‚               )
â”‚
â”‚           async def update_access(
â”‚               self,
â”‚               token_id: str,
â”‚               accessed_by: str
â”‚           ) -> None:
â”‚               """Update access tracking"""
â”‚               await self.prisma.platformtoken.update(
â”‚                   where={"id": token_id},
â”‚                   data={
â”‚                       "last_accessed_by": accessed_by,
â”‚                       "last_accessed_at": datetime.utcnow(),
â”‚                       "access_count": {"increment": 1}
â”‚                   }
â”‚               )
â”‚
â”‚           async def delete(
â”‚               self,
â”‚               merchant_id: str,
â”‚               platform_name: str
â”‚           ) -> Optional[PlatformToken]:
â”‚               """Delete a token"""
â”‚               try:
â”‚                   return await self.prisma.platformtoken.delete(
â”‚                       where={
â”‚                           "merchant_id_platform_name": {
â”‚                               "merchant_id": merchant_id,
â”‚                               "platform_name": platform_name
â”‚                           }
â”‚                       }
â”‚                   )
â”‚               except Exception:
â”‚                   return None
â”‚
â”‚           async def log_access(
â”‚               self,
â”‚               token_id: str,
â”‚               accessed_by: str,
â”‚               access_type: str,
â”‚               success: bool,
â”‚               correlation_id: Optional[str] = None,
â”‚               ip_address: Optional[str] = None,
â”‚               error_message: Optional[str] = None
â”‚           ) -> TokenAccessLog:
â”‚               """Log token access"""
â”‚               return await self.prisma.tokenaccesslog.create(
â”‚                   data={
â”‚                       "token_id": token_id,
â”‚                       "accessed_by": accessed_by,
â”‚                       "access_type": access_type,
â”‚                       "success": success,
â”‚                       "correlation_id": correlation_id,
â”‚                       "ip_address": ip_address,
â”‚                       "error_message": error_message
â”‚                   }
â”‚               )
â”‚       ```
â”‚
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ events.py
â”‚   â””â”€â”€ token.py
â”‚
â”‚       ```py
â”‚       # services/token-service/src/schemas/token.py
â”‚
â”‚       from uuid import UUID
â”‚       from datetime import datetime
â”‚       from pydantic import BaseModel, Field, ConfigDict
â”‚       from typing import Optional, Dict, Any, List
â”‚
â”‚       # Input DTOs
â”‚       class StoreTokenRequest(BaseModel):
â”‚           """Request to store a token"""
â”‚           merchant_id: str = Field(..., description="Internal merchant ID")
â”‚           platform_name: str = Field(..., description="Platform name (shopify, woocommerce, etc)")
â”‚           platform_shop_id: str = Field(..., description="Shop ID in the platform")
â”‚           domain: str = Field(..., description="Full domain")
â”‚           token_data: Dict[str, Any] = Field(..., description="Token data to encrypt")
â”‚           token_type: str = Field(..., description="Token type (oauth, api_key, etc)")
â”‚           expires_at: Optional[datetime] = Field(None, description="Token expiration")
â”‚           scopes: Optional[str] = Field(None, description="OAuth scopes")
â”‚
â”‚           model_config = ConfigDict(
â”‚               json_schema_extra={
â”‚                   "example": {
â”‚                       "merchant_id": "uuid-merchant-id",
â”‚                       "platform_name": "shopify",
â”‚                       "platform_shop_id": "12345678",
â”‚                       "domain": "example.myshopify.com",
â”‚                       "token_data": {
â”‚                           "access_token": "shpat_xxx",
â”‚                           "scope": "read_products,write_orders"
â”‚                       },
â”‚                       "token_type": "oauth",
â”‚                       "expires_at": "2024-12-31T23:59:59Z",
â”‚                       "scopes": "read_products,write_orders"
â”‚                   }
â”‚               }
â”‚           )
â”‚
â”‚       # Output DTOs
â”‚       class TokenData(BaseModel):
â”‚           """Decrypted token data"""
â”‚           platform_name: str
â”‚           platform_shop_id: str
â”‚           domain: str
â”‚           token_data: Dict[str, Any]
â”‚           token_type: str
â”‚           expires_at: Optional[datetime]
â”‚           is_expired: bool
â”‚           scopes: Optional[str]
â”‚
â”‚           model_config = ConfigDict(from_attributes=True)
â”‚
â”‚       class TokenListResponse(BaseModel):
â”‚           """Response with list of tokens"""
â”‚           tokens: List[TokenData]
â”‚
â”‚       class StoreTokenResponse(BaseModel):
â”‚           """Response after storing token"""
â”‚           token_id: str
â”‚           status: str
â”‚
â”‚       class DeleteTokenResponse(BaseModel):
â”‚           """Response after deleting token"""
â”‚           status: str
â”‚       ```
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ encryption_service.py
â”‚   â”‚
â”‚   â”‚   ```py
â”‚   â”‚   # services/token-service/src/services/encryption_service.py
â”‚   â”‚
â”‚   â”‚   import json
â”‚   â”‚   import base64
â”‚   â”‚   from typing import Dict, Any
â”‚   â”‚   from cryptography.fernet import Fernet
â”‚   â”‚   from cryptography.hazmat.primitives import hashes
â”‚   â”‚   from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2
â”‚   â”‚   from shared.utils.logger import ServiceLogger
â”‚   â”‚   from shared.utils.exceptions import InternalError
â”‚   â”‚
â”‚   â”‚   class EncryptionService:
â”‚   â”‚       """Handles token encryption and decryption"""
â”‚   â”‚
â”‚   â”‚       def __init__(self, encryption_key: str, key_id: str, logger: ServiceLogger):
â”‚   â”‚           self.key_id = key_id
â”‚   â”‚           self.logger = logger
â”‚   â”‚           self._cipher = self._create_cipher(encryption_key)
â”‚   â”‚
â”‚   â”‚       def _create_cipher(self, key: str) -> Fernet:
â”‚   â”‚           """Create Fernet cipher from key"""
â”‚   â”‚           # Use PBKDF2 to derive a proper key from the string
â”‚   â”‚           kdf = PBKDF2(
â”‚   â”‚               algorithm=hashes.SHA256(),
â”‚   â”‚               length=32,
â”‚   â”‚               salt=b'token-service-salt',  # In production, use unique salt per key
â”‚   â”‚               iterations=100000,
â”‚   â”‚           )
â”‚   â”‚           key_bytes = base64.urlsafe_b64encode(kdf.derive(key.encode()))
â”‚   â”‚           return Fernet(key_bytes)
â”‚   â”‚
â”‚   â”‚       def encrypt(self, data: Dict[str, Any]) -> str:
â”‚   â”‚           """Encrypt token data"""
â”‚   â”‚           try:
â”‚   â”‚               json_str = json.dumps(data)
â”‚   â”‚               encrypted = self._cipher.encrypt(json_str.encode())
â”‚   â”‚               return base64.urlsafe_b64encode(encrypted).decode()
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.logger.error(f"Encryption failed: {e}")
â”‚   â”‚               raise InternalError(
â”‚   â”‚                   "Failed to encrypt token data",
â”‚   â”‚                   details={"error": str(e)}
â”‚   â”‚               )
â”‚   â”‚
â”‚   â”‚       def decrypt(self, encrypted_data: str) -> Dict[str, Any]:
â”‚   â”‚           """Decrypt token data"""
â”‚   â”‚           try:
â”‚   â”‚               encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
â”‚   â”‚               decrypted = self._cipher.decrypt(encrypted_bytes)
â”‚   â”‚               return json.loads(decrypted.decode())
â”‚   â”‚           except Exception as e:
â”‚   â”‚               self.logger.error(f"Decryption failed: {e}")
â”‚   â”‚               raise InternalError(
â”‚   â”‚                   "Failed to decrypt token data",
â”‚   â”‚                   details={"error": str(e)}
â”‚   â”‚               )
â”‚   â”‚   ```
â”‚   â”‚
â”‚   â””â”€â”€ token_service.py
â”‚
â”‚       ```py
â”‚       # services/token-service/src/services/token_service.py
â”‚
â”‚       from typing import List, Optional, Dict, Any
â”‚       from datetime import datetime
â”‚       from shared.utils.logger import ServiceLogger
â”‚       from shared.utils.exceptions import NotFoundError, ValidationError
â”‚       from ..repositories.token_repository import TokenRepository
â”‚       from ..services.encryption_service import EncryptionService
â”‚       from ..schemas.token import StoreTokenRequest, TokenData
â”‚       from ..utils.constants import SUPPORTED_PLATFORMS, TOKEN_TYPES
â”‚
â”‚       class TokenService:
â”‚           """Business logic for token operations"""
â”‚
â”‚           def __init__(
â”‚               self,
â”‚               repository: TokenRepository,
â”‚               encryption: EncryptionService,
â”‚               logger: ServiceLogger
â”‚           ):
â”‚               self.repository = repository
â”‚               self.encryption = encryption
â”‚               self.logger = logger
â”‚
â”‚           async def store_token(
â”‚               self,
â”‚               request: StoreTokenRequest,
â”‚               correlation_id: str
â”‚           ) -> str:
â”‚               """Store or update a token"""
â”‚
â”‚               # Validate platform
â”‚               if request.platform_name not in SUPPORTED_PLATFORMS:
â”‚                   raise ValidationError(
â”‚                       f"Unsupported platform: {request.platform_name}",
â”‚                       field="platform_name",
â”‚                       value=request.platform_name
â”‚                   )
â”‚
â”‚               # Validate token type
â”‚               if request.token_type not in TOKEN_TYPES:
â”‚                   raise ValidationError(
â”‚                       f"Invalid token type: {request.token_type}",
â”‚                       field="token_type",
â”‚                       value=request.token_type
â”‚                   )
â”‚
â”‚               # Encrypt token data
â”‚               encrypted = self.encryption.encrypt(request.token_data)
â”‚
â”‚               # Store in database
â”‚               token = await self.repository.upsert({
â”‚                   "merchant_id": request.merchant_id,
â”‚                   "platform_name": request.platform_name,
â”‚                   "platform_shop_id": request.platform_shop_id,
â”‚                   "domain": request.domain,
â”‚                   "encrypted_token": encrypted,
â”‚                   "encryption_key_id": self.encryption.key_id,
â”‚                   "token_type": request.token_type,
â”‚                   "expires_at": request.expires_at,
â”‚                   "scopes": request.scopes
â”‚               })
â”‚
â”‚               # Log access
â”‚               await self.repository.log_access(
â”‚                   token_id=token.id,
â”‚                   accessed_by=request.domain,  # Store requester
â”‚                   access_type="write",
â”‚                   success=True,
â”‚                   correlation_id=correlation_id
â”‚               )
â”‚
â”‚               self.logger.info(
â”‚                   f"Token stored for merchant {request.merchant_id}",
â”‚                   extra={
â”‚                       "correlation_id": correlation_id,
â”‚                       "merchant_id": request.merchant_id,
â”‚                       "platform": request.platform_name
â”‚                   }
â”‚               )
â”‚
â”‚               return token.id
â”‚
â”‚           async def get_tokens(
â”‚               self,
â”‚               merchant_id: str,
â”‚               platform: Optional[str],
â”‚               requesting_service: str,
â”‚               correlation_id: str,
â”‚               ip_address: Optional[str] = None
â”‚           ) -> List[TokenData]:
â”‚               """Retrieve and decrypt tokens for a merchant"""
â”‚
â”‚               # Validate platform if specified
â”‚               if platform and platform not in SUPPORTED_PLATFORMS:
â”‚                   raise ValidationError(
â”‚                       f"Invalid platform: {platform}",
â”‚                       field="platform",
â”‚                       value=platform
â”‚                   )
â”‚
â”‚               # Retrieve tokens
â”‚               if platform:
â”‚                   tokens = await self.repository.find_by_merchant_platform(
â”‚                       merchant_id, platform
â”‚                   )
â”‚               else:
â”‚                   tokens = await self.repository.find_by_merchant(merchant_id)
â”‚
â”‚               # Process each token
â”‚               result = []
â”‚               for token in tokens:
â”‚                   # Decrypt token data
â”‚                   try:
â”‚                       token_data = self.encryption.decrypt(token.encrypted_token)
â”‚                   except Exception as e:
â”‚                       # Log decryption failure but continue
â”‚                       await self.repository.log_access(
â”‚                           token_id=token.id,
â”‚                           accessed_by=requesting_service,
â”‚                           access_type="read",
â”‚                           success=False,
â”‚                           correlation_id=correlation_id,
â”‚                           ip_address=ip_address,
â”‚                           error_message=f"Decryption failed: {str(e)}"
â”‚                       )
â”‚                       continue
â”‚
â”‚                   # Update access tracking
â”‚                   await self.repository.update_access(token.id, requesting_service)
â”‚
â”‚                   # Log successful access
â”‚                   await self.repository.log_access(
â”‚                       token_id=token.id,
â”‚                       accessed_by=requesting_service,
â”‚                       access_type="read",
â”‚                       success=True,
â”‚                       correlation_id=correlation_id,
â”‚                       ip_address=ip_address
â”‚                   )
â”‚
â”‚                   # Check expiry
â”‚                   is_expired = token.expires_at and token.expires_at < datetime.utcnow()
â”‚
â”‚                   result.append(TokenData(
â”‚                       platform_name=token.platform_name,
â”‚                       platform_shop_id=token.platform_shop_id,
â”‚                       domain=token.domain,
â”‚                       token_data=token_data,
â”‚                       token_type=token.token_type,
â”‚                       expires_at=token.expires_at,
â”‚                       is_expired=is_expired,
â”‚                       scopes=token.scopes
â”‚                   ))
â”‚
â”‚               self.logger.info(
â”‚                   f"Retrieved {len(result)} tokens for merchant {merchant_id}",
â”‚                   extra={
â”‚                       "correlation_id": correlation_id,
â”‚                       "merchant_id": merchant_id,
â”‚                       "requesting_service": requesting_service,
â”‚                       "token_count": len(result)
â”‚                   }
â”‚               )
â”‚
â”‚               return result
â”‚
â”‚           async def delete_token(
â”‚               self,
â”‚               merchant_id: str,
â”‚               platform: str,
â”‚               correlation_id: str
â”‚           ) -> bool:
â”‚               """Delete a specific token"""
â”‚
â”‚               # Validate platform
â”‚               if platform not in SUPPORTED_PLATFORMS:
â”‚                   raise ValidationError(
â”‚                       f"Invalid platform: {platform}",
â”‚                       field="platform",
â”‚                       value=platform
â”‚                   )
â”‚
â”‚               # Delete token
â”‚               deleted = await self.repository.delete(merchant_id, platform)
â”‚
â”‚               if deleted:
â”‚                   # Log deletion
â”‚                   await self.repository.log_access(
â”‚                       token_id=deleted.id,
â”‚                       accessed_by=deleted.domain,
â”‚                       access_type="delete",
â”‚                       success=True,
â”‚                       correlation_id=correlation_id
â”‚                   )
â”‚
â”‚                   self.logger.info(
â”‚                       f"Token deleted for merchant {merchant_id} platform {platform}",
â”‚                       extra={
â”‚                           "correlation_id": correlation_id,
â”‚                           "merchant_id": merchant_id,
â”‚                           "platform": platform
â”‚                       }
â”‚                   )
â”‚                   return True
â”‚
â”‚               return False
â”‚       ```
â”‚
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ constants.py
â”‚
â”‚       ```py
â”‚       # services/token-service/src/utils/constants.py
â”‚
â”‚       SUPPORTED_PLATFORMS = {
â”‚           "shopify",
â”‚           "woocommerce",
â”‚           "bigcommerce",
â”‚           "magento",
â”‚           "squarespace",
â”‚           "custom"
â”‚       }
â”‚
â”‚       TOKEN_TYPES = {
â”‚           "oauth",
â”‚           "api_key",
â”‚           "basic_auth",
â”‚           "bearer"
â”‚       }
â”‚
â”‚       # Services allowed to retrieve tokens
â”‚       ALLOWED_READER_SERVICES = [
â”‚           "platform-connector",
â”‚           "webhook-service",
â”‚           "merchant-service",
â”‚           "catalog-service",
â”‚           "analytics-service"
â”‚       ]
â”‚       ```
â”‚
â”œâ”€â”€ __init__.py
â”œâ”€â”€ config.py
â”‚
â”‚   ```py
â”‚   # services/token-service/src/config.py
â”‚
â”‚   import os
â”‚   from functools import lru_cache
â”‚   from pydantic import BaseModel, Field, ConfigDict, model_validator
â”‚   from shared.utils import load_root_env, ConfigurationError
â”‚
â”‚   class ServiceConfig(BaseModel):
â”‚       """Token Service configuration"""
â”‚       model_config = ConfigDict(
â”‚           extra="ignore",
â”‚           case_sensitive=False
â”‚       )
â”‚
â”‚       # Service identification
â”‚       service_name: str = "token-service"
â”‚       service_version: str = "1.0.0"
â”‚       service_description: str = "Secure token storage and retrieval service"
â”‚
â”‚       # Environment
â”‚       environment: str = Field(..., alias="APP_ENV")
â”‚       debug: bool = Field(default=False, alias="DEBUG")
â”‚
â”‚       # API configuration
â”‚       api_host: str = "0.0.0.0"
â”‚       api_external_port: int = Field(default=8007, alias="TOKEN_API_EXTERNAL_PORT")
â”‚
â”‚       # Database
â”‚       database_url: str = Field(..., alias="DATABASE_URL")
â”‚       database_enabled: bool = Field(default=True, alias="TOKEN_DB_ENABLED")
â”‚
â”‚       # Security
â”‚       client_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
â”‚       internal_api_keys: str = Field(..., alias="INTERNAL_JWT_SECRET")
â”‚       encryption_key: str = Field(..., alias="TOKEN_ENCRYPTION_KEY")
â”‚       encryption_key_id: str = Field(default="key_v1", alias="TOKEN_ENCRYPTION_KEY_ID")
â”‚
â”‚       # Logging
â”‚       logging_level: str = Field(default="INFO", alias="LOGGING_LEVEL")
â”‚
â”‚       @property
â”‚       def api_port(self) -> int:
â”‚           """Port based on environment"""
â”‚           in_container = os.path.exists("/.dockerenv")
â”‚           return 8000 if in_container else self.api_external_port
â”‚
â”‚       @model_validator(mode="after")
â”‚       def validate_config(self):
â”‚           if not self.database_url:
â”‚               raise ValueError("DATABASE_URL is required")
â”‚           if not self.encryption_key:
â”‚               raise ValueError("TOKEN_ENCRYPTION_KEY is required")
â”‚           if len(self.encryption_key) < 32:
â”‚               raise ValueError("TOKEN_ENCRYPTION_KEY must be at least 32 characters")
â”‚           return self
â”‚
â”‚   @lru_cache
â”‚   def get_service_config() -> ServiceConfig:
â”‚       """Load configuration once"""
â”‚       try:
â”‚           load_root_env()
â”‚           return ServiceConfig(**os.environ)
â”‚       except Exception as e:
â”‚           raise ConfigurationError(
â”‚               f"Failed to load config: {e}",
â”‚               config_key="token-service"
â”‚           )
â”‚   ```
â”‚
â”œâ”€â”€ dependencies.py
â”‚
â”‚   ```py
â”‚   # services/token-service/src/dependencies.py
â”‚
â”‚   from typing import Annotated
â”‚   from fastapi import Depends, Request, HTTPException
â”‚   from shared.api.dependencies import (
â”‚       RequestContextDep,
â”‚       ClientAuthDep,
â”‚       InternalAuthDep,
â”‚       LoggerDep,
â”‚       ClientIpDep
â”‚   )
â”‚   from .lifecycle import ServiceLifecycle
â”‚   from .services.token_service import TokenService
â”‚   from .config import ServiceConfig
â”‚
â”‚   # Re-export shared dependencies
â”‚   __all__ = [
â”‚       "RequestContextDep",
â”‚       "ClientAuthDep",
â”‚       "InternalAuthDep",
â”‚       "LoggerDep",
â”‚       "ClientIpDep",
â”‚       "LifecycleDep",
â”‚       "ConfigDep",
â”‚       "TokenServiceDep"
â”‚   ]
â”‚
â”‚   def get_lifecycle(request: Request) -> ServiceLifecycle:
â”‚       """Get service lifecycle from app state"""
â”‚       return request.app.state.lifecycle
â”‚
â”‚   def get_config(request: Request) -> ServiceConfig:
â”‚       """Get service config from app state"""
â”‚       return request.app.state.config
â”‚
â”‚   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
â”‚   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
â”‚
â”‚   def get_token_service(lifecycle: LifecycleDep) -> TokenService:
â”‚       """Get token service"""
â”‚       if not lifecycle.token_service:
â”‚           raise HTTPException(500, "Token service not initialized")
â”‚       return lifecycle.token_service
â”‚
â”‚   TokenServiceDep = Annotated[TokenService, Depends(get_token_service)]
â”‚   ```
â”‚
â”œâ”€â”€ exceptions.py
â”‚
â”‚   ```py
â”‚   # services/token-service/src/exceptions.py
â”‚
â”‚   from shared.utils.exceptions import DomainError
â”‚
â”‚   class TokenExpiredError(DomainError):
â”‚       """Token has expired"""
â”‚       code = "TOKEN_EXPIRED"
â”‚       status = 401
â”‚
â”‚   class EncryptionKeyMismatchError(DomainError):
â”‚       """Token encrypted with different key"""
â”‚       code = "ENCRYPTION_KEY_MISMATCH"
â”‚       status = 500
â”‚   ```
â”‚
â”œâ”€â”€ lifecycle.py
â”‚
â”‚   ```py
â”‚   # services/token-service/src/lifecycle.py
â”‚
â”‚   from typing import Optional
â”‚   from prisma import Prisma
â”‚   from shared.utils.logger import ServiceLogger
â”‚   from .config import ServiceConfig
â”‚   from .repositories.token_repository import TokenRepository
â”‚   from .services.token_service import TokenService
â”‚   from .services.encryption_service import EncryptionService
â”‚
â”‚   class ServiceLifecycle:
â”‚       """Manages all service components lifecycle"""
â”‚
â”‚       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
â”‚           self.config = config
â”‚           self.logger = logger
â”‚
â”‚           # Connections
â”‚           self.prisma: Optional[Prisma] = None
â”‚           self._db_connected = False
â”‚
â”‚           # Components
â”‚           self.token_repo: Optional[TokenRepository] = None
â”‚           self.encryption_service: Optional[EncryptionService] = None
â”‚           self.token_service: Optional[TokenService] = None
â”‚
â”‚       async def startup(self) -> None:
â”‚           """Initialize all components"""
â”‚           try:
â”‚               self.logger.info("Starting Token Service components...")
â”‚
â”‚               # 1. Database
â”‚               await self._init_database()
â”‚
â”‚               # 2. Encryption
â”‚               self._init_encryption()
â”‚
â”‚               # 3. Repositories
â”‚               self._init_repositories()
â”‚
â”‚               # 4. Services
â”‚               self._init_services()
â”‚
â”‚               self.logger.info(f"{self.config.service_name} started successfully")
â”‚
â”‚           except Exception as e:
â”‚               self.logger.critical("Service startup failed", exc_info=True)
â”‚               await self.shutdown()
â”‚               raise
â”‚
â”‚       async def shutdown(self) -> None:
â”‚           """Graceful shutdown"""
â”‚           self.logger.info(f"Shutting down {self.config.service_name}")
â”‚
â”‚           # Disconnect database
â”‚           if self.prisma and self._db_connected:
â”‚               try:
â”‚                   await self.prisma.disconnect()
â”‚               except Exception:
â”‚                   self.logger.error("Prisma disconnect failed", exc_info=True)
â”‚
â”‚           self.logger.info(f"{self.config.service_name} shutdown complete")
â”‚
â”‚       async def _init_database(self) -> None:
â”‚           """Initialize Prisma client"""
â”‚           if not self.config.database_enabled:
â”‚               raise RuntimeError("Database is required for Token Service")
â”‚
â”‚           self.prisma = Prisma()
â”‚           try:
â”‚               await self.prisma.connect()
â”‚               self._db_connected = True
â”‚               self.logger.info("Prisma connected")
â”‚           except Exception as e:
â”‚               self.logger.error(f"Prisma connect failed: {e}", exc_info=True)
â”‚               raise
â”‚
â”‚       def _init_encryption(self) -> None:
â”‚           """Initialize encryption service"""
â”‚           self.encryption_service = EncryptionService(
â”‚               encryption_key=self.config.encryption_key,
â”‚               key_id=self.config.encryption_key_id,
â”‚               logger=self.logger
â”‚           )
â”‚           self.logger.info("Encryption service initialized")
â”‚
â”‚       def _init_repositories(self) -> None:
â”‚           """Initialize repositories"""
â”‚           if not self._db_connected:
â”‚               raise RuntimeError("Database not connected")
â”‚
â”‚           self.token_repo = TokenRepository(self.prisma, self.logger)
â”‚           self.logger.info("Token repository initialized")
â”‚
â”‚       def _init_services(self) -> None:
â”‚           """Initialize business services"""
â”‚           if not self.token_repo or not self.encryption_service:
â”‚               raise RuntimeError("Dependencies not initialized")
â”‚
â”‚           self.token_service = TokenService(
â”‚               repository=self.token_repo,
â”‚               encryption=self.encryption_service,
â”‚               logger=self.logger
â”‚           )
â”‚           self.logger.info("Token service initialized")
â”‚   ```
â”‚
â””â”€â”€ main.py

    ```py
    # services/token-service/src/main.py

    from contextlib import asynccontextmanager
    from fastapi import FastAPI
    from shared.api import setup_middleware, create_health_router
    from shared.utils import create_logger
    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    # Create singletons
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)

    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Lifespan management"""
        # Store in app state for dependencies
        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger  # Required for middleware

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()

    def create_application() -> FastAPI:
        """Create FastAPI app"""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            description=config.service_description,
            lifespan=lifespan
        )

        # Setup shared middleware (handles ALL errors)
        setup_middleware(app, service_name=config.service_name)

        # Add health check
        app.include_router(create_health_router(config.service_name))

        # Add API routes
        from .api.v1 import tokens
        app.include_router(tokens.router)

        return app

    app = create_application()

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(
            "src.main:app",
            host=config.api_host,
            port=config.api_port,
            reload=config.debug
        )
    ```

tests/
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ test_api.py
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ test_service.py
â”œâ”€â”€ __init__.py
â””â”€â”€ conftest.py
Dockerfile

```
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ›   Stage 1  â”€ Builder
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FROM python:3.11-slim AS builder

# Base toolchain
RUN apt-get update -qq && apt-get install -y --no-install-recommends \
        curl ca-certificates build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install --no-cache-dir poetry==1.7.1
ENV POETRY_VIRTUALENVS_CREATE=false \
    POETRY_NO_INTERACTION=1

WORKDIR /app

# ---- 1ï¸âƒ£  Copy shared lib -----------------------------------------------------
COPY shared /shared
RUN pip install --no-cache-dir -e /shared

# Make shared importable
ENV PYTHONPATH="/shared:/app"

# ---- 2ï¸âƒ£  Service deps --------------------------------------------------------
COPY services/notification-service/pyproject.toml \
     services/notification-service/poetry.lock* /app/
RUN poetry install --no-root --no-ansi \
    && rm -rf ~/.cache/pypoetry ~/.cache/pip

# ---- 3ï¸âƒ£  Copy service source -------------------------------------------------
COPY services/notification-service /app

# ---- 4ï¸âƒ£  Copy config -----------------------------------------------------

COPY config /app/config

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“¦  Stage 2 â”€ Runtime
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app       /app
COPY --from=builder /shared    /shared

ENV PYTHONPATH="/shared:/app"
WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run with optimal settings for notification service
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "2"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
[tool.poetry]
name = "token-service"
version = "0.1.0"
description = "token-service microservice for GLAM platform"
authors = ["GLAM Team"]
readme = "README.md"
package-mode = false


[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109"
uvicorn = {extras = ["standard"], version = "^0.35.0"}
pydantic = "^2.11.7"
prisma = "^0.15.0"
cryptography = "^45.0.6"
shared = {path = "../../shared", develop = true}


[tool.poetry.group.dev.dependencies]
pytest = "^8.4.1"
ruff = "^0.12.9"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```


================================================================================
Output includes file contents
================================================================================
