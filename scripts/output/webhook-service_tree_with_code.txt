================================================================================
Directory Structure: /home/bellabe/glam-app/services/webhook-service
================================================================================

webhook-service/
alembic/
├── versions/
├── alembic.ini
│   
│   ```ini
│   [alembic]
│   script_location = alembic
│   prepend_sys_path = .
│   version_path_separator = os
│   sqlalchemy.url = postgresql+asyncpg://%(DB_USER)s:%(DB_PASSWORD)s@%(DB_HOST)s:%(DB_PORT)s/%(DB_NAME)s
│   
│   [post_write_hooks]
│   hooks = black
│   black.type = console_scripts
│   black.entrypoint = black
│   black.options = -l 88
│   
│   [loggers]
│   keys = root,sqlalchemy,alembic
│   
│   [handlers]
│   keys = console
│   
│   [formatters]
│   keys = generic
│   
│   [logger_root]
│   level = WARN
│   handlers = console
│   qualname =
│   
│   [logger_sqlalchemy]
│   level = WARN
│   handlers =
│   qualname = sqlalchemy.engine
│   
│   [logger_alembic]
│   level = INFO
│   handlers =
│   qualname = alembic
│   
│   [handler_console]
│   class = StreamHandler
│   args = (sys.stderr,)
│   level = NOTSET
│   formatter = generic
│   
│   [formatter_generic]
│   format = %(levelname)-5.5s [%(name)s] %(message)s
│   datefmt = %H:%M:%S
│   ```
│   
└── env.py
    
    ```py
    # services/webhook-service/alembic/env.py
    from logging.config import fileConfig
    from sqlalchemy import engine_from_config, pool
    from alembic import context
    import os
    import sys
    from pathlib import Path
    
    # Add parent directory to path
    sys.path.append(str(Path(__file__).parent.parent.parent.parent))
    sys.path.append(str(Path(__file__).parent.parent))
    
    # Import models and database config
    from shared.database.base import Base
    from shared.database.config import DatabaseConfig
    from src.models import *  # noqa - Import all models
    
    # this is the Alembic Config object
    config = context.config
    
    # Interpret the config file for logging
    if config.config_file_name is not None:
        fileConfig(config.config_file_name)
    
    # Get database URL from environment
    db_config = DatabaseConfig()
    config.set_main_option("sqlalchemy.url", db_config.sync_database_url)
    
    # Add your model's MetaData object here for 'autogenerate' support
    target_metadata = Base.metadata
    
    
    def run_migrations_offline() -> None:
        """Run migrations in 'offline' mode."""
        url = config.get_main_option("sqlalchemy.url")
        context.configure(
            url=url,
            target_metadata=target_metadata,
            literal_binds=True,
            dialect_opts={"paramstyle": "named"},
        )
    
        with context.begin_transaction():
            context.run_migrations()
    
    
    def run_migrations_online() -> None:
        """Run migrations in 'online' mode."""
        configuration = config.get_section(config.config_ini_section)
        configuration["sqlalchemy.url"] = db_config.sync_database_url
        
        connectable = engine_from_config(
            configuration,
            prefix="sqlalchemy.",
            poolclass=pool.NullPool,
        )
    
        with connectable.connect() as connection:
            context.configure(
                connection=connection,
                target_metadata=target_metadata
            )
    
            with context.begin_transaction():
                context.run_migrations()
    
    
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        run_migrations_online()
    ```
    
scripts/
└── test_webhook.py
    
    ```py
    #!/usr/bin/env python3
    """
    Test script for webhook service.
    
    Usage:
        python scripts/test_webhook.py
    """
    
    import asyncio
    import hashlib
    import hmac
    import base64
    import json
    import httpx
    from datetime import datetime
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    # Configuration
    WEBHOOK_SERVICE_URL = os.getenv("WEBHOOK_SERVICE_URL", "http://localhost:8012")
    SHOPIFY_SECRET = os.getenv("SHOPIFY_WEBHOOK_SECRET", "test-secret")
    
    
    def generate_shopify_hmac(body: bytes, secret: str) -> str:
        """Generate Shopify HMAC signature"""
        digest = hmac.new(secret.encode(), body, hashlib.sha256).digest()
        return base64.b64encode(digest).decode()
    
    
    async def test_shopify_webhook():
        """Test Shopify webhook"""
        
        # Sample product update webhook
        webhook_data = {
            "id": 1234567890,
            "title": "Test Product",
            "vendor": "Test Vendor",
            "product_type": "Test Type",
            "created_at": "2025-01-15T10:00:00Z",
            "updated_at": datetime.utcnow().isoformat() + "Z",
            "status": "active",
            "variants": [
                {
                    "id": 9876543210,
                    "product_id": 1234567890,
                    "title": "Default",
                    "price": "19.99",
                    "sku": "TEST-001",
                    "inventory_quantity": 100
                }
            ]
        }
        
        body = json.dumps(webhook_data).encode()
        signature = generate_shopify_hmac(body, SHOPIFY_SECRET)
        
        headers = {
            "X-Shopify-Topic": "products/update",
            "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
            "X-Shopify-Webhook-Id": f"test-webhook-{datetime.utcnow().timestamp()}",
            "X-Shopify-Hmac-SHA256": signature,
            "X-Shopify-API-Version": "2024-01",
            "Content-Type": "application/json"
        }
        
        async with httpx.AsyncClient() as client:
            print(f"Sending webhook to {WEBHOOK_SERVICE_URL}/api/v1/webhooks/shopify/products/update")
            
            response = await client.post(
                f"{WEBHOOK_SERVICE_URL}/api/v1/webhooks/shopify/products/update",
                content=body,
                headers=headers
            )
            
            print(f"Response: {response.status_code}")
            if response.status_code != 200:
                print(f"Response body: {response.text}")
            
            # Test health check
            health_response = await client.get(f"{WEBHOOK_SERVICE_URL}/api/v1/health")
            print(f"\nHealth check: {health_response.json()}")
    
    
    async def test_duplicate_webhook():
        """Test duplicate webhook handling"""
        
        webhook_data = {
            "id": 9999999999,
            "name": "Duplicate Order Test",
            "total_price": "99.99"
        }
        
        body = json.dumps(webhook_data).encode()
        signature = generate_shopify_hmac(body, SHOPIFY_SECRET)
        
        headers = {
            "X-Shopify-Topic": "orders/create",
            "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
            "X-Shopify-Webhook-Id": "duplicate-test-123",  # Same ID for both requests
            "X-Shopify-Hmac-SHA256": signature,
            "X-Shopify-API-Version": "2024-01",
            "Content-Type": "application/json"
        }
        
        async with httpx.AsyncClient() as client:
            print("\n\nTesting duplicate webhook handling...")
            
            # First request
            print("Sending first webhook...")
            response1 = await client.post(
                f"{WEBHOOK_SERVICE_URL}/api/v1/webhooks/shopify",
                content=body,
                headers=headers
            )
            print(f"First response: {response1.status_code}")
            
            # Second request (duplicate)
            print("Sending duplicate webhook...")
            response2 = await client.post(
                f"{WEBHOOK_SERVICE_URL}/api/v1/webhooks/shopify",
                content=body,
                headers=headers
            )
            print(f"Second response: {response2.status_code} (should still be 200)")
    
    
    async def test_invalid_signature():
        """Test invalid signature handling"""
        
        webhook_data = {"test": "invalid"}
        body = json.dumps(webhook_data).encode()
        
        headers = {
            "X-Shopify-Topic": "products/create",
            "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
            "X-Shopify-Webhook-Id": "invalid-test-123",
            "X-Shopify-Hmac-SHA256": "invalid-signature",
            "X-Shopify-API-Version": "2024-01",
            "Content-Type": "application/json"
        }
        
        async with httpx.AsyncClient() as client:
            print("\n\nTesting invalid signature...")
            
            response = await client.post(
                f"{WEBHOOK_SERVICE_URL}/api/v1/webhooks/shopify",
                content=body,
                headers=headers
            )
            print(f"Response: {response.status_code} (should be 401)")
    
    
    async def main():
        """Run all tests"""
        print("Testing Webhook Service")
        print("=" * 50)
        
        await test_shopify_webhook()
        await test_duplicate_webhook()
        await test_invalid_signature()
        
        print("\n\nAll tests completed!")
    
    
    if __name__ == "__main__":
        asyncio.run(main())
    ```
    
src/
├── api/
│   └── v1/
│       ├── health.py
│       │   
│       │   ```py
│       │   # services/webhook-service/src/api/v1/health.py
│       │   """Health check endpoints."""
│       │   
│       │   from fastapi import APIRouter, Depends
│       │   from typing import Dict, Any
│       │   
│       │   from shared.database.dependencies import get_database_health
│       │   from ...dependencies import LifecycleDep
│       │   
│       │   
│       │   router = APIRouter(tags=["health"])
│       │   
│       │   
│       │   @router.get("/health")
│       │   async def health_check(
│       │       lifecycle: LifecycleDep,
│       │       db_health: Dict[str, Any] = Depends(get_database_health)
│       │   ) -> Dict[str, Any]:
│       │       """
│       │       Comprehensive health check for webhook service.
│       │       
│       │       Validates:
│       │       - Database connectivity
│       │       - Redis connectivity
│       │       - NATS connectivity
│       │       - Platform secrets presence
│       │       """
│       │       
│       │       health_status = {
│       │           "status": "healthy",
│       │           "service": "webhook-service",
│       │           "checks": {
│       │               "database": db_health["status"],
│       │               "redis": "unknown",
│       │               "nats": "unknown",
│       │               "secrets": "unknown"
│       │           }
│       │       }
│       │       
│       │       # Check Redis
│       │       try:
│       │           if lifecycle.redis_client:
│       │               await lifecycle.redis_client.ping()
│       │               health_status["checks"]["redis"] = "healthy"
│       │           else:
│       │               health_status["checks"]["redis"] = "unhealthy"
│       │               health_status["status"] = "degraded"
│       │       except Exception as e:
│       │           health_status["checks"]["redis"] = f"unhealthy: {str(e)}"
│       │           health_status["status"] = "degraded"
│       │       
│       │       # Check NATS
│       │       try:
│       │           if lifecycle.messaging_wrapper and lifecycle.messaging_wrapper._client:
│       │               if lifecycle.messaging_wrapper._client.is_connected:
│       │                   health_status["checks"]["nats"] = "healthy"
│       │               else:
│       │                   health_status["checks"]["nats"] = "unhealthy: disconnected"
│       │                   health_status["status"] = "degraded"
│       │           else:
│       │               health_status["checks"]["nats"] = "unhealthy: not initialized"
│       │               health_status["status"] = "degraded"
│       │       except Exception as e:
│       │           health_status["checks"]["nats"] = f"unhealthy: {str(e)}"
│       │           health_status["status"] = "degraded"
│       │       
│       │       # Check secrets
│       │       if lifecycle.config.SHOPIFY_WEBHOOK_SECRET:
│       │           health_status["checks"]["secrets"] = "healthy"
│       │       else:
│       │           health_status["checks"]["secrets"] = "unhealthy: missing Shopify secret"
│       │           health_status["status"] = "unhealthy"
│       │       
│       │       return health_status
│       │   
│       │   
│       │   @router.get("/health/ready")
│       │   async def readiness_check(lifecycle: LifecycleDep) -> Dict[str, str]:
│       │       """Simple readiness check for k8s"""
│       │       
│       │       # Quick checks
│       │       if not lifecycle.webhook_service:
│       │           return {"status": "not_ready", "reason": "service not initialized"}
│       │       
│       │       if not lifecycle.messaging_wrapper or not lifecycle.messaging_wrapper._client.is_connected:
│       │           return {"status": "not_ready", "reason": "messaging not connected"}
│       │       
│       │       return {"status": "ready"}
│       │   
│       │   
│       │   @router.get("/health/live")
│       │   async def liveness_check() -> Dict[str, str]:
│       │       """Simple liveness check for k8s"""
│       │       return {"status": "alive"}
│       │   ```
│       │   
│       └── webhooks.py
│           
│           ```py
│           # services/webhook-service/src/api/v1/webhooks.py
│           """Webhook API endpoints."""
│           
│           from fastapi import APIRouter, Request, Response, Header, HTTPException
│           from typing import Optional, Dict, Any
│           
│           from shared.api.responses import success_response, error_response
│           from shared.errors import ValidationError
│           
│           from ...dependencies import WebhookServiceDep
│           from ...models.webhook_entry import WebhookSource
│           
│           
│           router = APIRouter(prefix="/webhooks", tags=["webhooks"])
│           
│           
│           @router.post("/shopify/{topic}")
│           async def shopify_webhook_with_topic(
│               request: Request,
│               topic: str,
│               webhook_service: WebhookServiceDep,
│               x_shopify_topic: Optional[str] = Header(None),
│               x_shopify_merchant_domain: Optional[str] = Header(None),
│               x_shopify_webhook_id: Optional[str] = Header(None),
│               x_shopify_hmac_sha256: Optional[str] = Header(None),
│               x_shopify_api_version: Optional[str] = Header(None),
│           ) -> Response:
│               """Handle Shopify webhook with topic in path"""
│           
│               # Validate required headers
│               if not x_shopify_hmac_sha256:
│                   raise HTTPException(status_code=401, detail="Missing signature header")
│           
│               if not x_shopify_merchant_domain:
│                   raise HTTPException(status_code=400, detail="Missing shop domain header")
│           
│               # Get raw body
│               body = await request.body()
│           
│               # Build headers dict
│               headers = {
│                   "x-shopify-topic": x_shopify_topic or topic,
│                   "x-shopify-shop-domain": x_shopify_merchant_domain,
│                   "x-shopify-webhook-id": x_shopify_webhook_id,
│                   "x-shopify-hmac-sha256": x_shopify_hmac_sha256,
│                   "x-shopify-api-version": x_shopify_api_version,
│               }
│           
│               try:
│                   result = await webhook_service.process_webhook(
│                       source=WebhookSource.SHOPIFY, headers=headers, body=body, topic=topic
│                   )
│           
│                   # Always return 200 for accepted webhooks
│                   return Response(status_code=200)
│           
│               except ValidationError as e:
│                   # Return 401 for auth failures
│                   if "signature" in str(e).lower():
│                       raise HTTPException(status_code=401, detail=str(e))
│                   # Return 400 for other validation errors
│                   raise HTTPException(status_code=400, detail=str(e))
│               except Exception as e:
│                   # Log but return 200 to prevent retries
│                   return Response(status_code=200)
│           
│           
│           @router.post("/shopify")
│           async def shopify_webhook_fallback(
│               request: Request,
│               webhook_service: WebhookServiceDep,
│               x_shopify_topic: str = Header(...),
│               x_shopify_merchant_domain: str = Header(...),
│               x_shopify_webhook_id: Optional[str] = Header(None),
│               x_shopify_hmac_sha256: str = Header(...),
│               x_shopify_api_version: Optional[str] = Header(None),
│           ) -> Response:
│               """Handle Shopify webhook with topic in header (fallback)"""
│           
│               body = await request.body()
│           
│               headers = {
│                   "x-shopify-topic": x_shopify_topic,
│                   "x-shopify-shop-domain": x_shopify_merchant_domain,
│                   "x-shopify-webhook-id": x_shopify_webhook_id,
│                   "x-shopify-hmac-sha256": x_shopify_hmac_sha256,
│                   "x-shopify-api-version": x_shopify_api_version,
│               }
│           
│               try:
│                   result = await webhook_service.process_webhook(
│                       source=WebhookSource.SHOPIFY,
│                       headers=headers,
│                       body=body,
│                       topic=x_shopify_topic,
│                   )
│           
│                   return Response(status_code=200)
│           
│               except ValidationError as e:
│                   if "signature" in str(e).lower():
│                       raise HTTPException(status_code=401, detail=str(e))
│                   raise HTTPException(status_code=400, detail=str(e))
│               except Exception:
│                   return Response(status_code=200)
│           
│           
│           @router.post("/stripe")
│           async def stripe_webhook(
│               request: Request,
│               webhook_service: WebhookServiceDep,
│               stripe_signature: str = Header(...),
│           ) -> Response:
│               """Handle Stripe webhook"""
│           
│               body = await request.body()
│           
│               headers = {"stripe-signature": stripe_signature}
│           
│               try:
│                   # Parse body to get event type
│                   import json
│           
│                   parsed = json.loads(body)
│                   topic = parsed.get("type", "unknown")
│           
│                   result = await webhook_service.process_webhook(
│                       source=WebhookSource.STRIPE, headers=headers, body=body, topic=topic
│                   )
│           
│                   return Response(status_code=200)
│           
│               except ValidationError as e:
│                   if "signature" in str(e).lower():
│                       raise HTTPException(status_code=401, detail=str(e))
│                   raise HTTPException(status_code=400, detail=str(e))
│               except Exception:
│                   return Response(status_code=200)
│           
│           
│           @router.post("/{source}")
│           async def generic_webhook(
│               request: Request, source: str, webhook_service: WebhookServiceDep
│           ) -> Response:
│               """Handle generic webhook (future extensibility)"""
│           
│               # For now, just accept and log
│               body = await request.body()
│               headers = dict(request.headers)
│           
│               # Log for future implementation
│               webhook_service.logger.info(
│                   f"Received webhook from unsupported source: {source}",
│                   extra={"source": source, "headers": headers},
│               )
│           
│               return Response(status_code=200)
│           ```
│           
├── events/
│   ├── publishers.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/events/publishers.py
│   │   """Event publishers for webhook service."""
│   │   
│   │   from shared.events import (
│   │       Streams,
│   │       DomainEventPublisher,
│   │       EventContextManager,
│   │       EventContext,
│   │   )
│   │   from shared.events.webhook.types import (
│   │       WebhookEvents,
│   │       WebhookReceivedPayload,
│   │       WebhookProcessedPayload,
│   │       WebhookFailedPayload,
│   │       ValidationFailedPayload,
│   │   )
│   │   from typing import Optional, Dict, Any
│   │   from uuid import UUID
│   │   from datetime import datetime, timezone
│   │   
│   │   
│   │   class WebhookEventPublisher(DomainEventPublisher):
│   │       """Publisher for webhook service events"""
│   │   
│   │       domain_stream = Streams.WEBHOOK
│   │       service_name_override = "webhook-service"
│   │   
│   │       def __init__(self, client, js, logger=None):
│   │           super().__init__(client, js, logger)
│   │           self.context_manager = EventContextManager(logger or self.logger)
│   │   
│   │       async def publish_webhook_received(
│   │           self,
│   │           source: str,
│   │           topic: str,
│   │           merchant_id: Optional[str] = None,
│   │           merchant_domain: Optional[str] = None,
│   │           webhook_id: Optional[str] = None,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │       ) -> str:
│   │           """Publish webhook received event"""
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=WebhookEvents.WEBHOOK_RECEIVED,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override,
│   │               metadata={
│   │                   **(metadata or {}),
│   │                   "source": source,
│   │                   "topic": topic,
│   │                   "webhook_id": webhook_id,
│   │               },
│   │           )
│   │   
│   │           payload = WebhookReceivedPayload(
│   │               source=source,
│   │               topic=topic,
│   │               merchant_id=merchant_id,
│   │               merchant_domain=merchant_domain,
│   │               webhook_id=webhook_id,
│   │               received_at=context.timestamp,
│   │           )
│   │   
│   │           return await self.publish_with_context(context, payload)
│   │   
│   │       async def publish_validation_failed(
│   │           self,
│   │           source: str,
│   │           reason: str,
│   │           topic: Optional[str] = None,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │       ) -> str:
│   │           """Publish validation failed event"""
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=WebhookEvents.VALIDATION_FAILED,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override,
│   │               metadata={**(metadata or {}), "source": source, "reason": reason},
│   │           )
│   │   
│   │           payload = ValidationFailedPayload(
│   │               source=source, reason=reason, topic=topic, failed_at=context.timestamp
│   │           )
│   │   
│   │           return await self.publish_with_context(context, payload)
│   │   
│   │       async def publish_webhook_processed(
│   │           self,
│   │           entry_id: str,
│   │           source: str,
│   │           topic: str,
│   │           event_type: str,
│   │           merchant_id: Optional[str] = None,
│   │           merchant_domain: Optional[str] = None,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │       ) -> str:
│   │           """Publish webhook processed event"""
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=WebhookEvents.WEBHOOK_PROCESSED,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override,
│   │               metadata={
│   │                   **(metadata or {}),
│   │                   "entry_id": entry_id,
│   │                   "mapped_event": event_type,
│   │               },
│   │           )
│   │   
│   │           payload = WebhookProcessedPayload(
│   │               entry_id=entry_id,
│   │               source=source,
│   │               topic=topic,
│   │               event_type=event_type,
│   │               merchant_id=merchant_id,
│   │               merchant_domain=merchant_domain,
│   │               processed_at=context.timestamp,
│   │           )
│   │   
│   │           return await self.publish_with_context(context, payload)
│   │   
│   │       async def publish_webhook_failed(
│   │           self,
│   │           entry_id: str,
│   │           source: str,
│   │           topic: str,
│   │           error: str,
│   │           attempts: int,
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │       ) -> str:
│   │           """Publish webhook failed event"""
│   │           context = EventContext(
│   │               event_id=str(UUID()),
│   │               event_type=WebhookEvents.WEBHOOK_FAILED,
│   │               correlation_id=correlation_id,
│   │               timestamp=datetime.now(timezone.utc),
│   │               source_service=self.service_name_override,
│   │               metadata={**(metadata or {}), "entry_id": entry_id, "attempts": attempts},
│   │           )
│   │   
│   │           payload = WebhookFailedPayload(
│   │               entry_id=entry_id,
│   │               source=source,
│   │               topic=topic,
│   │               error=error,
│   │               attempts=attempts,
│   │               failed_at=context.timestamp,
│   │           )
│   │   
│   │           return await self.publish_with_context(context, payload)
│   │   
│   │       async def publish_domain_event(
│   │           self,
│   │           event_type: str,
│   │           payload: Dict[str, Any],
│   │           correlation_id: Optional[str] = None,
│   │           metadata: Optional[Dict[str, Any]] = None,
│   │       ) -> str:
│   │           """Publish mapped domain event (e.g., evt.webhook.catalog.item_created)"""
│   │           # For domain events, just use the base publisher
│   │           return await self.publish_event(
│   │               event_type=event_type,
│   │               payload=payload,
│   │               correlation_id=correlation_id,
│   │               metadata=metadata,
│   │           )
│   │   ```
│   │   
│   └── types.py
│       
│       ```py
│       # shared/events/webhook/types.py
│       """Webhook service event type definitions."""
│       
│       from typing import Optional, List, Dict, Any
│       from datetime import datetime
│       from pydantic import BaseModel, Field
│       
│       
│       class WebhookEvents:
│           """Webhook service event types"""
│       
│           # Raw webhook events
│           WEBHOOK_RECEIVED = "evt.webhook.received"
│           WEBHOOK_PROCESSED = "evt.webhook.processed"
│           WEBHOOK_FAILED = "evt.webhook.failed"
│           VALIDATION_FAILED = "evt.webhook.validation.failed"
│       
│           # Domain events (mapped from webhooks)
│           # App lifecycle
│           APP_UNINSTALLED = "evt.webhook.app.uninstalled"
│           APP_SUBSCRIPTION_UPDATED = "evt.webhook.app.subscription_updated"
│           APP_PURCHASE_UPDATED = "evt.webhook.app.purchase_updated"
│       
│           # Catalog
│           CATALOG_ITEM_CREATED = "evt.webhook.catalog.item_created"
│           CATALOG_ITEM_UPDATED = "evt.webhook.catalog.item_updated"
│           CATALOG_ITEM_DELETED = "evt.webhook.catalog.item_deleted"
│       
│           # Orders
│           ORDER_CREATED = "evt.webhook.order.created"
│           ORDER_UPDATED = "evt.webhook.order.updated"
│           ORDER_FULFILLED = "evt.webhook.order.fulfilled"
│           ORDER_CANCELLED = "evt.webhook.order.cancelled"
│       
│           # Inventory
│           INVENTORY_UPDATED = "evt.webhook.inventory.updated"
│           INVENTORY_ITEM_UPDATED = "evt.webhook.inventory.item_updated"
│       
│           # Payment (Stripe)
│           PAYMENT_SUCCEEDED = "evt.webhook.payment.succeeded"
│           PAYMENT_FAILED = "evt.webhook.payment.failed"
│       
│           # Subscription (Stripe)
│           SUBSCRIPTION_CREATED = "evt.webhook.subscription.created"
│           SUBSCRIPTION_UPDATED = "evt.webhook.subscription.updated"
│           SUBSCRIPTION_CANCELLED = "evt.webhook.subscription.cancelled"
│       
│           # Customer (Stripe)
│           CUSTOMER_CREATED = "evt.webhook.customer.created"
│           CUSTOMER_UPDATED = "evt.webhook.customer.updated"
│       
│       
│       # Event Payloads
│       class WebhookReceivedPayload(BaseModel):
│           """Payload for webhook received event"""
│       
│           source: str
│           topic: str
│           merchant_id: Optional[str] = None
│           merchant_domain: Optional[str] = None
│           webhook_id: Optional[str] = None
│           received_at: datetime
│       
│       
│       class WebhookProcessedPayload(BaseModel):
│           """Payload for webhook processed event"""
│       
│           entry_id: str
│           source: str
│           topic: str
│           event_type: str
│           merchant_id: Optional[str] = None
│           merchant_domain: Optional[str] = None
│           processed_at: datetime
│       
│       
│       class WebhookFailedPayload(BaseModel):
│           """Payload for webhook failed event"""
│       
│           entry_id: str
│           source: str
│           topic: str
│           error: str
│           attempts: int
│           failed_at: datetime
│       
│       
│       class ValidationFailedPayload(BaseModel):
│           """Payload for validation failed event"""
│       
│           source: str
│           reason: str
│           topic: Optional[str] = None
│           failed_at: datetime
│       
│       
│       # Domain Event Payloads
│       class AppUninstalledPayload(BaseModel):
│           """App uninstalled event payload"""
│       
│           merchant_id: str
│           merchant_domain: str
│           timestamp: datetime
│       
│       
│       class CatalogItemPayload(BaseModel):
│           """Catalog item event payload"""
│       
│           merchant_id: str
│           merchant_domain: Optional[str] = None
│           item_id: str
│           external_id: str
│           title: Optional[str] = None
│           changes: Optional[List[str]] = None
│       
│       
│       class OrderPayload(BaseModel):
│           """Order event payload"""
│       
│           merchant_id: str
│           merchant_domain: Optional[str] = None
│           order_id: str
│           order_number: Optional[str] = None
│           total: Optional[str] = None
│           currency: Optional[str] = None
│           items: List[Dict[str, Any]] = Field(default_factory=list)
│       ```
│       
├── handlers/
│   ├── base.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/handlers/base.py
│   │   """Base webhook handler interface."""
│   │   
│   │   from abc import ABC, abstractmethod
│   │   from typing import Dict, Any, Optional, NamedTuple
│   │   from dataclasses import dataclass
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   
│   │   
│   │   @dataclass
│   │   class WebhookData:
│   │       """Parsed webhook data"""
│   │   
│   │       topic: str
│   │       merchant_id: Optional[str]
│   │       merchant_domain: Optional[str]
│   │       idempotency_key: str
│   │       payload: Dict[str, Any]
│   │       metadata: Dict[str, Any]
│   │   
│   │   
│   │   @dataclass
│   │   class DomainEvent:
│   │       """Domain event to publish"""
│   │   
│   │       event_type: str
│   │       payload: Dict[str, Any]
│   │   
│   │   
│   │   class WebhookHandler(ABC):
│   │       """Base class for webhook handlers"""
│   │   
│   │       def __init__(self, logger: Optional[ServiceLogger] = None):
│   │           self.logger = logger or ServiceLogger(__name__)
│   │   
│   │       @abstractmethod
│   │       def parse_webhook(
│   │           self, body: Dict[str, Any], topic: Optional[str], headers: Dict[str, str]
│   │       ) -> WebhookData:
│   │           """Parse webhook into structured data"""
│   │           pass
│   │   
│   │       @abstractmethod
│   │       def get_idempotency_key(
│   │           self, body: Dict[str, Any], topic: str, headers: Dict[str, str]
│   │       ) -> str:
│   │           """Generate idempotency key for deduplication"""
│   │           pass
│   │   
│   │       @abstractmethod
│   │       def map_to_domain_event(self, webhook_data: WebhookData) -> Optional[DomainEvent]:
│   │           """Map webhook to domain event"""
│   │           pass
│   │   ```
│   │   
│   ├── shopify.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/handlers/shopify.py
│   │   """Shopify webhook handler."""
│   │   
│   │   import hashlib
│   │   from typing import Dict, Any, Optional
│   │   from datetime import datetime
│   │   
│   │   from .base import WebhookHandler, WebhookData, DomainEvent
│   │   
│   │   
│   │   class ShopifyWebhookHandler(WebhookHandler):
│   │       """Handler for Shopify webhooks"""
│   │   
│   │       # Topic to domain event mapping
│   │       TOPIC_EVENT_MAP = {
│   │           # App lifecycle
│   │           "app/uninstalled": "evt.webhook.app.uninstalled",
│   │           "app_subscriptions/update": "evt.webhook.app.subscription_updated",
│   │           "app_purchases_one_time/update": "evt.webhook.app.purchase_updated",
│   │           # Catalog
│   │           "products/create": "evt.webhook.catalog.item_created",
│   │           "products/update": "evt.webhook.catalog.item_updated",
│   │           "products/delete": "evt.webhook.catalog.item_deleted",
│   │           # Orders
│   │           "orders/create": "evt.webhook.order.created",
│   │           "orders/updated": "evt.webhook.order.updated",
│   │           "orders/fulfilled": "evt.webhook.order.fulfilled",
│   │           "orders/cancelled": "evt.webhook.order.cancelled",
│   │           # Inventory
│   │           "inventory_levels/update": "evt.webhook.inventory.updated",
│   │           "inventory_items/update": "evt.webhook.inventory.item_updated",
│   │           # Compliance (no domain events)
│   │           "customers/data_request": None,
│   │           "customers/redact": None,
│   │           "shop/redact": None,
│   │       }
│   │   
│   │       def parse_webhook(
│   │           self, body: Dict[str, Any], topic: Optional[str], headers: Dict[str, str]
│   │       ) -> WebhookData:
│   │           """Parse Shopify webhook"""
│   │   
│   │           # Get topic from header if not in path
│   │           if not topic:
│   │               topic = headers.get("x-shopify-topic", "unknown")
│   │   
│   │           # Extract shop info
│   │           merchant_domain = headers.get("x-shopify-shop-domain", "")
│   │           merchant_id = merchant_domain.split(".")[0] if merchant_domain else None
│   │   
│   │           # Generate idempotency key
│   │           idempotency_key = self.get_idempotency_key(body, topic, headers)
│   │   
│   │           # Build metadata
│   │           metadata = {
│   │               "webhook_id": headers.get("x-shopify-webhook-id"),
│   │               "api_version": headers.get("x-shopify-api-version"),
│   │               "triggered_at": headers.get("x-shopify-triggered-at"),
│   │           }
│   │   
│   │           return WebhookData(
│   │               topic=topic,
│   │               merchant_id=merchant_id,
│   │               merchant_domain=merchant_domain,
│   │               idempotency_key=idempotency_key,
│   │               payload=body,
│   │               metadata={k: v for k, v in metadata.items() if v},
│   │           )
│   │   
│   │       def get_idempotency_key(
│   │           self, body: Dict[str, Any], topic: str, headers: Dict[str, str]
│   │       ) -> str:
│   │           """Generate idempotency key for Shopify webhook"""
│   │   
│   │           # Use webhook ID if available
│   │           webhook_id = headers.get("x-shopify-webhook-id")
│   │           if webhook_id:
│   │               return f"shopify:{webhook_id}"
│   │   
│   │           # Fallback to hash of key components
│   │           merchant_domain = headers.get("x-shopify-shop-domain", "")
│   │   
│   │           # For orders/products, use their ID
│   │           if "id" in body:
│   │               key_parts = f"shopify:{topic}:{merchant_domain}:{body['id']}"
│   │           else:
│   │               # Hash the entire payload as last resort
│   │               payload_hash = hashlib.sha256(str(body).encode()).hexdigest()[:16]
│   │               key_parts = f"shopify:{topic}:{merchant_domain}:{payload_hash}"
│   │   
│   │           return hashlib.sha256(key_parts.encode()).hexdigest()
│   │   
│   │       def map_to_domain_event(self, webhook_data: WebhookData) -> Optional[DomainEvent]:
│   │           """Map Shopify webhook to domain event"""
│   │   
│   │           event_type = self.TOPIC_EVENT_MAP.get(webhook_data.topic)
│   │           if not event_type:
│   │               self.logger.debug(
│   │                   f"No domain event mapping for topic: {webhook_data.topic}"
│   │               )
│   │               return None
│   │   
│   │           # Build event payload based on topic
│   │           payload = self._build_event_payload(
│   │               webhook_data.topic,
│   │               webhook_data.payload,
│   │               webhook_data.merchant_id,
│   │               webhook_data.merchant_domain,
│   │           )
│   │   
│   │           return DomainEvent(event_type=event_type, payload=payload)
│   │   
│   │       def _build_event_payload(
│   │           self,
│   │           topic: str,
│   │           webhook_payload: Dict[str, Any],
│   │           merchant_id: Optional[str],
│   │           merchant_domain: Optional[str],
│   │       ) -> Dict[str, Any]:
│   │           """Build domain event payload based on topic"""
│   │   
│   │           base_payload = {
│   │               "merchant_id": merchant_id,
│   │               "merchant_domain": merchant_domain,
│   │               "timestamp": datetime.utcnow().isoformat(),
│   │           }
│   │   
│   │           # App lifecycle events
│   │           if topic == "app/uninstalled":
│   │               return {**base_payload}
│   │   
│   │           elif topic == "app_subscriptions/update":
│   │               subscription = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "subscription_id": str(subscription.get("id")),
│   │                   "status": subscription.get("status"),
│   │                   "plan": subscription.get("name"),
│   │                   "trial_ends_at": subscription.get("trial_ends_on"),
│   │               }
│   │   
│   │           # Product events
│   │           elif topic.startswith("products/"):
│   │               product = webhook_payload
│   │               payload = {
│   │                   **base_payload,
│   │                   "item_id": str(product.get("id")),
│   │                   "external_id": str(product.get("id")),
│   │                   "title": product.get("title"),
│   │                   "vendor": product.get("vendor"),
│   │                   "product_type": product.get("product_type"),
│   │                   "status": product.get("status"),
│   │               }
│   │   
│   │               if topic == "products/update":
│   │                   # Add change detection (simplified)
│   │                   payload["changes"] = ["data"]  # Would need previous state
│   │   
│   │               return payload
│   │   
│   │           # Order events
│   │           elif topic.startswith("orders/"):
│   │               order = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "order_id": str(order.get("id")),
│   │                   "order_number": order.get("order_number"),
│   │                   "total": order.get("total_price"),
│   │                   "currency": order.get("currency"),
│   │                   "financial_status": order.get("financial_status"),
│   │                   "fulfillment_status": order.get("fulfillment_status"),
│   │                   "customer_id": str(order.get("customer", {}).get("id", "")),
│   │                   "items": [
│   │                       {
│   │                           "item_id": str(item.get("product_id")),
│   │                           "variant_id": str(item.get("variant_id")),
│   │                           "quantity": item.get("quantity"),
│   │                           "price": item.get("price"),
│   │                       }
│   │                       for item in order.get("line_items", [])
│   │                   ],
│   │               }
│   │   
│   │           # Inventory events
│   │           elif topic == "inventory_levels/update":
│   │               return {
│   │                   **base_payload,
│   │                   "item_id": str(webhook_payload.get("inventory_item_id")),
│   │                   "location_id": str(webhook_payload.get("location_id")),
│   │                   "available": webhook_payload.get("available"),
│   │                   "updated_at": webhook_payload.get("updated_at"),
│   │               }
│   │   
│   │           elif topic == "inventory_items/update":
│   │               item = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "item_id": str(item.get("id")),
│   │                   "sku": item.get("sku"),
│   │                   "tracked": item.get("tracked"),
│   │                   "requires_shipping": item.get("requires_shipping"),
│   │               }
│   │   
│   │           # Default fallback
│   │           return {**base_payload, "data": webhook_payload}
│   │   ```
│   │   
│   └── stripe.py
│       
│       ```py
│       # services/webhook-service/src/handlers/stripe.py
│       """Stripe webhook handler."""
│       
│       import hashlib
│       from typing import Dict, Any, Optional
│       
│       from .base import WebhookHandler, WebhookData, DomainEvent
│       
│       
│       class StripeWebhookHandler(WebhookHandler):
│           """Handler for Stripe webhooks"""
│       
│           # Event type to domain event mapping
│           EVENT_TYPE_MAP = {
│               # Payment events
│               "payment_intent.succeeded": "evt.webhook.payment.succeeded",
│               "payment_intent.failed": "evt.webhook.payment.failed",
│               # Subscription events
│               "customer.subscription.created": "evt.webhook.subscription.created",
│               "customer.subscription.updated": "evt.webhook.subscription.updated",
│               "customer.subscription.deleted": "evt.webhook.subscription.cancelled",
│               # Customer events
│               "customer.created": "evt.webhook.customer.created",
│               "customer.updated": "evt.webhook.customer.updated",
│           }
│       
│           def parse_webhook(
│               self, body: Dict[str, Any], topic: Optional[str], headers: Dict[str, str]
│           ) -> WebhookData:
│               """Parse Stripe webhook"""
│       
│               # Extract event type
│               event_type = body.get("type", "unknown")
│               if topic and topic != event_type:
│                   self.logger.warning(f"Topic mismatch: path={topic}, body={event_type}")
│       
│               # Extract data
│               data = body.get("data", {}).get("object", {})
│       
│               # Get shop info from metadata if available
│               metadata = data.get("metadata", {})
│               merchant_id = metadata.get("merchant_id")
│               merchant_domain = metadata.get("merchant_domain")
│       
│               # Generate idempotency key
│               idempotency_key = self.get_idempotency_key(body, event_type, headers)
│       
│               # Build metadata
│               webhook_metadata = {
│                   "event_id": body.get("id"),
│                   "api_version": body.get("api_version"),
│                   "created": body.get("created"),
│                   "livemode": body.get("livemode"),
│               }
│       
│               return WebhookData(
│                   topic=event_type,
│                   merchant_id=merchant_id,
│                   merchant_domain=merchant_domain,
│                   idempotency_key=idempotency_key,
│                   payload=data,
│                   metadata=webhook_metadata,
│               )
│       
│           def get_idempotency_key(
│               self, body: Dict[str, Any], topic: str, headers: Dict[str, str]
│           ) -> str:
│               """Generate idempotency key for Stripe webhook"""
│       
│               # Use event ID
│               event_id = body.get("id")
│               if event_id:
│                   return f"stripe:{event_id}"
│       
│               # Fallback (shouldn't happen with valid Stripe events)
│               payload_hash = hashlib.sha256(str(body).encode()).hexdigest()[:16]
│       
│               return f"stripe:{topic}:{payload_hash}"
│       
│           def map_to_domain_event(self, webhook_data: WebhookData) -> Optional[DomainEvent]:
│               """Map Stripe webhook to domain event"""
│       
│               event_type = self.EVENT_TYPE_MAP.get(webhook_data.topic)
│               if not event_type:
│                   self.logger.debug(
│                       f"No domain event mapping for Stripe event: {webhook_data.topic}"
│                   )
│                   return None
│       
│               # Build event payload
│               payload = self._build_event_payload(
│                   webhook_data.topic,
│                   webhook_data.payload,
│                   webhook_data.merchant_id,
│                   webhook_data.merchant_domain,
│               )
│       
│               return DomainEvent(event_type=event_type, payload=payload)
│       
│           def _build_event_payload(
│               self,
│               event_type: str,
│               stripe_data: Dict[str, Any],
│               merchant_id: Optional[str],
│               merchant_domain: Optional[str],
│           ) -> Dict[str, Any]:
│               """Build domain event payload for Stripe events"""
│       
│               base_payload = {
│                   "merchant_id": merchant_id,
│                   "merchant_domain": merchant_domain,
│                   "stripe_object_id": stripe_data.get("id"),
│                   "created": stripe_data.get("created"),
│               }
│       
│               # Payment events
│               if event_type.startswith("payment_intent."):
│                   return {
│                       **base_payload,
│                       "payment_intent_id": stripe_data.get("id"),
│                       "amount": stripe_data.get("amount"),
│                       "currency": stripe_data.get("currency"),
│                       "status": stripe_data.get("status"),
│                       "customer_id": stripe_data.get("customer"),
│                   }
│       
│               # Subscription events
│               elif event_type.startswith("customer.subscription."):
│                   return {
│                       **base_payload,
│                       "subscription_id": stripe_data.get("id"),
│                       "customer_id": stripe_data.get("customer"),
│                       "status": stripe_data.get("status"),
│                       "plan_id": stripe_data.get("items", {})
│                       .get("data", [{}])[0]
│                       .get("price", {})
│                       .get("id"),
│                       "current_period_end": stripe_data.get("current_period_end"),
│                   }
│       
│               # Customer events
│               elif event_type.startswith("customer."):
│                   return {
│                       **base_payload,
│                       "customer_id": stripe_data.get("id"),
│                       "email": stripe_data.get("email"),
│                       "name": stripe_data.get("name"),
│                   }
│       
│               # Default
│               return {**base_payload, "data": stripe_data}
│       ```
│       
├── mappers/
├── models/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/models/__init__.py
│   │   """Database models for webhook service."""
│   │   
│   │   from shared.database.base import Base, TimestampedMixin
│   │   from .webhook import Webhook, WebhookStatus
│   │   from .platform_config import PlatformConfig
│   │   
│   │   __all__ = [
│   │       # Base (from shared)
│   │       "Base",
│   │       "TimestampedMixin",
│   │       
│   │       # Webhook models
│   │       "Webhook",
│   │       "WebhookStatus",
│   │       
│   │       # Platform models
│   │       "PlatformConfig",
│   │   ]
│   │   ```
│   │   
│   ├── base.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/models/base.py
│   │   """Base model and common mixins for webhook service models."""
│   │   
│   │   from sqlalchemy import String
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   
│   │   # Import shared base and mixins
│   │   from shared.database.base import Base, TimestampedMixin
│   │   
│   │   
│   │   class ShopMixin:
│   │       """Mixin for shop-related fields."""
│   │   
│   │       merchant_id: Mapped[str] = mapped_column(String(36), nullable=True, index=True)
│   │       merchant_domain: Mapped[str] = mapped_column(String(255), nullable=True)
│   │   ```
│   │   
│   ├── platform_config.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/models/platform_config.py
│   │   """Platform configuration for webhook secrets and settings."""
│   │   
│   │   from uuid import UUID, uuid4
│   │   from sqlalchemy import String, Text, JSON, Boolean
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   from sqlalchemy.dialects.postgresql import UUID as PGUUID
│   │   
│   │   from shared.database.base import TimestampedMixin
│   │   from .base import Base
│   │   from .webhook_entry import WebhookSource
│   │   
│   │   
│   │   class PlatformConfiguration(Base, TimestampedMixin):
│   │       """Store platform-specific webhook configurations"""
│   │       
│   │       __tablename__ = "platform_configurations"
│   │       
│   │       id: Mapped[UUID] = mapped_column(
│   │           PGUUID(as_uuid=True), 
│   │           primary_key=True, 
│   │           default=uuid4
│   │       )
│   │       
│   │       source: Mapped[WebhookSource] = mapped_column(
│   │           SQLEnum(WebhookSource),
│   │           nullable=False,
│   │           unique=True
│   │       )
│   │       
│   │       # Encrypted webhook secret
│   │       webhook_secret: Mapped[str] = mapped_column(Text, nullable=False)
│   │       
│   │       # Platform settings
│   │       api_version: Mapped[str | None] = mapped_column(String(50), nullable=True)
│   │       active: Mapped[bool] = mapped_column(Boolean, default=True)
│   │       
│   │       # Additional endpoints config
│   │       endpoints: Mapped[dict | None] = mapped_column(JSON, nullable=True)
│   │   ```
│   │   
│   └── webhook-entry.py
│       
│       ```py
│       # services/webhook-service/src/models/webhook_entry.py
│       """Webhook entry model for storing all received webhooks."""
│       
│       from enum import Enum
│       from uuid import UUID, uuid4
│       from sqlalchemy import String, Text, JSON, Integer, Enum as SQLEnum
│       from sqlalchemy.orm import Mapped, mapped_column
│       from sqlalchemy.dialects.postgresql import UUID as PGUUID
│       
│       from shared.database.base import TimestampedMixin
│       from .base import Base, ShopMixin
│       
│       
│       class WebhookSource(str, Enum):
│           """Supported webhook sources"""
│           SHOPIFY = "SHOPIFY"
│           STRIPE = "STRIPE"
│           OTHER = "OTHER"
│       
│       
│       class WebhookStatus(str, Enum):
│           """Webhook processing status"""
│           RECEIVED = "RECEIVED"
│           PROCESSING = "PROCESSING"
│           PROCESSED = "PROCESSED"
│           FAILED = "FAILED"
│       
│       
│       class WebhookEntry(Base, TimestampedMixin, ShopMixin):
│           """Store all webhook entries for audit and replay"""
│           
│           __tablename__ = "webhook_entries"
│           
│           id: Mapped[UUID] = mapped_column(
│               PGUUID(as_uuid=True), 
│               primary_key=True, 
│               default=uuid4
│           )
│           
│           # Source and topic
│           source: Mapped[WebhookSource] = mapped_column(
│               SQLEnum(WebhookSource), 
│               nullable=False,
│               index=True
│           )
│           topic: Mapped[str] = mapped_column(String(255), nullable=False, index=True)
│           
│           # Request data
│           headers: Mapped[dict] = mapped_column(JSON, nullable=False)
│           payload: Mapped[dict] = mapped_column(JSON, nullable=False)
│           hmac_signature: Mapped[str] = mapped_column(Text, nullable=False)
│           
│           # Processing status
│           status: Mapped[WebhookStatus] = mapped_column(
│               SQLEnum(WebhookStatus),
│               nullable=False,
│               default=WebhookStatus.RECEIVED,
│               index=True
│           )
│           attempts: Mapped[int] = mapped_column(Integer, default=0)
│           error: Mapped[str | None] = mapped_column(Text, nullable=True)
│           
│           # Idempotency
│           idempotency_key: Mapped[str] = mapped_column(
│               String(255), 
│               nullable=False, 
│               unique=True,
│               index=True
│           )
│           
│           # Audit
│           processed_at: Mapped[datetime | None] = mapped_column(
│               DateTime(timezone=True), 
│               nullable=True
│           )
│       ```
│       
├── repositories/
│   ├── platform_config_repository.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/repositories/platform_config_repository.py
│   │   """Repository for platform configuration operations."""
│   │   
│   │   from typing import Optional
│   │   from sqlalchemy import select
│   │   from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
│   │   
│   │   from shared.database.repository import Repository
│   │   from ..models.platform_config import PlatformConfiguration
│   │   from ..models.webhook_entry import WebhookSource
│   │   
│   │   
│   │   class PlatformConfigRepository(Repository[PlatformConfiguration]):
│   │       """Repository for platform configuration operations"""
│   │       
│   │       def __init__(self, session_factory: async_sessionmaker[AsyncSession]):
│   │           super().__init__(PlatformConfiguration, session_factory)
│   │       
│   │       async def get_by_source(
│   │           self,
│   │           source: WebhookSource
│   │       ) -> Optional[PlatformConfiguration]:
│   │           """Get configuration for a specific source"""
│   │           async with self.session_factory() as session:
│   │               stmt = select(PlatformConfiguration).where(
│   │                   PlatformConfiguration.source == source,
│   │                   PlatformConfiguration.active == True
│   │               )
│   │               result = await session.execute(stmt)
│   │               return result.scalar_one_or_none()
│   │       
│   │       async def create_or_update(
│   │           self,
│   │           source: WebhookSource,
│   │           webhook_secret: str,
│   │           api_version: Optional[str] = None,
│   │           endpoints: Optional[dict] = None
│   │       ) -> PlatformConfiguration:
│   │           """Create or update platform configuration"""
│   │           async with self.session_factory() as session:
│   │               # Check if exists
│   │               stmt = select(PlatformConfiguration).where(
│   │                   PlatformConfiguration.source == source
│   │               )
│   │               result = await session.execute(stmt)
│   │               config = result.scalar_one_or_none()
│   │               
│   │               if config:
│   │                   # Update existing
│   │                   config.webhook_secret = webhook_secret
│   │                   config.api_version = api_version
│   │                   config.endpoints = endpoints
│   │                   config.active = True
│   │               else:
│   │                   # Create new
│   │                   config = PlatformConfiguration(
│   │                       source=source,
│   │                       webhook_secret=webhook_secret,
│   │                       api_version=api_version,
│   │                       endpoints=endpoints,
│   │                       active=True
│   │                   )
│   │                   session.add(config)
│   │               
│   │               await session.commit()
│   │               await session.refresh(config)
│   │               
│   │               return config
│   │   ```
│   │   
│   └── webhook_repository.py
│       
│       ```py
│       # services/webhook-service/src/repositories/webhook_repository.py
│       """Repository for webhook entry operations."""
│       
│       from typing import Optional, List
│       from uuid import UUID
│       from datetime import datetime, timezone
│       from sqlalchemy import select, update, and_
│       from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
│       
│       from shared.database.repository import Repository
│       from ..models.webhook_entry import WebhookEntry, WebhookStatus, WebhookSource
│       
│       
│       class WebhookRepository(Repository[WebhookEntry]):
│           """Repository for webhook operations"""
│       
│           def __init__(self, session_factory: async_sessionmaker[AsyncSession]):
│               super().__init__(WebhookEntry, session_factory)
│       
│           async def create_entry(
│               self,
│               source: WebhookSource,
│               topic: str,
│               headers: dict,
│               payload: dict,
│               hmac_signature: str,
│               idempotency_key: str,
│               merchant_id: Optional[str] = None,
│               merchant_domain: Optional[str] = None,
│           ) -> WebhookEntry:
│               """Create a new webhook entry"""
│               async with self.session_factory() as session:
│                   entry = WebhookEntry(
│                       source=source,
│                       topic=topic,
│                       headers=headers,
│                       payload=payload,
│                       hmac_signature=hmac_signature,
│                       idempotency_key=idempotency_key,
│                       merchant_id=merchant_id,
│                       merchant_domain=merchant_domain,
│                       status=WebhookStatus.RECEIVED,
│                   )
│       
│                   session.add(entry)
│                   await session.commit()
│                   await session.refresh(entry)
│       
│                   return entry
│       
│           async def find_by_idempotency_key(
│               self, idempotency_key: str
│           ) -> Optional[WebhookEntry]:
│               """Find webhook by idempotency key"""
│               async with self.session_factory() as session:
│                   stmt = select(WebhookEntry).where(
│                       WebhookEntry.idempotency_key == idempotency_key
│                   )
│                   result = await session.execute(stmt)
│                   return result.scalar_one_or_none()
│       
│           async def mark_as_processing(self, entry_id: UUID) -> bool:
│               """Mark webhook as processing"""
│               async with self.session_factory() as session:
│                   stmt = (
│                       update(WebhookEntry)
│                       .where(
│                           and_(
│                               WebhookEntry.id == entry_id,
│                               WebhookEntry.status == WebhookStatus.RECEIVED,
│                           )
│                       )
│                       .values(
│                           status=WebhookStatus.PROCESSING, attempts=WebhookEntry.attempts + 1
│                       )
│                   )
│       
│                   result = await session.execute(stmt)
│                   await session.commit()
│       
│                   return result.rowcount > 0
│       
│           async def mark_as_processed(self, entry_id: UUID) -> bool:
│               """Mark webhook as successfully processed"""
│               async with self.session_factory() as session:
│                   stmt = (
│                       update(WebhookEntry)
│                       .where(WebhookEntry.id == entry_id)
│                       .values(
│                           status=WebhookStatus.PROCESSED,
│                           processed_at=datetime.now(timezone.utc),
│                           error=None,
│                       )
│                   )
│       
│                   result = await session.execute(stmt)
│                   await session.commit()
│       
│                   return result.rowcount > 0
│       
│           async def mark_as_failed(self, entry_id: UUID, error: str) -> bool:
│               """Mark webhook as failed"""
│               async with self.session_factory() as session:
│                   stmt = (
│                       update(WebhookEntry)
│                       .where(WebhookEntry.id == entry_id)
│                       .values(
│                           status=WebhookStatus.FAILED,
│                           error=error,
│                           processed_at=datetime.now(timezone.utc),
│                       )
│                   )
│       
│                   result = await session.execute(stmt)
│                   await session.commit()
│       
│                   return result.rowcount > 0
│       
│           async def get_failed_webhooks(
│               self, max_attempts: int = 5, limit: int = 100
│           ) -> List[WebhookEntry]:
│               """Get failed webhooks for retry"""
│               async with self.session_factory() as session:
│                   stmt = (
│                       select(WebhookEntry)
│                       .where(
│                           and_(
│                               WebhookEntry.status == WebhookStatus.FAILED,
│                               WebhookEntry.attempts < max_attempts,
│                           )
│                       )
│                       .order_by(WebhookEntry.created_at)
│                       .limit(limit)
│                   )
│       
│                   result = await session.execute(stmt)
│                   return list(result.scalars())
│       ```
│       
├── schemas/
│   └── webhook.py
│       
│       ```py
│       # services/webhook-service/src/schemas/webhook.py
│       """Webhook schemas for API requests and responses."""
│       
│       from typing import Optional, Dict, Any, List
│       from datetime import datetime
│       from uuid import UUID
│       from pydantic import BaseModel, Field, ConfigDict, field_validator
│       
│       from ..models.webhook import WebhookStatus
│       
│       
│       class WebhookHeaders(BaseModel):
│           """Common webhook headers"""
│       
│           content_type: str = Field(alias="Content-Type")
│           user_agent: Optional[str] = Field(None, alias="User-Agent")
│       
│           # Platform specific headers will be in extra
│           model_config = ConfigDict(extra="allow", populate_by_name=True)
│       
│       
│       class ShopifyWebhookHeaders(WebhookHeaders):
│           """Shopify specific webhook headers"""
│       
│           x_shopify_topic: str = Field(alias="X-Shopify-Topic")
│           x_shopify_hmac_sha256: str = Field(alias="X-Shopify-Hmac-Sha256")
│           x_shopify_merchant_domain: str = Field(alias="X-Shopify-Shop-Domain")
│           x_shopify_api_version: Optional[str] = Field(None, alias="X-Shopify-API-Version")
│           x_shopify_webhook_id: Optional[str] = Field(None, alias="X-Shopify-Webhook-Id")
│       
│       
│       class WebhookReceive(BaseModel):
│           """Schema for receiving webhook data"""
│       
│           platform: str
│           topic: Optional[str] = None  # May come from headers
│           headers: Dict[str, Any]
│           body: Dict[str, Any]
│           raw_body: bytes = Field(exclude=True)  # For signature validation
│       
│           @field_validator("platform")
│           def validate_platform(cls, v):
│               """Validate platform is supported"""
│               supported = ["shopify", "stripe", "square"]  # Add more as needed
│               if v.lower() not in supported:
│                   raise ValueError(f"Platform {v} not supported. Must be one of {supported}")
│               return v.lower()
│       
│       
│       class WebhookCreate(BaseModel):
│           """Internal schema for creating webhook record"""
│       
│           platform: str
│           topic: str
│           webhook_id: Optional[str] = None
│           merchant_id: str
│           payload: Dict[str, Any]
│           headers: Dict[str, Any]
│           signature: Optional[str] = None
│           status: WebhookStatus = WebhookStatus.RECEIVED
│       
│       
│       class WebhookUpdate(BaseModel):
│           """Update webhook status"""
│       
│           status: WebhookStatus
│           error: Optional[str] = None
│           processed_at: Optional[datetime] = None
│           published_event_id: Optional[str] = None
│           published_event_type: Optional[str] = None
│           attempts: Optional[int] = None
│       
│       
│       class WebhookFilter(BaseModel):
│           """Filter parameters for webhook queries"""
│       
│           platform: Optional[str] = None
│           topic: Optional[str] = None
│           merchant_id: Optional[str] = None
│           status: Optional[WebhookStatus] = None
│           start_date: Optional[datetime] = None
│           end_date: Optional[datetime] = None
│           limit: int = Field(default=100, le=1000)
│           offset: int = Field(default=0, ge=0)
│       
│       
│       class WebhookResponse(BaseModel):
│           """Basic webhook response"""
│       
│           id: UUID
│           platform: str
│           topic: str
│           merchant_id: str
│           status: WebhookStatus
│           received_at: datetime
│           processed_at: Optional[datetime] = None
│           created_at: datetime
│           updated_at: datetime
│       
│           model_config = ConfigDict(from_attributes=True)
│       
│       
│       class WebhookDetailResponse(WebhookResponse):
│           """Detailed webhook response with full information"""
│       
│           webhook_id: Optional[str] = None
│           payload: Dict[str, Any]
│           headers: Dict[str, Any]
│           signature: Optional[str] = None
│           attempts: int
│           error: Optional[str] = None
│           published_event_id: Optional[str] = None
│           published_event_type: Optional[str] = None
│       
│       
│       class WebhookStats(BaseModel):
│           """Webhook statistics"""
│       
│           total: int
│           by_status: Dict[str, int]
│           by_platform: Dict[str, int]
│           by_topic: Dict[str, int]
│           success_rate: float
│           average_processing_time_ms: Optional[float] = None
│       ```
│       
├── services/
│   ├── auth_service.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/services/auth_service.py
│   │   """Authentication service for webhook validation."""
│   │   
│   │   import base64
│   │   import hashlib
│   │   import hmac
│   │   from typing import Optional
│   │   from abc import ABC, abstractmethod
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   from ..models.webhook_entry import WebhookSource
│   │   from ..repositories.platform_config_repository import PlatformConfigRepository
│   │   
│   │   
│   │   class WebhookAuthService:
│   │       """Service for webhook authentication"""
│   │       
│   │       def __init__(
│   │           self,
│   │           platform_config_repo: PlatformConfigRepository,
│   │           shopify_secret: str,
│   │           stripe_secret: Optional[str] = None,
│   │           logger: Optional[ServiceLogger] = None
│   │       ):
│   │           self.platform_config_repo = platform_config_repo
│   │           self.shopify_secret = shopify_secret
│   │           self.stripe_secret = stripe_secret
│   │           self.logger = logger or ServiceLogger(__name__)
│   │       
│   │       def validate_shopify_webhook(
│   │           self, 
│   │           body: bytes, 
│   │           signature: str
│   │       ) -> bool:
│   │           """Validate Shopify webhook HMAC signature"""
│   │           try:
│   │               digest = hmac.new(
│   │                   self.shopify_secret.encode(), 
│   │                   body, 
│   │                   hashlib.sha256
│   │               ).digest()
│   │               expected = base64.b64encode(digest).decode()
│   │               
│   │               return hmac.compare_digest(expected, signature)
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   "Failed to validate Shopify webhook",
│   │                   extra={"error": str(e)}
│   │               )
│   │               return False
│   │       
│   │       def validate_stripe_webhook(
│   │           self, 
│   │           body: bytes, 
│   │           signature: str,
│   │           timestamp: str
│   │       ) -> bool:
│   │           """Validate Stripe webhook signature"""
│   │           if not self.stripe_secret:
│   │               self.logger.error("Stripe webhook secret not configured")
│   │               return False
│   │           
│   │           try:
│   │               # Stripe signature format: t=timestamp,v1=signature
│   │               signed_payload = f"{timestamp}.{body.decode('utf-8')}"
│   │               expected_sig = hmac.new(
│   │                   self.stripe_secret.encode(),
│   │                   signed_payload.encode(),
│   │                   hashlib.sha256
│   │               ).hexdigest()
│   │               
│   │               # Extract v1 signature from header
│   │               sig_parts = dict(part.split('=') for part in signature.split(','))
│   │               provided_sig = sig_parts.get('v1', '')
│   │               
│   │               return hmac.compare_digest(expected_sig, provided_sig)
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   "Failed to validate Stripe webhook",
│   │                   extra={"error": str(e)}
│   │               )
│   │               return False
│   │       
│   │       async def validate_webhook(
│   │           self,
│   │           source: WebhookSource,
│   │           body: bytes,
│   │           headers: dict
│   │       ) -> bool:
│   │           """Validate webhook based on source"""
│   │           if source == WebhookSource.SHOPIFY:
│   │               signature = headers.get('x-shopify-hmac-sha256', '')
│   │               return self.validate_shopify_webhook(body, signature)
│   │           
│   │           elif source == WebhookSource.STRIPE:
│   │               signature = headers.get('stripe-signature', '')
│   │               # Extract timestamp from signature header
│   │               sig_parts = dict(part.split('=') for part in signature.split(','))
│   │               timestamp = sig_parts.get('t', '')
│   │               return self.validate_stripe_webhook(body, signature, timestamp)
│   │           
│   │           else:
│   │               self.logger.warning(f"Unknown webhook source: {source}")
│   │               return False
│   │   ```
│   │   
│   ├── circuite_breaker_service.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/services/circuit_breaker_service.py
│   │   """Circuit breaker for downstream services."""
│   │   
│   │   from typing import Optional, Dict
│   │   from datetime import datetime, timedelta
│   │   from enum import Enum
│   │   import json
│   │   import redis.asyncio as redis
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   
│   │   
│   │   class CircuitState(str, Enum):
│   │       """Circuit breaker states"""
│   │       CLOSED = "CLOSED"  # Normal operation
│   │       OPEN = "OPEN"      # Failing, reject requests
│   │       HALF_OPEN = "HALF_OPEN"  # Testing recovery
│   │   
│   │   
│   │   class CircuitBreakerService:
│   │       """
│   │       Circuit breaker implementation using Redis for state storage.
│   │       
│   │       Protects downstream services from cascading failures.
│   │       """
│   │       
│   │       def __init__(
│   │           self,
│   │           redis_client: redis.Redis,
│   │           failure_threshold: int = 5,
│   │           timeout_seconds: int = 60,
│   │           window_seconds: int = 30,
│   │           logger: Optional[ServiceLogger] = None
│   │       ):
│   │           self.redis = redis_client
│   │           self.failure_threshold = failure_threshold
│   │           self.timeout_seconds = timeout_seconds
│   │           self.window_seconds = window_seconds
│   │           self.logger = logger or ServiceLogger(__name__)
│   │           self.key_prefix = "webhook:circuit:"
│   │       
│   │       async def can_proceed(self, subject: str) -> bool:
│   │           """Check if request can proceed for given subject"""
│   │           state = await self._get_state(subject)
│   │           
│   │           if state["state"] == CircuitState.CLOSED:
│   │               return True
│   │           
│   │           elif state["state"] == CircuitState.OPEN:
│   │               # Check if timeout has passed
│   │               if datetime.utcnow() > state["open_until"]:
│   │                   # Move to half-open
│   │                   await self._set_state(subject, CircuitState.HALF_OPEN)
│   │                   return True
│   │               return False
│   │           
│   │           elif state["state"] == CircuitState.HALF_OPEN:
│   │               # Allow one request through to test
│   │               return True
│   │           
│   │           return False
│   │       
│   │       async def record_success(self, subject: str):
│   │           """Record successful request"""
│   │           state = await self._get_state(subject)
│   │           
│   │           if state["state"] == CircuitState.HALF_OPEN:
│   │               # Recovery successful, close circuit
│   │               await self._set_state(subject, CircuitState.CLOSED)
│   │               await self._reset_failures(subject)
│   │               
│   │               self.logger.info(
│   │                   f"Circuit closed for {subject} after successful recovery"
│   │               )
│   │       
│   │       async def record_failure(self, subject: str):
│   │           """Record failed request"""
│   │           state = await self._get_state(subject)
│   │           
│   │           if state["state"] == CircuitState.HALF_OPEN:
│   │               # Still failing, reopen
│   │               await self._set_state(subject, CircuitState.OPEN)
│   │               self.logger.warning(
│   │                   f"Circuit reopened for {subject} after half-open failure"
│   │               )
│   │               return
│   │           
│   │           # Increment failure count
│   │           failures = await self._increment_failures(subject)
│   │           
│   │           if failures >= self.failure_threshold:
│   │               await self._set_state(subject, CircuitState.OPEN)
│   │               self.logger.warning(
│   │                   f"Circuit opened for {subject} after {failures} failures"
│   │               )
│   │       
│   │       async def _get_state(self, subject: str) -> Dict:
│   │           """Get current circuit state"""
│   │           key = f"{self.key_prefix}state:{subject}"
│   │           
│   │           try:
│   │               data = await self.redis.get(key)
│   │               if data:
│   │                   state_data = json.loads(data)
│   │                   # Parse datetime
│   │                   if "open_until" in state_data:
│   │                       state_data["open_until"] = datetime.fromisoformat(
│   │                           state_data["open_until"]
│   │                       )
│   │                   return state_data
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to get circuit state: {e}")
│   │           
│   │           # Default state
│   │           return {
│   │               "state": CircuitState.CLOSED,
│   │               "failures": 0,
│   │               "last_failure": None,
│   │               "open_until": None
│   │           }
│   │       
│   │       async def _set_state(
│   │           self, 
│   │           subject: str, 
│   │           state: CircuitState
│   │       ):
│   │           """Set circuit state"""
│   │           key = f"{self.key_prefix}state:{subject}"
│   │           
│   │           state_data = {
│   │               "state": state,
│   │               "updated_at": datetime.utcnow().isoformat()
│   │           }
│   │           
│   │           if state == CircuitState.OPEN:
│   │               state_data["open_until"] = (
│   │                   datetime.utcnow() + timedelta(seconds=self.timeout_seconds)
│   │               ).isoformat()
│   │           
│   │           try:
│   │               await self.redis.setex(
│   │                   key,
│   │                   self.timeout_seconds * 2,  # Expire after 2x timeout
│   │                   json.dumps(state_data)
│   │               )
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to set circuit state: {e}")
│   │       
│   │       async def _increment_failures(self, subject: str) -> int:
│   │           """Increment failure count within window"""
│   │           key = f"{self.key_prefix}failures:{subject}"
│   │           
│   │           try:
│   │               # Use Redis increment with expiry
│   │               failures = await self.redis.incr(key)
│   │               
│   │               # Set expiry on first failure
│   │               if failures == 1:
│   │                   await self.redis.expire(key, self.window_seconds)
│   │               
│   │               return failures
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to increment failures: {e}")
│   │               return 0
│   │       
│   │       async def _reset_failures(self, subject: str):
│   │           """Reset failure count"""
│   │           key = f"{self.key_prefix}failures:{subject}"
│   │           
│   │           try:
│   │               await self.redis.delete(key)
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to reset failures: {e}")
│   │       
│   │       async def get_status(self, subject: str) -> Dict:
│   │           """Get detailed circuit status (for monitoring)"""
│   │           state = await self._get_state(subject)
│   │           
│   │           # Get failure count
│   │           failures_key = f"{self.key_prefix}failures:{subject}"
│   │           try:
│   │               failures = await self.redis.get(failures_key)
│   │               state["current_failures"] = int(failures) if failures else 0
│   │           except:
│   │               state["current_failures"] = 0
│   │           
│   │           return state
│   │   ```
│   │   
│   ├── deduplication_service.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/services/deduplication_service.py
│   │   """Service for webhook deduplication using Redis."""
│   │   
│   │   from typing import Optional
│   │   import redis.asyncio as redis
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   
│   │   
│   │   class DeduplicationService:
│   │       """Handle webhook deduplication via Redis"""
│   │       
│   │       def __init__(
│   │           self,
│   │           redis_client: redis.Redis,
│   │           ttl_hours: int = 24,
│   │           logger: Optional[ServiceLogger] = None
│   │       ):
│   │           self.redis = redis_client
│   │           self.ttl_seconds = ttl_hours * 3600
│   │           self.logger = logger or ServiceLogger(__name__)
│   │           self.key_prefix = "webhook:dedup:"
│   │       
│   │       async def is_duplicate(self, idempotency_key: str) -> bool:
│   │           """Check if webhook has been seen before"""
│   │           key = f"{self.key_prefix}{idempotency_key}"
│   │           
│   │           try:
│   │               exists = await self.redis.exists(key)
│   │               return bool(exists)
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   f"Failed to check deduplication: {e}",
│   │                   extra={"idempotency_key": idempotency_key}
│   │               )
│   │               # Fail open - process webhook if Redis fails
│   │               return False
│   │       
│   │       async def mark_as_seen(self, idempotency_key: str) -> bool:
│   │           """Mark webhook as processed"""
│   │           key = f"{self.key_prefix}{idempotency_key}"
│   │           
│   │           try:
│   │               # Set with TTL
│   │               await self.redis.setex(
│   │                   key,
│   │                   self.ttl_seconds,
│   │                   "1"
│   │               )
│   │               return True
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   f"Failed to mark as seen: {e}",
│   │                   extra={"idempotency_key": idempotency_key}
│   │               )
│   │               return False
│   │       
│   │       async def remove(self, idempotency_key: str) -> bool:
│   │           """Remove idempotency key (for testing/replay)"""
│   │           key = f"{self.key_prefix}{idempotency_key}"
│   │           
│   │           try:
│   │               result = await self.redis.delete(key)
│   │               return bool(result)
│   │           except Exception as e:
│   │               self.logger.error(
│   │                   f"Failed to remove key: {e}",
│   │                   extra={"idempotency_key": idempotency_key}
│   │               )
│   │               return False
│   │   ```
│   │   
│   └── webhook_service.py
│       
│       ```py
│       # services/webhook-service/src/services/webhook_service.py
│       """Main webhook processing service."""
│       
│       import json
│       from typing import Optional, Dict, Any, Type
│       from uuid import UUID
│       from datetime import datetime, timezone
│       
│       from shared.utils.logger import ServiceLogger
│       from shared.events import EventContextManager
│       from shared.errors import ValidationError, NotFoundError
│       
│       from ..models.webhook_entry import WebhookEntry, WebhookSource, WebhookStatus
│       from ..repositories.webhook_repository import WebhookRepository
│       from ..events.publishers import WebhookEventPublisher
│       from ..handlers.base import WebhookHandler
│       from ..handlers.shopify import ShopifyWebhookHandler
│       from ..handlers.stripe import StripeWebhookHandler
│       from .auth_service import WebhookAuthService
│       from .deduplication_service import DeduplicationService
│       from .circuit_breaker_service import CircuitBreakerService
│       
│       
│       class WebhookService:
│           """Main service for webhook processing"""
│       
│           def __init__(
│               self,
│               webhook_repo: WebhookRepository,
│               auth_service: WebhookAuthService,
│               dedup_service: DeduplicationService,
│               circuit_breaker: CircuitBreakerService,
│               publisher: WebhookEventPublisher,
│               logger: Optional[ServiceLogger] = None,
│           ):
│               self.webhook_repo = webhook_repo
│               self.auth_service = auth_service
│               self.dedup_service = dedup_service
│               self.circuit_breaker = circuit_breaker
│               self.publisher = publisher
│               self.logger = logger or ServiceLogger(__name__)
│               self.context_manager = EventContextManager(self.logger)
│       
│               # Initialize handlers
│               self.handlers: Dict[WebhookSource, WebhookHandler] = {
│                   WebhookSource.SHOPIFY: ShopifyWebhookHandler(logger=self.logger),
│                   WebhookSource.STRIPE: StripeWebhookHandler(logger=self.logger),
│               }
│       
│           async def process_webhook(
│               self,
│               source: WebhookSource,
│               headers: dict,
│               body: bytes,
│               topic: Optional[str] = None,
│           ) -> Dict[str, Any]:
│               """
│               Process incoming webhook with full validation and deduplication
│       
│               Returns:
│                   Dict with processing result
│               """
│               start_time = datetime.now(timezone.utc)
│               correlation_id = headers.get("x-correlation-id") or str(UUID())
│       
│               self.logger.info(
│                   "Processing webhook",
│                   extra={
│                       "source": source.value,
│                       "topic": topic,
│                       "correlation_id": correlation_id,
│                   },
│               )
│       
│               try:
│                   # 1. Validate signature
│                   if not await self.auth_service.validate_webhook(source, body, headers):
│                       await self.publisher.publish_validation_failed(
│                           source=source.value,
│                           reason="Invalid signature",
│                           topic=topic,
│                           correlation_id=correlation_id,
│                       )
│                       raise ValidationError("Invalid webhook signature")
│       
│                   # 2. Get handler
│                   handler = self.handlers.get(source)
│                   if not handler:
│                       raise ValidationError(f"No handler for source: {source}")
│       
│                   # 3. Parse webhook
│                   parsed = json.loads(body.decode("utf-8"))
│                   webhook_data = handler.parse_webhook(parsed, topic, headers)
│       
│                   # 4. Check deduplication
│                   idempotency_key = webhook_data.idempotency_key
│                   if await self.dedup_service.is_duplicate(idempotency_key):
│                       self.logger.info(
│                           "Duplicate webhook detected",
│                           extra={
│                               "idempotency_key": idempotency_key,
│                               "source": source.value,
│                               "topic": webhook_data.topic,
│                           },
│                       )
│                       return {"status": "duplicate", "message": "Webhook already processed"}
│       
│                   # 5. Store webhook entry
│                   entry = await self.webhook_repo.create_entry(
│                       source=source,
│                       topic=webhook_data.topic,
│                       headers=headers,
│                       payload=parsed,
│                       hmac_signature=headers.get(
│                           (
│                               "x-shopify-hmac-sha256"
│                               if source == WebhookSource.SHOPIFY
│                               else "stripe-signature"
│                           ),
│                           "",
│                       ),
│                       idempotency_key=idempotency_key,
│                       merchant_id=webhook_data.merchant_id,
│                       merchant_domain=webhook_data.merchant_domain,
│                   )
│       
│                   # 6. Mark as seen for deduplication
│                   await self.dedup_service.mark_as_seen(idempotency_key)
│       
│                   # 7. Publish raw webhook received event
│                   await self.publisher.publish_webhook_received(
│                       source=source.value,
│                       topic=webhook_data.topic,
│                       merchant_id=webhook_data.merchant_id,
│                       merchant_domain=webhook_data.merchant_domain,
│                       webhook_id=str(entry.id),
│                       correlation_id=correlation_id,
│                   )
│       
│                   # 8. Map to domain event
│                   domain_event = handler.map_to_domain_event(webhook_data)
│       
│                   if domain_event:
│                       # 9. Check circuit breaker
│                       subject = domain_event.event_type
│                       if not await self.circuit_breaker.can_proceed(subject):
│                           self.logger.warning(
│                               "Circuit breaker open", extra={"subject": subject}
│                           )
│                           await self.webhook_repo.mark_as_failed(
│                               entry.id, "Circuit breaker open"
│                           )
│                           raise ValidationError("Circuit breaker open")
│       
│                       # 10. Publish domain event
│                       try:
│                           await self.publisher.publish_domain_event(
│                               event_type=domain_event.event_type,
│                               payload=domain_event.payload,
│                               correlation_id=correlation_id,
│                               metadata={
│                                   "webhook_id": str(entry.id),
│                                   "source": source.value,
│                                   "topic": webhook_data.topic,
│                               },
│                           )
│       
│                           # Record success
│                           await self.circuit_breaker.record_success(subject)
│       
│                       except Exception as e:
│                           # Record failure
│                           await self.circuit_breaker.record_failure(subject)
│                           raise
│       
│                   # 11. Mark as processed
│                   await self.webhook_repo.mark_as_processed(entry.id)
│       
│                   # 12. Publish processed event
│                   await self.publisher.publish_webhook_processed(
│                       entry_id=str(entry.id),
│                       source=source.value,
│                       topic=webhook_data.topic,
│                       event_type=domain_event.event_type if domain_event else "none",
│                       merchant_id=webhook_data.merchant_id,
│                       merchant_domain=webhook_data.merchant_domain,
│                       correlation_id=correlation_id,
│                   )
│       
│                   processing_time = (datetime.now(timezone.utc) - start_time).total_seconds()
│                   self.logger.info(
│                       "Webhook processed successfully",
│                       extra={
│                           "entry_id": str(entry.id),
│                           "source": source.value,
│                           "topic": webhook_data.topic,
│                           "processing_time": processing_time,
│                           "correlation_id": correlation_id,
│                       },
│                   )
│       
│                   return {
│                       "status": "processed",
│                       "entry_id": str(entry.id),
│                       "processing_time": processing_time,
│                   }
│       
│               except Exception as e:
│                   self.logger.error(
│                       "Failed to process webhook",
│                       extra={
│                           "source": source.value,
│                           "topic": topic,
│                           "error": str(e),
│                           "correlation_id": correlation_id,
│                       },
│                   )
│       
│                   # Try to mark as failed if we have an entry
│                   if "entry" in locals():
│                       await self.webhook_repo.mark_as_failed(entry.id, str(e))
│       
│                       await self.publisher.publish_webhook_failed(
│                           entry_id=str(entry.id),
│                           source=source.value,
│                           topic=topic or "unknown",
│                           error=str(e),
│                           attempts=1,
│                           correlation_id=correlation_id,
│                       )
│       
│                   raise
│       ```
│       
├── __init__.py
├── config.py
│   
│   ```py
│   from functools import lru_cache
│   from typing import Optional
│   from pydantic import BaseModel, Field
│   from shared.config.loader import merged_config
│   from shared.database import DatabaseConfig, create_database_config
│   
│   
│   class WebhookConfig(BaseModel):
│       # Service Identity (from shared + service YAML)
│       service_name: str = Field(..., alias="service.name")
│       service_version: str = Field(..., alias="service.version")
│       environment: str
│       debug: bool
│       
│       # API Configuration (from shared + service YAML)
│       api_host: str = Field(..., alias="api.host")
│       api_port: int = Field(..., alias="api.port")
│       api_workers: int = Field(..., alias="api.workers")
│       
│       # Infrastructure (from shared YAML)
│       infrastructure_nats_url: str = Field(..., alias="infrastructure.nats_url")
│       infrastructure_redis_url: str = Field(..., alias="infrastructure.redis_url")
│       
│       # Database (from shared YAML)
│       database_host: str = Field(..., alias="database.host")
│       database_port: int = Field(..., alias="database.port")
│       database_pool_size: int = Field(..., alias="database.pool_size")
│       database_echo: bool = Field(..., alias="database.echo")
│       
│       # Logging (from shared YAML)
│       logging_level: str = Field(..., alias="logging.level")
│       logging_format: str = Field(..., alias="logging.format")
│       
│       # Rate Limiting (from shared YAML)
│       rate_limiting_enabled: bool = Field(..., alias="rate_limiting.enabled")
│       rate_limiting_window_seconds: int = Field(..., alias="rate_limiting.window_seconds")
│       
│       # Monitoring (from shared YAML)
│       monitoring_metrics_enabled: bool = Field(..., alias="monitoring.metrics_enabled")
│       
│       # Webhook Configuration (service-specific)
│       webhook_max_payload_size_mb: int = Field(..., alias="webhook.max_payload_size_mb")
│       webhook_dedup_ttl_hours: int = Field(..., alias="webhook.dedup_ttl_hours")
│       
│       # Circuit Breaker Configuration (service-specific)
│       circuit_breaker_failure_threshold: int = Field(..., alias="circuit_breaker.failure_threshold")
│       circuit_breaker_recovery_timeout: int = Field(..., alias="circuit_breaker.recovery_timeout")
│       
│       # External Services (env-only, optional)
│       shopify_webhook_secret: Optional[str] = None
│       stripe_webhook_secret: Optional[str] = None
│       
│       @property
│       def database_config(self) -> DatabaseConfig:
│           """Get database configuration"""
│           return create_database_config(prefix="WEBHOOK_")
│   
│   
│   @lru_cache
│   def get_service_config() -> WebhookConfig:
│       """Load and cache service configuration"""
│       cfg_dict = merged_config("webhook", env_prefix="WEBHOOK")
│       return WebhookConfig(**cfg_dict)
│   ```
│   
├── dependencies.py
│   
│   ```py
│   # services/webhook-service/src/dependencies.py
│   """
│   FastAPI dependencies for webhook service.
│   
│   Follows the same pattern as notification service.
│   """
│   
│   from typing import Annotated, Any
│   from fastapi import Depends, Request, HTTPException
│   
│   from shared.database.dependencies import DBSessionDep
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   
│   from .lifecycle import ServiceLifecycle
│   from .services.webhook_service import WebhookService
│   from .services.auth_service import WebhookAuthService
│   from .services.deduplication_service import DeduplicationService
│   from .services.circuit_breaker_service import CircuitBreakerService
│   from .repositories.webhook_repository import WebhookRepository
│   from .repositories.platform_config_repository import PlatformConfigRepository
│   from .events.publishers import WebhookEventPublisher
│   
│   
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       """Get service lifecycle from app state"""
│       return request.app.state.lifecycle
│   
│   
│   def get_config(request: Request):
│       """Get service config from app state"""
│       return request.app.state.config
│   
│   
│   # Type aliases for core dependencies
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[Any, Depends(get_config)]
│   
│   
│   # Messaging dependencies
│   def get_messaging_wrapper(lifecycle: LifecycleDep) -> JetStreamWrapper:
│       """Get messaging wrapper"""
│       if not lifecycle.messaging_wrapper:
│           raise HTTPException(500, "Messaging not initialized")
│       return lifecycle.messaging_wrapper
│   
│   
│   def get_publisher(wrapper: Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)]) -> WebhookEventPublisher:
│       """Get webhook event publisher"""
│       pub = wrapper.get_publisher(WebhookEventPublisher)
│       if not pub:
│           raise HTTPException(500, "WebhookEventPublisher not initialized")
│       return pub
│   
│   
│   # Type aliases for messaging
│   MessagingDep = Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)]
│   PublisherDep = Annotated[WebhookEventPublisher, Depends(get_publisher)]
│   
│   
│   # Repository dependencies
│   def get_webhook_repo(lifecycle: LifecycleDep) -> WebhookRepository:
│       """Get webhook repository"""
│       if not lifecycle.webhook_repo:
│           raise HTTPException(500, "WebhookRepository not initialized")
│       return lifecycle.webhook_repo
│   
│   
│   def get_platform_config_repo(lifecycle: LifecycleDep) -> PlatformConfigRepository:
│       """Get platform config repository"""
│       if not lifecycle.platform_config_repo:
│           raise HTTPException(500, "PlatformConfigRepository not initialized")
│       return lifecycle.platform_config_repo
│   
│   
│   # Type aliases for repositories
│   WebhookRepoDep = Annotated[WebhookRepository, Depends(get_webhook_repo)]
│   PlatformConfigRepoDep = Annotated[PlatformConfigRepository, Depends(get_platform_config_repo)]
│   
│   
│   # Service dependencies
│   def get_auth_service(lifecycle: LifecycleDep) -> WebhookAuthService:
│       """Get auth service"""
│       if not lifecycle.auth_service:
│           raise HTTPException(500, "AuthService not initialized")
│       return lifecycle.auth_service
│   
│   
│   def get_dedup_service(lifecycle: LifecycleDep) -> DeduplicationService:
│       """Get deduplication service"""
│       if not lifecycle.dedup_service:
│           raise HTTPException(500, "DeduplicationService not initialized")
│       return lifecycle.dedup_service
│   
│   
│   def get_circuit_breaker(lifecycle: LifecycleDep) -> CircuitBreakerService:
│       """Get circuit breaker service"""
│       if not lifecycle.circuit_breaker:
│           raise HTTPException(500, "CircuitBreakerService not initialized")
│       return lifecycle.circuit_breaker
│   
│   
│   def get_webhook_service(lifecycle: LifecycleDep) -> WebhookService:
│       """Get webhook service"""
│       if not lifecycle.webhook_service:
│           raise HTTPException(500, "WebhookService not initialized")
│       return lifecycle.webhook_service
│   
│   
│   # Type aliases for services
│   AuthServiceDep = Annotated[WebhookAuthService, Depends(get_auth_service)]
│   DedupServiceDep = Annotated[DeduplicationService, Depends(get_dedup_service)]
│   CircuitBreakerDep = Annotated[CircuitBreakerService, Depends(get_circuit_breaker)]
│   WebhookServiceDep = Annotated[WebhookService, Depends(get_webhook_service)]
│   ```
│   
├── exceptions.py
│   
│   ```py
│   # services/webhook-service/src/exceptions.py
│   """
│   Webhook service exceptions using shared error classes.
│   
│   All exceptions are re-exported from shared.errors for consistency
│   across the platform.
│   """
│   
│   from shared.errors import (
│       # Base exceptions
│       BaseServiceError,
│       
│       # Client errors (4xx)
│       ValidationError,
│       NotFoundError,
│       ConflictError,
│       UnauthorizedError,
│       ForbiddenError,
│       RateLimitError,
│       
│       # Server errors (5xx)
│       InternalError,
│       ExternalServiceError,
│       DatabaseError,
│       MessagingError,
│       ConfigurationError,
│       
│       # Business logic errors
│       BusinessRuleViolation,
│       ResourceExhausted,
│       OperationNotAllowed,
│   )
│   
│   # Service-specific exceptions can be added here if needed
│   class WebhookValidationError(ValidationError):
│       """Specific validation error for webhooks"""
│       pass
│   
│   
│   class WebhookSignatureError(UnauthorizedError):
│       """Invalid webhook signature"""
│       pass
│   
│   
│   class WebhookDuplicateError(ConflictError):
│       """Webhook already processed"""
│       pass
│   
│   
│   __all__ = [
│       # Re-exported from shared
│       "BaseServiceError",
│       "ValidationError",
│       "NotFoundError",
│       "ConflictError",
│       "UnauthorizedError",
│       "ForbiddenError",
│       "RateLimitError",
│       "InternalError",
│       "ExternalServiceError",
│       "DatabaseError",
│       "MessagingError",
│       "ConfigurationError",
│       "BusinessRuleViolation",
│       "ResourceExhausted",
│       "OperationNotAllowed",
│       
│       # Service-specific
│       "WebhookValidationError",
│       "WebhookSignatureError",
│       "WebhookDuplicateError",
│   ]
│   ```
│   
├── lifecycle.py
│   
│   ```py
│   # services/webhook-service/src/lifecycle.py
│   """
│   Service lifecycle management for webhook service.
│   
│   Manages initialization and cleanup of all service components.
│   """
│   
│   from __future__ import annotations
│   
│   import asyncio
│   from typing import List, Optional, cast
│   
│   from nats.js.api import StreamConfig, RetentionPolicy, StorageType
│   import redis.asyncio as redis
│   
│   from shared.utils.logger import create_logger, ServiceLogger
│   from shared.database import DatabaseSessionManager, set_database_manager
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   
│   from .config import ServiceConfig
│   from .services.auth_service import WebhookAuthService
│   from .services.deduplication_service import DeduplicationService
│   from .services.circuit_breaker_service import CircuitBreakerService
│   from .services.webhook_service import WebhookService
│   
│   # repositories
│   from .repositories.webhook_repository import WebhookRepository
│   from .repositories.platform_config_repository import PlatformConfigRepository
│   
│   # models
│   from .models.webhook_entry import WebhookEntry
│   from .models.platform_config import PlatformConfiguration
│   
│   # events
│   from .events.publishers import WebhookEventPublisher
│   
│   
│   class ServiceLifecycle:
│       """Manages lifecycle of webhook service components"""
│       
│       def __init__(self, config: ServiceConfig):
│           self.config = config
│           self.logger = create_logger(service_name=config.SERVICE_NAME)
│           
│           # Core infrastructure
│           self.db_manager: Optional[DatabaseSessionManager] = None
│           self.messaging_wrapper: Optional[JetStreamWrapper] = None
│           self.redis_client: Optional[redis.Redis] = None
│           
│           # Repositories
│           self.webhook_repo: Optional[WebhookRepository] = None
│           self.platform_config_repo: Optional[PlatformConfigRepository] = None
│           
│           # Services
│           self.auth_service: Optional[WebhookAuthService] = None
│           self.dedup_service: Optional[DeduplicationService] = None
│           self.circuit_breaker: Optional[CircuitBreakerService] = None
│           self.webhook_service: Optional[WebhookService] = None
│           
│           # Background tasks
│           self._background_tasks: List[asyncio.Task] = []
│       
│       async def startup(self):
│           """Initialize all service components"""
│           self.logger.info("Starting webhook service lifecycle")
│           
│           try:
│               # 1. Database
│               await self._init_database()
│               
│               # 2. Redis
│               await self._init_redis()
│               
│               # 3. Messaging
│               await self._init_messaging()
│               
│               # 4. Repositories
│               self._init_repositories()
│               
│               # 5. Services
│               self._init_services()
│               
│               # 6. Background tasks
│               await self._start_background_tasks()
│               
│               self.logger.info("Webhook service lifecycle started successfully")
│               
│           except Exception as e:
│               self.logger.error(f"Failed to start webhook service: {e}")
│               await self.shutdown()
│               raise
│       
│       async def shutdown(self):
│           """Clean shutdown of all components"""
│           self.logger.info("Shutting down webhook service lifecycle")
│           
│           # Cancel background tasks
│           for task in self._background_tasks:
│               if not task.done():
│                   task.cancel()
│           
│           if self._background_tasks:
│               await asyncio.gather(*self._background_tasks, return_exceptions=True)
│           
│           # Close connections
│           if self.redis_client:
│               await self.redis_client.close()
│           
│           if self.messaging_wrapper:
│               await self.messaging_wrapper.close()
│           
│           if self.db_manager:
│               await self.db_manager.close()
│           
│           self.logger.info("Webhook service lifecycle shutdown complete")
│       
│       async def _init_database(self):
│           """Initialize database connection"""
│           self.db_manager = DatabaseSessionManager(
│               database_url=self.config.DATABASE_URL,
│               echo=self.config.DB_ECHO
│           )
│           await self.db_manager.connect()
│           
│           # Create tables if needed
│           from .models import Base
│           async with self.db_manager.engine.begin() as conn:
│               await conn.run_sync(Base.metadata.create_all)
│           
│           # Set global database manager
│           set_database_manager(self.db_manager)
│           
│           self.logger.info("Database initialized")
│       
│       async def _init_redis(self):
│           """Initialize Redis connection"""
│           self.redis_client = await redis.from_url(
│               self.config.REDIS_URL,
│               decode_responses=True
│           )
│           await self.redis_client.ping()
│           self.logger.info("Redis initialized")
│       
│       async def _init_messaging(self):
│           """Initialize NATS/JetStream"""
│           self.messaging_wrapper = JetStreamWrapper(logger=self.logger)
│           await self.messaging_wrapper.connect([self.config.NATS_URL])
│           
│           # Ensure WEBHOOK stream exists
│           stream_config = StreamConfig(
│               name="WEBHOOK",
│               subjects=[
│                   "evt.webhook.*",
│                   "evt.webhook.>",
│                   "cmd.webhook.*",
│                   "cmd.webhook.>"
│               ],
│               retention=RetentionPolicy.LIMITS,
│               storage=StorageType.FILE,
│               max_msgs=1_000_000,
│               max_age=86400 * 7,  # 7 days
│               max_msg_size=10 * 1024 * 1024,  # 10MB
│               discard="old",
│               num_replicas=3
│           )
│           
│           js = self.messaging_wrapper._js
│           try:
│               await js.add_stream(stream_config)
│               self.logger.info("Created WEBHOOK stream")
│           except Exception:
│               await js.update_stream(stream_config)
│               self.logger.info("Updated WEBHOOK stream")
│       
│       def _init_repositories(self):
│           """Initialize repositories"""
│           if not self.db_manager:
│               raise RuntimeError("Database not initialized")
│           
│           session_factory = self.db_manager.session_factory
│           
│           self.webhook_repo = WebhookRepository(session_factory)
│           self.platform_config_repo = PlatformConfigRepository(session_factory)
│           
│           self.logger.info("Repositories initialized")
│       
│       def _init_services(self):
│           """Initialize services"""
│           if not all([
│               self.webhook_repo,
│               self.platform_config_repo,
│               self.redis_client,
│               self.messaging_wrapper
│           ]):
│               raise RuntimeError("Required dependencies not initialized")
│           
│           # Auth service
│           self.auth_service = WebhookAuthService(
│               platform_config_repo=self.platform_config_repo,
│               shopify_secret=self.config.SHOPIFY_WEBHOOK_SECRET,
│               stripe_secret=self.config.STRIPE_WEBHOOK_SECRET,
│               logger=self.logger
│           )
│           
│           # Deduplication service
│           self.dedup_service = DeduplicationService(
│               redis_client=self.redis_client,
│               ttl_hours=self.config.DEDUP_TTL_HOURS,
│               logger=self.logger
│           )
│           
│           # Circuit breaker service
│           self.circuit_breaker = CircuitBreakerService(
│               redis_client=self.redis_client,
│               failure_threshold=self.config.CIRCUIT_BREAKER_FAILURE_THRESHOLD,
│               timeout_seconds=self.config.CIRCUIT_BREAKER_TIMEOUT_SECONDS,
│               window_seconds=self.config.CIRCUIT_BREAKER_WINDOW_SECONDS,
│               logger=self.logger
│           )
│           
│           # Publisher
│           publisher = self.messaging_wrapper.create_publisher(WebhookEventPublisher)
│           
│           # Main webhook service
│           self.webhook_service = WebhookService(
│               webhook_repo=self.webhook_repo,
│               auth_service=self.auth_service,
│               dedup_service=self.dedup_service,
│               circuit_breaker=self.circuit_breaker,
│               publisher=publisher,
│               logger=self.logger
│           )
│           
│           self.logger.info("Services initialized")
│       
│       async def _start_background_tasks(self):
│           """Start background tasks"""
│           # Could add DLQ processor, metrics reporter, etc.
│           pass
│   ```
│   
├── main.py
│   
│   ```py
│   # services/webhook-service/src/main.py
│   """
│   Webhook service FastAPI application.
│   
│   Entry point for the webhook service that receives and processes
│   external webhooks from various platforms.
│   """
│   
│   from contextlib import asynccontextmanager
│   from fastapi import FastAPI, Request
│   from fastapi.middleware.cors import CORSMiddleware
│   from fastapi.exceptions import RequestValidationError
│   from starlette.exceptions import HTTPException as StarletteHTTPException
│   
│   from shared.api.error_handlers import (
│       validation_exception_handler,
│       http_exception_handler,
│       general_exception_handler
│   )
│   from shared.api.middleware import (
│       RequestLoggingMiddleware,
│       CorrelationIdMiddleware,
│       MetricsMiddleware
│   )
│   from shared.monitoring.metrics import init_metrics
│   
│   from .config import get_config
│   from .lifecycle import ServiceLifecycle
│   from .api.v1 import health, webhooks
│   
│   
│   @asynccontextmanager
│   async def lifespan(app: FastAPI):
│       """Manage application lifecycle"""
│       # Startup
│       config = get_config()
│       lifecycle = ServiceLifecycle(config)
│       
│       await lifecycle.startup()
│       
│       # Store in app state
│       app.state.lifecycle = lifecycle
│       app.state.config = config
│       
│       # Initialize metrics
│       init_metrics(service_name=config.SERVICE_NAME)
│       
│       yield
│       
│       # Shutdown
│       await lifecycle.shutdown()
│   
│   
│   # Create FastAPI app
│   app = FastAPI(
│       title="Webhook Service",
│       description="Unified webhook ingestion service for GlamYouUp platform",
│       version="2.0.0",
│       docs_url="/docs",
│       redoc_url="/redoc",
│       lifespan=lifespan
│   )
│   
│   # Add middleware
│   app.add_middleware(MetricsMiddleware)
│   app.add_middleware(CorrelationIdMiddleware)
│   app.add_middleware(RequestLoggingMiddleware)
│   
│   # CORS
│   app.add_middleware(
│       CORSMiddleware,
│       allow_origins=["*"],  # Configure based on environment
│       allow_credentials=True,
│       allow_methods=["*"],
│       allow_headers=["*"],
│   )
│   
│   # Exception handlers
│   app.add_exception_handler(RequestValidationError, validation_exception_handler)
│   app.add_exception_handler(StarletteHTTPException, http_exception_handler)
│   app.add_exception_handler(Exception, general_exception_handler)
│   
│   # Include routers
│   app.include_router(health.router, prefix="/api/v1")
│   app.include_router(webhooks.router, prefix="/api/v1")
│   
│   
│   @app.get("/")
│   async def root():
│       """Root endpoint"""
│       return {
│           "service": "webhook-service",
│           "version": "2.0.0",
│           "status": "operational"
│       }
│   ```
│   
└── metrics.py
    
    ```py
    # services/webhook-service/src/metrics.py
    """
    Prometheus metrics for webhook service.
    
    Tracks:
    - Webhook reception and processing
    - Platform-specific metrics
    - Error rates
    - Processing times
    """
    
    from prometheus_client import Counter, Histogram, Gauge, Info
    
    # Service info
    service_info = Info("webhook_service", "Webhook service information")
    
    # Webhook metrics
    webhooks_received_total = Counter(
        "webhooks_received_total",
        "Total number of webhooks received",
        ["platform", "topic", "status"],
    )
    
    webhook_validation_failures_total = Counter(
        "webhook_validation_failures_total",
        "Total number of webhook validation failures",
        ["platform", "reason"],
    )
    
    webhook_processing_duration_seconds = Histogram(
        "webhook_processing_duration_seconds",
        "Time spent processing webhooks",
        ["platform", "topic"],
        buckets=(0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0),
    )
    
    webhook_duplicate_total = Counter(
        "webhook_duplicate_total", "Total number of duplicate webhooks", ["platform"]
    )
    
    # Event publishing metrics
    events_published_total = Counter(
        "webhook_events_published_total",
        "Total number of events published from webhooks",
        ["event_type", "platform"],
    )
    
    event_publishing_errors_total = Counter(
        "webhook_event_publishing_errors_total",
        "Total number of event publishing errors",
        ["event_type", "platform", "error_type"],
    )
    
    # Queue metrics
    webhook_queue_size = Gauge(
        "webhook_queue_size", "Current size of webhook processing queue", ["platform"]
    )
    
    webhook_retry_queue_size = Gauge(
        "webhook_retry_queue_size", "Current size of webhook retry queue"
    )
    
    # Platform-specific metrics
    shopify_webhooks_total = Counter(
        "shopify_webhooks_total",
        "Total Shopify webhooks by topic",
        ["topic", "merchant_id"],
    )
    
    # Helper functions
    
    
    def record_webhook_received(platform: str, topic: str, status: str = "success"):
        """Record webhook received"""
        webhooks_received_total.labels(platform=platform, topic=topic, status=status).inc()
    
    
    def record_webhook_validation_failure(platform: str, reason: str):
        """Record webhook validation failure"""
        webhook_validation_failures_total.labels(platform=platform, reason=reason).inc()
    
    
    def observe_webhook_processing_time(platform: str, topic: str, duration: float):
        """Observe webhook processing duration"""
        webhook_processing_duration_seconds.labels(platform=platform, topic=topic).observe(
            duration
        )
    
    
    def record_duplicate_webhook(platform: str):
        """Record duplicate webhook"""
        webhook_duplicate_total.labels(platform=platform).inc()
    
    
    def record_event_published(event_type: str, platform: str):
        """Record event published"""
        events_published_total.labels(event_type=event_type, platform=platform).inc()
    
    
    def record_event_publishing_error(event_type: str, platform: str, error_type: str):
        """Record event publishing error"""
        event_publishing_errors_total.labels(
            event_type=event_type, platform=platform, error_type=error_type
        ).inc()
    
    
    # Initialize service info
    def init_metrics(service_name: str, version: str, environment: str):
        """Initialize service metrics"""
        service_info.info(
            {"service": service_name, "version": version, "environment": environment}
        )
    ```
    
tests/
└── __init__.py
.env.example
.gitignore
.python-version
docker_compose.yml

```yml
version: '3.8'

services:
  webhook-service:
    build:
      context: ../..
      dockerfile: services/webhook-service/Dockerfile
    container_name: webhook-service
    ports:
      - "8012:8012"
    environment:
      - SERVICE_NAME=webhook-service
      - SERVICE_PORT=8012
      - DATABASE_URL=postgresql+asyncpg://webhook:webhook@postgres:5432/webhook_db
      - REDIS_URL=redis://redis:6379
      - NATS_URL=nats://nats:4222
      - SHOPIFY_WEBHOOK_SECRET=${SHOPIFY_WEBHOOK_SECRET}
      - STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
      - LOG_LEVEL=INFO
    depends_on:
      - postgres
      - redis
      - nats
    networks:
      - glam-network
    restart: unless-stopped

networks:
  glam-network:
    external: true
```

Dockerfile

```
# ──────────────────────────────────────────────────────────────
# 📦  Stage 1 ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim as builder

# System dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
ENV POETRY_VERSION=1.6.1
RUN pip install poetry==$POETRY_VERSION

# Copy shared package first
WORKDIR /shared
COPY shared/pyproject.toml shared/poetry.lock* ./
COPY shared/ ./

# Install shared dependencies
RUN poetry config virtualenvs.create false && \
    poetry install --no-interaction --no-ansi --no-root

# Copy service source
COPY services/webhook-service /app

# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app       /app
COPY --from=builder /shared    /shared

ENV PYTHONPATH="/shared:/app"
WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8012

# Run with optimal settings
CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8012", "--workers", "4"]
```

poetry.lock
pyproject.toml

```toml
[tool.poetry]
name = "webhook-service"
version = "2.0.0"
description = "Unified webhook ingestion service for GlamYouUp platform"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
sqlalchemy = "^2.0.23"
asyncpg = "^0.29.0"
alembic = "^1.13.0"
nats-py = "^2.6.0"
redis = "^5.0.1"
httpx = "^0.25.2"
python-jose = {extras = ["cryptography"], version = "^3.3.0"}
python-dotenv = "^1.0.0"
python-multipart = "^0.0.6"
shared = { path = "../../shared", develop = true }
prometheus-client = "^0.22.1"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
flake8 = "^6.1.0"
mypy = "^1.7.1"
faker = "^20.1.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 88
target-version = ['py311']

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
asyncio_mode = "auto"
```

README.md

```md
# Webhook Service

Unified webhook ingestion service for the GlamYouUp platform.

## Features

- **Multi-source Support**: Currently supports Shopify and Stripe webhooks
- **HMAC Signature Validation**: Secure webhook authentication
- **Idempotency**: Redis-based deduplication with configurable TTL
- **Event Mapping**: Maps external webhooks to internal domain events
- **Circuit Breakers**: Protects downstream services from cascading failures
- **Dead Letter Queue**: Failed webhooks can be replayed
- **Observability**: Structured logging, Prometheus metrics, health checks
- **Extensible**: Easy to add new webhook sources

## Architecture
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│ External        │────▶│ Webhook Service  │────▶│ Event Bus       │
│ Platforms       │     │                  │     │ (NATS)          │
└─────────────────┘     └──────────────────┘     └─────────────────┘
│
▼
┌──────────────────┐
│ PostgreSQL       │
│ Redis            │
└──────────────────┘


### Service Type
- **Type**: API Service
- **Port**: 8012
- **Database**: PostgreSQL (dedicated schema)
- **Cache**: Redis for deduplication and circuit breakers
- **Messaging**: NATS JetStream for event publishing

### Key Components

1. **Webhook Handlers**
   - Shopify: Full support for products, orders, inventory, app lifecycle
   - Stripe: Payment and subscription events
   - Extensible base handler for new sources

2. **Authentication**
   - HMAC-SHA256 validation for Shopify
   - Stripe signature validation
   - Per-source secret management

3. **Deduplication**
   - Redis-based with configurable TTL (default 24h)
   - Idempotency keys based on webhook ID or content hash

4. **Circuit Breakers**
   - Per-subject breakers with sliding window
   - Automatic recovery with half-open state
   - Configurable thresholds and timeouts

5. **Event Publishing**
   - Maps webhooks to domain events
   - Publishes to appropriate NATS streams
   - Maintains correlation IDs

## API Endpoints

### Webhooks
- `POST /api/v1/webhooks/shopify/{topic}` - Shopify webhook (topic in path)
- `POST /api/v1/webhooks/shopify` - Shopify webhook (topic in header)
- `POST /api/v1/webhooks/stripe` - Stripe webhook
- `POST /api/v1/webhooks/{source}` - Generic webhook (future)

### Health
- `GET /api/v1/health` - Comprehensive health check
- `GET /api/v1/health/ready` - Kubernetes readiness
- `GET /api/v1/health/live` - Kubernetes liveness

## Environment Variables

See `.env.example` for all configuration options. Key variables:

- `SHOPIFY_WEBHOOK_SECRET` - Required for Shopify webhooks
- `STRIPE_WEBHOOK_SECRET` - Required for Stripe webhooks
- `REDIS_URL` - Redis connection for deduplication
- `DEDUP_TTL_HOURS` - Deduplication window (default 24)
- `MAX_PAYLOAD_SIZE_MB` - Maximum webhook size (default 10)

## Development

```bash
# Install dependencies
poetry install

# Copy environment variables
cp .env.example .env
# Edit .env with your configuration

# Run database migrations
alembic upgrade head

# Start service
uvicorn src.main:app --reload --port 8012

# Run tests
pytest

# Test webhook
python scripts/test_webhook.py



Key Components Created:
1. Core Structure

Complete directory structure matching the notification service pattern
Service lifecycle management with proper startup/shutdown
Event-driven architecture with NATS JetStream
Repository pattern using SQLAlchemy's latest mapped API

2. Models & Database

WebhookEntry - Stores all received webhooks for audit/replay
PlatformConfiguration - Manages webhook secrets per source
Uses shared mixins (TimestampedMixin, ShopMixin)
Alembic migrations setup

3. Services

WebhookService - Main orchestration service
AuthService - HMAC validation for Shopify/Stripe
DeduplicationService - Redis-based idempotency
CircuitBreakerService - Downstream protection

4. Event Handling

WebhookEventPublisher - Publishes webhook events
Maps external webhooks to domain events
Maintains event context and correlation IDs

5. Webhook Handlers

ShopifyWebhookHandler - Handles all Shopify topics
StripeWebhookHandler - Handles Stripe events
Extensible base handler for new sources

6. API Endpoints

/api/v1/webhooks/shopify/{topic} - Shopify webhooks
/api/v1/webhooks/stripe - Stripe webhooks
Comprehensive health checks

7. Production Features

Docker multi-stage build
Environment-based configuration
Structured logging with correlation IDs
Prometheus metrics
Circuit breakers with sliding windows
Dead letter queue support

Key Design Patterns Followed:

Dependency Injection - FastAPI dependencies matching notification service
Repository Pattern - Generic repository with specific implementations
Event Publishing - Domain event publisher with typed payloads
Service Lifecycle - Centralized startup/shutdown management
Error Handling - Shared error classes from the shared package

The service is production-ready and maintains complete consistency with the existing platform architecture. It can handle high-throughput webhook processing with proper deduplication, circuit breaking, and observability.
```


================================================================================
Output includes file contents
================================================================================