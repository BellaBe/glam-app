================================================================================
Directory Structure: /home/bellabe/glam-app/services/webhook-service
================================================================================

webhook-service/
logs/
prisma/
├── migrations/
│   ├── 20250814041638_desktop_pgt_1_cqb/
│   │   └── migration.sql
│   │
│   │       ```sql
│   │       -- CreateTable
│   │       CREATE TABLE "webhook_entries" (
│   │           "id" UUID NOT NULL,
│   │           "platform" VARCHAR(50) NOT NULL,
│   │           "webhook_id" VARCHAR(255) NOT NULL,
│   │           "topic" VARCHAR(255) NOT NULL,
│   │           "domain" VARCHAR(255) NOT NULL,
│   │           "payload" JSONB NOT NULL,
│   │           "status" VARCHAR(20) NOT NULL DEFAULT 'RECEIVED',
│   │           "processing_attempts" INTEGER NOT NULL DEFAULT 0,
│   │           "error_message" TEXT,
│   │           "processed_at" TIMESTAMPTZ(3),
│   │           "created_at" TIMESTAMPTZ(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
│   │           "updated_at" TIMESTAMPTZ(3) NOT NULL,
│   │
│   │           CONSTRAINT "webhook_entries_pkey" PRIMARY KEY ("id")
│   │       );
│   │
│   │       -- CreateIndex
│   │       CREATE UNIQUE INDEX "webhook_entries_webhook_id_key" ON "webhook_entries"("webhook_id");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "webhook_entries_domain_topic_idx" ON "webhook_entries"("domain", "topic");
│   │
│   │       -- CreateIndex
│   │       CREATE INDEX "webhook_entries_status_processing_attempts_idx" ON "webhook_entries"("status", "processing_attempts");
│   │       ```
│   │
│   └── migration_lock.toml
│
│       ```toml
│       # Please do not edit this file manually
│       # It should be added in your version-control system (i.e. Git)
│       provider = "postgresql"
│       ```
│
└── schema.prisma
scripts/
├── __init__.py
├── test_webhook.py
│
│   ```py
│   # ruff: noqa: T201
│   """Manual test script for webhook service"""
│
│   import asyncio
│   import base64
│   import hashlib
│   import hmac
│   import json
│   from datetime import datetime
│
│   import httpx
│   import uuid7
│
│
│   def compute_hmac(body: bytes, secret: str) -> str:
│       """Compute HMAC-SHA256 for webhook body"""
│       hash_obj = hmac.new(secret.encode("utf-8"), body, hashlib.sha256)
│       return base64.b64encode(hash_obj.digest()).decode("utf-8")
│
│
│   async def test_order_webhook():
│       """Test order created webhook"""
│       # Webhook payload
│       payload = {
│           "id": 5678901234,
│           "email": "customer@example.com",
│           "created_at": datetime.utcnow().isoformat() + "Z",
│           "updated_at": datetime.utcnow().isoformat() + "Z",
│           "total_price": "150.00",
│           "currency": "USD",
│           "financial_status": "paid",
│           "line_items": [
│               {"id": 111, "title": "Test Product 1", "quantity": 2, "price": "50.00"},
│               {"id": 222, "title": "Test Product 2", "quantity": 1, "price": "50.00"},
│           ],
│           "myshopify_domain": "test-shop.myshopify.com",
│       }
│
│       body = json.dumps(payload).encode()
│
│       # Headers
│       headers = {
│           "Content-Type": "application/json",
│           "X-Shopify-Topic": "orders/create",
│           "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
│           "X-Shopify-Webhook-Id": str(uuid7.uuid7()),
│           "X-Shopify-Api-Version": "2024-01",
│           "X-Shopify-Hmac-Sha256": compute_hmac(body, "your-shopify-webhook-secret"),
│       }
│
│       async with httpx.AsyncClient() as client:
│           response = await client.post(
│               "http://localhost:8112/api/v1/shopify/webhooks/orders/create", content=body, headers=headers
│           )
│
│           print(f"Status: {response.status_code}")
│           print(f"Response: {response.json()}")
│           print(f"Headers: {dict(response.headers)}")
│
│
│   async def test_app_uninstalled_webhook():
│       """Test app uninstalled webhook"""
│       payload = {
│           "id": 1234567890,
│           "name": "Test Shop",
│           "email": "shop@example.com",
│           "domain": "test-shop.myshopify.com",
│           "created_at": "2024-01-01T00:00:00Z",
│           "myshopify_domain": "test-shop.myshopify.com",
│       }
│
│       body = json.dumps(payload).encode()
│
│       headers = {
│           "Content-Type": "application/json",
│           "X-Shopify-Topic": "app/uninstalled",
│           "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
│           "X-Shopify-Webhook-Id": str(uuid7.uuid7()),
│           "X-Shopify-Api-Version": "2024-01",
│           "X-Shopify-Hmac-Sha256": compute_hmac(body, "your-shopify-webhook-secret"),
│       }
│
│       async with httpx.AsyncClient() as client:
│           response = await client.post(
│               "http://localhost:8112/api/v1/shopify/webhooks/app/uninstalled", content=body, headers=headers
│           )
│
│           print(f"Status: {response.status_code}")
│           print(f"Response: {response.json()}")
│
│
│   async def test_duplicate_webhook():
│       """Test duplicate webhook handling"""
│       webhook_id = str(uuid7.uuid7())
│       payload = {"test": "duplicate"}
│       body = json.dumps(payload).encode()
│
│       headers = {
│           "Content-Type": "application/json",
│           "X-Shopify-Topic": "orders/create",
│           "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
│           "X-Shopify-Webhook-Id": webhook_id,  # Same ID for both requests
│           "X-Shopify-Api-Version": "2024-01",
│           "X-Shopify-Hmac-Sha256": compute_hmac(body, "your-shopify-webhook-secret"),
│       }
│
│       async with httpx.AsyncClient() as client:
│           # First request
│           response1 = await client.post(
│               "http://localhost:8112/api/v1/shopify/webhooks/test", content=body, headers=headers
│           )
│           print(f"First request - Status: {response1.status_code}, Response: {response1.json()}")
│
│           # Second request with same webhook ID
│           response2 = await client.post(
│               "http://localhost:8112/api/v1/shopify/webhooks/test", content=body, headers=headers
│           )
│           print(f"Second request - Status: {response2.status_code}, Response: {response2.json()}")
│
│
│   async def test_health_check():
│       """Test health endpoints"""
│       async with httpx.AsyncClient() as client:
│           # Basic health
│           response = await client.get("http://localhost:8112/api/v1/health")
│           print(f"Basic health: {response.json()}")
│
│           # Detailed health
│           response = await client.get("http://localhost:8112/api/v1/health/detailed")
│           print(f"Detailed health: {json.dumps(response.json(), indent=2)}")
│
│
│   async def main():
│       print("Testing Webhook Service...")
│       print("\n1. Testing Order Created Webhook:")
│       await test_order_webhook()
│
│       print("\n2. Testing App Uninstalled Webhook:")
│       await test_app_uninstalled_webhook()
│
│       print("\n3. Testing Duplicate Webhook:")
│       await test_duplicate_webhook()
│
│       print("\n4. Testing Health Checks:")
│       await test_health_check()
│
│
│   if __name__ == "__main__":
│       asyncio.run(main())
│   ```
│
└── validate_event_context.py

    ```py
    # ruff: noqa: T201
    """Validate proper EventContext usage across services."""

    import ast
    import sys
    from pathlib import Path


    def check_event_context_usage():
        """Ensure EventContext.create() calls include proper correlation handling."""
        errors = []

        for py_file in Path("src").rglob("*.py"):
            if py_file.name.startswith("__"):
                continue

            with open(py_file) as f:
                try:
                    tree = ast.parse(f.read())
                    for node in ast.walk(tree):
                        if (
                            isinstance(node, ast.Call)
                            and hasattr(node.func, "attr")
                            and node.func.attr == "create"
                            and hasattr(node.func, "value")
                            and hasattr(node.func.value, "id")
                            and node.func.value.id == "EventContext"
                        ):
                            # Check if correlation_id is properly handled
                            keywords = {kw.arg for kw in node.keywords if kw.arg}
                            if "correlation_id" not in keywords:
                                errors.append(
                                    f"{py_file}:{node.lineno} - EventContext.create() missing correlation_id parameter"
                                )
                except SyntaxError:
                    continue

        if errors:
            for error in errors:
                print(error, file=sys.stderr)
            print("\nTip: Add correlation_id parameter to EventContext.create() calls", file=sys.stderr)
            print("Example: EventContext.create(..., correlation_id=get_correlation_context())", file=sys.stderr)
            sys.exit(1)

        print("✅ All EventContext.create() calls properly handle correlation_id")


    def check_uuid_usage():
        """Ensure uuid7() is used instead of uuid4() for event IDs."""
        errors = []

        for py_file in Path("src").rglob("*.py"):
            if py_file.name.startswith("__"):
                continue

            with open(py_file) as f:
                content = f.read()
                lines = content.split("\n")
                for i, line in enumerate(lines, 1):
                    if "uuid4()" in line and "import" not in line:
                        errors.append(f"{py_file}:{i} - Use uuid7() instead of uuid4()")

        if errors:
            for error in errors:
                print(error, file=sys.stderr)
            print("\nTip: Use uuid7() for monotonic ordering in events", file=sys.stderr)
            sys.exit(1)

        print("✅ All UUID usage follows monotonic ordering")


    if __name__ == "__main__":
        check_event_context_usage()
        check_uuid_usage()
    ```

src/
├── api/
│   ├── v1/
│   │   ├── __init__.py
│   │   │
│   │   │   ```py
│   │   │   # services/webhook-service/src/api/v1/__init__.py
│   │   │   from fastapi import APIRouter
│   │   │
│   │   │   from .webhooks import webhooks_router
│   │   │
│   │   │   v1_router = APIRouter(prefix="/v1")
│   │   │
│   │   │   # Include v1 API routes
│   │   │   v1_router.include_router(webhooks_router, tags=["webhooks"])
│   │   │   ```
│   │   │
│   │   └── webhooks.py
│   │
│   │       ```py
│   │       # services/webhook-service/src/api/v1/webhooks.py
│   │       import json
│   │
│   │       from fastapi import APIRouter
│   │
│   │       from shared.api.dependencies import ClientAuthDep, LoggerDep, PlatformContextDep, RequestContextDep, WebhookHeadersDep
│   │       from shared.api.validation import validate_shop_context
│   │
│   │       from ...dependencies import WebhookServiceDep
│   │       from ...exceptions import InvalidContentTypeError, MalformedPayloadError, PayloadTooLargeError
│   │       from ...models import WebhookPlatform, parse_topic
│   │       from ...schemas.webhooks import WebhookResponse
│   │
│   │       webhooks_router = APIRouter(prefix="/webhooks")
│   │
│   │
│   │       @webhooks_router.post("/shopify", response_model=WebhookResponse)
│   │       async def receive_shopify_webhook(
│   │           body: bytes,
│   │           svc: WebhookServiceDep,
│   │           ctx: RequestContextDep,
│   │           client_auth: ClientAuthDep,
│   │           platform_ctx: PlatformContextDep,
│   │           webhook: WebhookHeadersDep,
│   │           logger: LoggerDep,
│   │       ) -> WebhookResponse:
│   │           """Receive webhook from Shopify BFF."""
│   │
│   │           # Validate content type
│   │           ct = (ctx.content_type or "").lower()
│   │           if "application/json" not in ct:
│   │               raise InvalidContentTypeError(ct)
│   │
│   │           # Check payload size
│   │           if len(body) > 2097152:  # 2MB limit
│   │               raise PayloadTooLargeError(len(body), 2097152)
│   │
│   │           # Parse the body
│   │           try:
│   │               payload = json.loads(body)
│   │           except Exception as e:
│   │               raise MalformedPayloadError() from e
│   │
│   │           # ✨ Single validation call handles everything
│   │           validate_shop_context(
│   │               client_auth=client_auth,
│   │               platform_ctx=platform_ctx,
│   │               logger=logger,
│   │               expected_platform="shopify",  # This is a Shopify-only endpoint
│   │               expected_scope="bff:call",  # Required scope
│   │               webhook_payload=payload,  # Validate payload domain
│   │           )
│   │
│   │           # Set logger context
│   │           logger.set_request_context(
│   │               platform=platform_ctx.platform,
│   │               domain=platform_ctx.domain,
│   │               webhook_topic=webhook.topic,
│   │               webhook_id=webhook.webhook_id,
│   │           )
│   │
│   │           logger.info("Received Shopify webhook", extra={"correlation_id": ctx.correlation_id, "payload_size": len(body)})
│   │
│   │           # Process the webhook
│   │           entry_id = await svc.receive_webhook(
│   │               platform=WebhookPlatform.SHOPIFY,
│   │               topic=parse_topic(webhook.topic),
│   │               domain=platform_ctx.domain,
│   │               webhook_id=webhook.webhook_id,
│   │               payload=payload,
│   │               correlation_id=ctx.correlation_id,
│   │           )
│   │
│   │           logger.info("Webhook processed successfully")
│   │
│   │           return WebhookResponse(success=True, webhook_id=entry_id)
│   │       ```
│   │
│   └── __init__.py
│
│       ```py
│       # services/webhook-service/src/api/__init__.py
│       from fastapi import APIRouter
│
│       from .v1 import v1_router
│
│       api_router = APIRouter(prefix="/api")
│
│       api_router.include_router(v1_router, tags=["v1"])
│       ```
│
├── events/
│   ├── __init__.py
│   │
│   │   ```py
│   │   """Event publishers and listeners"""
│   │
│   │   from .publishers import WebhookEventPublisher
│   │
│   │   __all__ = ["WebhookEventPublisher", "WebhookProcessListener"]
│   │   ```
│   │
│   └── publishers.py
│
│       ```py
│       from shared.messaging.publisher import Publisher
│
│
│       class WebhookEventPublisher(Publisher):
│           """Publisher for webhook domain events"""
│
│           @property
│           def service_name(self) -> str:
│               return "webhook-service"
│
│           async def app_uninstalled(self, domain: str, webhook_id: str, correlation_id: str) -> str:
│               """Publish app uninstalled event"""
│               return await self.publish_event(
│                   subject="evt.webhook.app.uninstalled",
│                   data={"domain": domain, "webhook_id": webhook_id},
│                   correlation_id=correlation_id,
│               )
│
│           async def app_subscription_updated(
│               self, domain: str, subscription_id: str, status: str, webhook_id: str, correlation_id: str
│           ) -> str:
│               """Publish app subscription updated event"""
│               return await self.publish_event(
│                   subject="evt.webhook.app.subscription_updated",
│                   data={
│                       "domain": domain,
│                       "subscription_id": subscription_id,
│                       "status": status,
│                       "webhook_id": webhook_id,
│                   },
│                   correlation_id=correlation_id,
│               )
│
│           async def app_purchase_updated(
│               self, domain: str, charge_id: str, status: str, test: bool, webhook_id: str, correlation_id: str
│           ) -> str:
│               """Publish app purchase updated event"""
│               return await self.publish_event(
│                   subject="evt.webhook.app.purchase_updated",
│                   data={
│                       "domain": domain,
│                       "charge_id": charge_id,
│                       "status": status,
│                       "test": test,
│                       "webhook_id": webhook_id,
│                   },
│                   correlation_id=correlation_id,
│               )
│
│           async def order_created(
│               self,
│               domain: str,
│               order_id: str,
│               total_price: str,
│               currency: str,
│               created_at: str,
│               line_items_count: int,
│               webhook_id: str,
│               correlation_id: str,
│           ) -> str:
│               """Publish order created event"""
│               return await self.publish_event(
│                   subject="evt.webhook.order.created",
│                   data={
│                       "domain": domain,
│                       "order_id": order_id,
│                       "total_price": total_price,
│                       "currency": currency,
│                       "created_at": created_at,
│                       "line_items_count": line_items_count,
│                       "webhook_id": webhook_id,
│                   },
│                   correlation_id=correlation_id,
│               )
│
│           async def catalog_product_event(
│               self,
│               event_type: str,  # created, updated, deleted
│               domain: str,
│               product_id: str,
│               updated_at: str | None,
│               webhook_id: str,
│               correlation_id: str,
│           ) -> str:
│               """Publish catalog product event"""
│               subject = f"evt.webhook.catalog.product_{event_type}"
│               data = {"domain": domain, "product_id": product_id, "webhook_id": webhook_id}
│               if updated_at and event_type == "updated":
│                   data["updated_at"] = updated_at
│
│               return await self.publish_event(subject=subject, data=data, correlation_id=correlation_id)
│
│           async def catalog_collection_event(
│               self,
│               event_type: str,  # created, updated, deleted
│               domain: str,
│               collection_id: str,
│               updated_at: str | None,
│               webhook_id: str,
│               correlation_id: str,
│           ) -> str:
│               """Publish catalog collection event"""
│               subject = f"evt.webhook.catalog.collection_{event_type}"
│               data = {"domain": domain, "collection_id": collection_id, "webhook_id": webhook_id}
│               if updated_at and event_type == "updated":
│                   data["updated_at"] = updated_at
│
│               return await self.publish_event(subject=subject, data=data, correlation_id=correlation_id)
│
│           async def inventory_updated(
│               self,
│               domain: str,
│               inventory_item_id: str,
│               location_id: str,
│               available: int,
│               webhook_id: str,
│               correlation_id: str,
│           ) -> str:
│               """Publish inventory updated event"""
│               return await self.publish_event(
│                   subject="evt.webhook.inventory.updated",
│                   data={
│                       "domain": domain,
│                       "inventory_item_id": inventory_item_id,
│                       "location_id": location_id,
│                       "available": available,
│                       "webhook_id": webhook_id,
│                   },
│                   correlation_id=correlation_id,
│               )
│
│           async def gdpr_data_request(
│               self, domain: str, customer_id: str, orders_requested: list[str], webhook_id: str, correlation_id: str
│           ) -> str:
│               """Publish GDPR data request event"""
│               return await self.publish_event(
│                   subject="evt.webhook.gdpr.data_request",
│                   data={
│                       "domain": domain,
│                       "customer_id": customer_id,
│                       "orders_requested": orders_requested,
│                       "webhook_id": webhook_id,
│                   },
│                   correlation_id=correlation_id,
│               )
│
│           async def gdpr_customer_redact(
│               self, domain: str, customer_id: str, orders_to_redact: list[str], webhook_id: str, correlation_id: str
│           ) -> str:
│               """Publish GDPR customer redact event"""
│               return await self.publish_event(
│                   subject="evt.webhook.gdpr.customer_redact",
│                   data={
│                       "domain": domain,
│                       "customer_id": customer_id,
│                       "orders_to_redact": orders_to_redact,
│                       "webhook_id": webhook_id,
│                   },
│                   correlation_id=correlation_id,
│               )
│
│           async def gdpr_shop_redact(self, domain: str, webhook_id: str, correlation_id: str) -> str:
│               """Publish GDPR shop redact event"""
│               return await self.publish_event(
│                   subject="evt.webhook.gdpr.shop_redact",
│                   data={"domain": domain, "webhook_id": webhook_id},
│                   correlation_id=correlation_id,
│               )
│       ```
│
├── models/
│   ├── __init__.py
│   │
│   │   ```py
│   │   """Domain models and enums"""
│   │
│   │   from .enums import ShopifyWebhookTopic, WebhookPlatform, WebhookStatus, parse_topic
│   │
│   │   __all__ = ["ShopifyWebhookTopic", "WebhookPlatform", "WebhookStatus", "parse_topic"]
│   │   ```
│   │
│   └── enums.py
│
│       ```py
│       from enum import Enum
│
│
│       class WebhookPlatform(str, Enum):
│           SHOPIFY = "shopify"
│
│
│       class WebhookStatus(str, Enum):
│           RECEIVED = "RECEIVED"
│           PROCESSING = "PROCESSING"
│           PROCESSED = "PROCESSED"
│           FAILED = "FAILED"
│
│
│       class ShopifyWebhookTopic(str, Enum):
│           """
│           Canonical Shopify topics. Enum values are the *raw* Shopify topic strings.
│           This lets us avoid a separate mapping.
│           """
│
│           APP_UNINSTALLED = "app/uninstalled"
│           APP_SUBSCRIPTIONS_UPDATE = "app_subscriptions/update"
│           APP_PURCHASES_ONE_TIME_UPDATE = "app_purchases_one_time/update"
│           ORDERS_CREATE = "orders/create"
│           PRODUCTS_CREATE = "products/create"
│           PRODUCTS_UPDATE = "products/update"
│           PRODUCTS_DELETE = "products/delete"
│           COLLECTIONS_CREATE = "collections/create"
│           COLLECTIONS_UPDATE = "collections/update"
│           COLLECTIONS_DELETE = "collections/delete"
│           INVENTORY_LEVELS_UPDATE = "inventory_levels/update"
│           CUSTOMERS_DATA_REQUEST = "customers/data_request"
│           CUSTOMERS_REDACT = "customers/redact"
│           SHOP_REDACT = "shop/redact"
│           UNKNOWN = "__unknown__"
│
│
│       def parse_topic(raw: str) -> ShopifyWebhookTopic:
│           """
│           Convert raw header string → Enum. Unknown → ShopifyWebhookTopic.UNKNOWN.
│           """
│           try:
│               return ShopifyWebhookTopic(raw)
│           except ValueError:
│               return ShopifyWebhookTopic.UNKNOWN
│       ```
│
├── repositories/
│   ├── __init__.py
│   │
│   │   ```py
│   │   """Data access layer"""
│   │
│   │   from .webhook_repository import WebhookRepository
│   │
│   │   __all__ = ["WebhookRepository"]
│   │   ```
│   │
│   └── webhook_repository.py
│
│       ```py
│       # services/webhook-service/src/repositories/webhook_repository.py
│       from typing import Any
│
│       from prisma import Prisma  # type: ignore[attr-defined]
│       from prisma.errors import UniqueViolationError
│
│       from ..models.enums import WebhookStatus
│
│
│       class WebhookRepository:
│           def __init__(self, prisma: Prisma):
│               self.prisma = prisma
│
│           async def create_or_get_existing(
│               self,
│               *,
│               platform: str,
│               webhook_id: str,
│               topic: str,
│               domain: str,
│               payload: dict,
│           ) -> tuple[Any, bool]:
│               """
│               Create webhook or return existing. Returns (webhook, is_new).
│               """
│               # Check if exists
│               existing = await self.prisma.webhookentry.find_unique(where={"webhook_id": webhook_id})
│
│               if existing:
│                   return existing, False
│
│               # Create new
│               try:
│                   webhook = await self.prisma.webhookentry.create(
│                       data={
│                           "platform": platform,
│                           "webhook_id": webhook_id,
│                           "topic": topic,
│                           "domain": domain.lower(),
│                           "payload": payload,
│                           "status": WebhookStatus.RECEIVED.value,
│                       }
│                   )
│                   return webhook, True
│               except UniqueViolationError:
│                   # Race condition - another request created it
│                   existing = await self.prisma.webhookentry.find_unique(where={"webhook_id": webhook_id})
│                   return existing, False
│
│           async def update_status(
│               self,
│               id: str,
│               status: WebhookStatus,
│               error_message: str | None = None,
│           ):
│               """Update webhook processing status"""
│               from datetime import datetime
│
│               update_data: dict[str, Any] = {"status": status.value}
│
│               if status == WebhookStatus.PROCESSED:
│                   update_data["processed_at"] = datetime.utcnow()
│
│               if error_message:
│                   update_data["error_message"] = error_message
│
│               return await self.prisma.webhookentry.update(where={"id": id}, data=update_data)
│
│           async def increment_attempts(self, id: str):
│               """Increment processing attempts counter"""
│               return await self.prisma.webhookentry.update(where={"id": id}, data={"processing_attempts": {"increment": 1}})
│       ```
│
├── schemas/
│   ├── __init__.py
│   │
│   │   ```py
│   │   from .webhooks import WebhookResponse
│   │
│   │   __all__ = ["WebhookResponse"]
│   │   ```
│   │
│   └── webhooks.py
│
│       ```py
│       from pydantic import BaseModel
│
│
│       class WebhookResponse(BaseModel):
│           success: bool
│           webhook_id: str
│       ```
│
├── services/
│   ├── __init__.py
│   │
│   │   ```py
│   │   """Business logic services"""
│   │
│   │   from .webhook_service import WebhookService
│   │
│   │   __all__ = ["WebhookService"]
│   │   ```
│   │
│   └── webhook_service.py
│
│       ```py
│       # services/webhook-service/src/services/webhook_service.py
│       from typing import Any
│
│       from shared.utils.logger import ServiceLogger
│
│       from ..config import ServiceConfig
│       from ..events.publishers import WebhookEventPublisher
│       from ..models import ShopifyWebhookTopic, WebhookPlatform
│       from ..repositories.webhook_repository import WebhookRepository
│
│
│       class WebhookService:
│           def __init__(
│               self,
│               config: ServiceConfig,
│               repository: WebhookRepository,
│               publisher: WebhookEventPublisher,
│               logger: ServiceLogger,
│           ):
│               self.config = config
│               self.repository = repository
│               self.publisher = publisher
│               self.logger = logger
│
│           async def receive_webhook(
│               self,
│               *,
│               platform: WebhookPlatform,
│               topic: ShopifyWebhookTopic,
│               domain: str,
│               webhook_id: str,
│               payload: dict,
│               correlation_id: str,
│           ) -> str:
│               """
│               Store webhook and publish domain events if new.
│               Returns the webhook entry ID.
│               """
│
│               if topic is ShopifyWebhookTopic.UNKNOWN:
│                   self.logger.warning(
│                       "Received webhook with unknown topic",
│                       extra={
│                           "topic_enum": topic.name,
│                           "topic": topic.value,
│                           "domain": domain,
│                           "webhook_id": webhook_id,
│                           "correlation_id": correlation_id,
│                       },
│                   )
│
│               # Store the webhook
│               entry, is_new = await self.repository.create_or_get_existing(
│                   platform=platform.value,
│                   webhook_id=webhook_id,
│                   topic=topic.value,
│                   domain=domain,
│                   payload=payload,
│               )
│
│               if not is_new:
│                   # Duplicate webhook - already processed
│                   self.logger.info(
│                       "Duplicate webhook received",
│                       extra={
│                           "topic_enum": topic.name,
│                           "topic": topic.value,
│                           "domain": domain,
│                           "webhook_id": webhook_id,
│                           "correlation_id": correlation_id,
│                           "entry_id": entry.id,
│                       },
│                   )
│                   return entry.id
│
│               await self._publish_domain_event(
│                   topic=topic,
│                   domain=domain,
│                   webhook_id=webhook_id,
│                   payload=payload,
│                   correlation_id=correlation_id,
│               )
│
│               self.logger.info(
│                   "New webhook stored & events published",
│                   extra={
│                       "topic": topic,
│                       "topic_enum": topic.value,
│                       "domain": domain,
│                       "webhook_id": webhook_id,
│                       "correlation_id": correlation_id,
│                       "entry_id": entry.id,
│                   },
│               )
│
│               return entry.id
│
│           async def _publish_domain_event(
│               self,
│               topic: ShopifyWebhookTopic,
│               domain: str,
│               webhook_id: str,
│               payload: dict[Any, Any],
│               correlation_id: str,
│           ) -> None:
│               """Publish appropriate domain event based on webhook topic"""
│
│               # Map webhook topics to domain events
│               if topic is ShopifyWebhookTopic.APP_UNINSTALLED:
│                   await self.publisher.app_uninstalled(
│                       domain=domain,
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.ORDERS_CREATE:
│                   await self.publisher.order_created(
│                       domain=domain,
│                       order_id=str(payload.get("id", "")),
│                       total_price=payload.get("total_price", "0.00"),
│                       currency=payload.get("currency", "USD"),
│                       created_at=payload.get("created_at", ""),
│                       line_items_count=len(payload.get("line_items", [])),
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.APP_SUBSCRIPTIONS_UPDATE:
│                   subscription = payload.get("app_subscription", {})
│                   await self.publisher.app_subscription_updated(
│                       domain=domain,
│                       subscription_id=str(subscription.get("id", "")),
│                       status=subscription.get("status", ""),
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.APP_PURCHASES_ONE_TIME_UPDATE:
│                   purchase = payload.get("app_purchase_one_time", {})
│                   await self.publisher.app_purchase_updated(
│                       domain=domain,
│                       charge_id=str(purchase.get("id", "")),
│                       status=purchase.get("status", ""),
│                       test=purchase.get("test", False),
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic in (
│                   ShopifyWebhookTopic.PRODUCTS_CREATE,
│                   ShopifyWebhookTopic.PRODUCTS_UPDATE,
│                   ShopifyWebhookTopic.PRODUCTS_DELETE,
│               ):
│                   action_map = {
│                       ShopifyWebhookTopic.PRODUCTS_CREATE: "created",
│                       ShopifyWebhookTopic.PRODUCTS_UPDATE: "updated",
│                       ShopifyWebhookTopic.PRODUCTS_DELETE: "deleted",
│                   }
│                   event_type = action_map[topic]
│                   await self.publisher.catalog_product_event(
│                       event_type=event_type,
│                       domain=domain,
│                       product_id=str(payload.get("id", "")),
│                       updated_at=payload.get("updated_at") if event_type == "updated" else None,
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic in (
│                   ShopifyWebhookTopic.COLLECTIONS_CREATE,
│                   ShopifyWebhookTopic.COLLECTIONS_UPDATE,
│                   ShopifyWebhookTopic.COLLECTIONS_DELETE,
│               ):
│                   action_map = {
│                       ShopifyWebhookTopic.COLLECTIONS_CREATE: "created",
│                       ShopifyWebhookTopic.COLLECTIONS_UPDATE: "updated",
│                       ShopifyWebhookTopic.COLLECTIONS_DELETE: "deleted",
│                   }
│                   event_type = action_map[topic]
│                   await self.publisher.catalog_collection_event(
│                       event_type=event_type,
│                       domain=domain,
│                       collection_id=str(payload.get("id", "")),
│                       updated_at=payload.get("updated_at") if event_type == "updated" else None,
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.INVENTORY_LEVELS_UPDATE:
│                   await self.publisher.inventory_updated(
│                       domain=domain,
│                       inventory_item_id=str(payload.get("inventory_item_id", "")),
│                       location_id=str(payload.get("location_id", "")),
│                       available=payload.get("available", 0),
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.CUSTOMERS_DATA_REQUEST:
│                   customer = payload.get("customer", {})
│                   await self.publisher.gdpr_data_request(
│                       domain=domain,
│                       customer_id=str(customer.get("id", "")),
│                       orders_requested=payload.get("orders_requested", []),
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.CUSTOMERS_REDACT:
│                   customer = payload.get("customer", {})
│                   await self.publisher.gdpr_customer_redact(
│                       domain=domain,
│                       customer_id=str(customer.get("id", "")),
│                       orders_to_redact=payload.get("orders_to_redact", []),
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               elif topic is ShopifyWebhookTopic.SHOP_REDACT:
│                   await self.publisher.gdpr_shop_redact(
│                       domain=domain,
│                       webhook_id=webhook_id,
│                       correlation_id=correlation_id,
│                   )
│
│               else:
│                   self.logger.warning(
│                       f"No domain event mapping for topic: {topic}",
│                       extra={
│                           "topic": topic.value,
│                           "domain": domain,
│                           "correlation_id": correlation_id,
│                       },
│                   )
│       ```
│
├── __init__.py
│
│   ```py
│   """Webhook Service - Receives and processes webhooks from external platforms"""
│
│   __version__ = "1.0.0"
│   ```
│
├── config.py
│
│   ```py
│   # services/webhook-service/src/config.py
│   import os
│   from functools import lru_cache
│
│   from pydantic import BaseModel, ConfigDict, Field, model_validator
│
│   from shared.utils import ConfigurationError, load_root_env
│
│
│   class ServiceConfig(BaseModel):
│       """Webhook service configuration"""
│
│       model_config = ConfigDict(
│           extra="ignore",
│           populate_by_name=True,
│       )
│
│       service_name: str = "webhook-service"
│       service_version: str = "1.0.0"
│       service_description: str = "Webhook management service"
│       debug: bool = True
│
│       environment: str = Field(..., alias="APP_ENV")
│
│       api_host: str = "0.0.0.0"
│       api_external_port: int = Field(..., alias="WEBHOOK_API_EXTERNAL_PORT")
│
│       database_enabled: int = Field(..., alias="WEBHOOK_DB_ENABLED")
│       database_url: str = Field(..., alias="DATABASE_URL")
│
│       logging_level: str = "INFO"
│       logging_format: str = "json"
│       logging_file_path: str = ""
│
│       body_limit_bytes: int = 2097152  # 2MB default limit
│       idempotency_ttl_seconds: int = 259200  # 72 hours default
│       max_retries: int = 10
│       retry_delay_seconds: int = 60  # Default since missing
│
│       client_jwt_secret: str = Field(..., alias="CLIENT_JWT_SECRET")
│
│       @property
│       def nats_url(self) -> str:
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "nats://nats:4222"
│           return "nats://localhost:4222"
│
│       @property
│       def redis_url(self) -> str:
│           in_container = os.path.exists("/.dockerenv")
│           if in_container or self.environment in ["development", "production"]:
│               return "redis://redis:6379"
│           return "redis://localhost:6379"
│
│       @property
│       def api_port(self) -> int:
│           in_container = os.path.exists("/.dockerenv")
│           return 8000 if in_container else self.api_external_port
│
│       @model_validator(mode="after")
│       def _require_db_url_when_enabled(self):
│           if self.database_enabled and not self.database_url:
│               raise ValueError("database_enabled=true requires DATABASE_URL")
│           return self
│
│
│   @lru_cache
│   def get_service_config() -> ServiceConfig:
│       """Load config - fail if anything is missing"""
│       try:
│           load_root_env()
│           return ServiceConfig(**os.environ)  # type: ignore[arg-type]
│
│       except Exception as e:
│           raise ConfigurationError(
│               f"Failed to load service configuration: {e}", config_key="webhook-service", expected_value="valid config"
│           ) from e
│   ```
│
├── dependencies.py
│
│   ```py
│   from typing import Annotated
│
│   from fastapi import Depends, HTTPException, Request, status
│
│   from .config import ServiceConfig
│   from .lifecycle import ServiceLifecycle
│   from .services import WebhookService
│
│   __all__ = [
│       "ConfigDep",
│       "LifecycleDep",
│       "WebhookServiceDep",
│   ]
│
│
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       lc = getattr(request.app.state, "lifecycle", None)
│       if lc is None:
│           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Lifecycle not initialized")
│       return lc
│
│
│   def get_config(request: Request) -> ServiceConfig:
│       cfg = getattr(request.app.state, "config", None)
│       if cfg is None:
│           raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Config not initialized")
│       return cfg
│
│
│   # Type aliases
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[ServiceConfig, Depends(get_config)]
│
│
│   # Service dependencies
│   def get_webhook_service(lifecycle: LifecycleDep) -> WebhookService:
│       """Get webhook service"""
│       if not lifecycle.webhook_service:
│           raise HTTPException(500, "Webhook service not initialized")
│       return lifecycle.webhook_service
│
│
│   # Type aliases
│   WebhookServiceDep = Annotated[WebhookService, Depends(get_webhook_service)]
│   ```
│
├── exceptions.py
│
│   ```py
│   from shared.utils.exceptions import (
│       GlamBaseError,
│       UnauthorizedError,
│       ValidationError,
│   )
│
│
│   class WebhookError(GlamBaseError):
│       """Base class for webhook errors"""
│
│       pass
│
│
│   class InvalidContentTypeError(ValidationError):
│       """Invalid content type for webhook"""
│
│       def __init__(self, content_type: str):
│           super().__init__(message="Content-Type must be application/json", field="content-type", value=content_type)
│
│
│   class PayloadTooLargeError(ValidationError):
│       """Webhook payload exceeds size limit"""
│
│       def __init__(self, size: int, limit: int):
│           super().__init__(message=f"Request payload exceeds {limit} byte limit", field="payload", value=f"{size} bytes")
│
│
│   class InvalidSignatureError(UnauthorizedError):
│       """Invalid HMAC signature"""
│
│       def __init__(self):
│           super().__init__(message="Invalid HMAC signature", auth_type="hmac")
│
│
│   class MissingHeadersError(ValidationError):
│       """Required headers missing"""
│
│       def __init__(self, missing_headers: list):
│           super().__init__(
│               message=f"Required headers missing: {', '.join(missing_headers)}", field="headers", value=missing_headers
│           )
│
│
│   class MalformedPayloadError(ValidationError):
│       """Invalid JSON payload"""
│
│       def __init__(self):
│           super().__init__(message="Invalid JSON payload", field="payload")
│
│
│   class InvalidShopDomainError(ValidationError):
│       """Invalid shop domain format"""
│
│       def __init__(self, domain: str):
│           super().__init__(
│               message="Invalid shop domain - must end with .myshopify.com", field="domain", value=domain
│           )
│
│
│   class IPNotAllowedError(UnauthorizedError):
│       """IP not in allowlist"""
│
│       def __init__(self, ip: str):
│           super().__init__(message="IP not in allowlist", auth_type="ip_allowlist")
│
│
│   # services/webhook-service/src/exceptions.py
│   class DomainMismatchError(ValidationError):
│       """Shop domain mismatch"""
│
│       def __init__(self, header_domain: str, payload_domain: str | None = None, jwt_domain: str | None = None):
│           if jwt_domain:
│               message = f"Shop domain mismatch - JWT: {jwt_domain}, Header: {header_domain}"
│               value = f"jwt: {jwt_domain}, header: {header_domain}"
│           elif payload_domain:
│               message = f"Shop domain mismatch - Header: {header_domain}, Payload: {payload_domain}"
│               value = f"header: {header_domain}, payload: {payload_domain}"
│           else:
│               message = "Shop domain mismatch"
│               value = header_domain
│
│           super().__init__(message=message, field="domain", value=value)
│   ```
│
├── lifecycle.py
│
│   ```py
│   import asyncio
│
│   from prisma import Prisma  # type: ignore[attr-defined]
│
│   from shared.messaging.jetstream_client import JetStreamClient
│   from shared.utils.logger import ServiceLogger
│
│   from .config import ServiceConfig
│   from .events.publishers import WebhookEventPublisher
│   from .repositories.webhook_repository import WebhookRepository
│   from .services.webhook_service import WebhookService
│
│
│   class ServiceLifecycle:
│       """Manages service lifecycle and dependencies"""
│
│       def __init__(self, config: ServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│
│           # External connections
│           self.messaging_client: JetStreamClient | None = None
│           self.prisma: Prisma | None = None
│           self._db_connected: bool = False
│
│           # Publisher / listeners
│           self.event_publisher: WebhookEventPublisher | None = None
│           self._listeners: list = []
│
│           # Repositories / services
│           self.webhook_repo: WebhookRepository | None = None
│           self.webhook_service: WebhookService | None = None
│
│           # Tasks
│           self._tasks: list[asyncio.Task] = []
│           self._shutdown_event = asyncio.Event()
│
│       async def startup(self) -> None:
│           try:
│               self.logger.info("Starting service components...")
│
│               await self._init_messaging()
│               await self._init_database()
│               self._init_repositories()
│               self._init_local_services()
│               self.logger.info("%s started successfully", self.config.service_name)
│           except Exception:
│               self.logger.critical("Service failed to start", exc_info=True)
│               await self.shutdown()
│               raise
│
│       async def shutdown(self) -> None:
│           """Graceful shutdown of all components"""
│           self.logger.info("Shutting down %s", self.config.service_name)
│
│           # Cancel tasks
│           for t in self._tasks:
│               t.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│
│           # Stop listeners
│           for lst in self._listeners:
│               try:
│                   await lst.stop()
│               except Exception:
│                   self.logger.critical("Listener stop failed", exc_info=True)
│
│           # Close messaging
│           if self.messaging_client:
│               try:
│                   await self.messaging_client.close()
│               except Exception:
│                   self.logger.critical("Messaging client close failed", exc_info=True)
│
│           # Disconnect database
│           if self.prisma and self._db_connected:
│               try:
│                   await self.prisma.disconnect()
│               except Exception:
│                   self.logger.critical("Prisma disconnect failed", exc_info=True)
│
│           self.logger.info("%s shutdown complete", self.config.service_name)
│
│       async def _init_messaging(self) -> None:
│           self.messaging_client = JetStreamClient(self.logger)
│           await self.messaging_client.connect([self.config.nats_url])
│           await self.messaging_client.ensure_stream("GLAM_EVENTS", ["evt.>", "cmd.>"])
│
│           # Initialize publisher
│           self.event_publisher = WebhookEventPublisher(
│               jetstream_client=self.messaging_client,
│               logger=self.logger,
│           )
│
│           self.logger.info("Messaging client and publisher initialized")
│
│       async def _init_database(self) -> None:
│           """Initialize Prisma client if database is enabled."""
│           if not self.config.database_enabled:
│               self.logger.info("Database disabled; skipping Prisma initialization")
│               return
│
│           self.prisma = Prisma()
│           if not self.prisma:
│               raise RuntimeError("Prisma client not initialized")
│
│           try:
│               await self.prisma.connect()
│               self._db_connected = True
│               self.logger.info("Prisma connected")
│           except Exception as e:
│               self.logger.exception("Prisma connect failed: %s", e, exc_info=True)
│               raise
│
│       def _init_repositories(self) -> None:
│           if self.config.database_enabled:
│               if not (self.prisma and self._db_connected):
│                   raise RuntimeError("Prisma client not initialized/connected")
│
│               self.webhook_repo = WebhookRepository(self.prisma)
│               self.logger.info("Webhook repository initialized")
│           else:
│               self.webhook_repo = None
│
│       def _init_local_services(self) -> None:
│           """Initialize local services with proper dependencies"""
│           if not self.webhook_repo:
│               raise RuntimeError("Webhook repository not initialized")
│           if not self.event_publisher:
│               raise RuntimeError("Event publisher not initialized")
│
│           # Initialize webhook service with all required dependencies
│           self.webhook_service = WebhookService(
│               config=self.config, repository=self.webhook_repo, publisher=self.event_publisher, logger=self.logger
│           )
│
│           self.logger.info("Services initialized")
│
│       # Convenience helpers
│       def add_task(self, coro) -> asyncio.Task:
│           t = asyncio.create_task(coro)
│           self._tasks.append(t)
│           return t
│
│       async def wait_for_shutdown(self) -> None:
│           await self._shutdown_event.wait()
│
│       def signal_shutdown(self) -> None:
│           self._shutdown_event.set()
│   ```
│
└── main.py

    ```py
    from contextlib import asynccontextmanager

    from fastapi import FastAPI

    from shared.api import setup_debug_handlers, setup_debug_middleware, setup_middleware
    from shared.api.health import create_health_router
    from shared.utils.logger import create_logger

    from .api import api_router
    from .config import get_service_config
    from .lifecycle import ServiceLifecycle

    # Global singletons
    config = get_service_config()
    logger = create_logger(config.service_name)
    lifecycle = ServiceLifecycle(config, logger)


    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """FastAPI lifespan adapter"""
        logger.info(
            f"Starting {config.service_name}",
            extra={
                "service_name": config.service_name,
                "version": config.service_version,
                "environment": config.environment,
                "api_host": config.api_host,
                "api_port": config.api_port,
            },
        )

        app.state.lifecycle = lifecycle
        app.state.config = config
        app.state.logger = logger

        try:
            await lifecycle.startup()
            yield
        finally:
            await lifecycle.shutdown()


    def create_application() -> FastAPI:
        """Create and configure the FastAPI application."""
        app = FastAPI(
            title=config.service_name,
            version=config.service_version,
            lifespan=lifespan,
            description=config.service_description,
            docs_url="/docs",
            redoc_url="/redoc",
            exception_handlers={},  # Use shared middleware for exception handling
        )

        if config.debug:
            logger.info("🚨 Debug mode enabled - adding debug handlers")
            setup_debug_handlers(app)
            setup_debug_middleware(app)

        # Setup middleware from shared package
        setup_middleware(
            app,
            service_name=config.service_name,
        )

        # Include routers
        app.include_router(api_router)
        app.include_router(create_health_router(config.service_name))

        return app


    app = create_application()


    if __name__ == "__main__":
        import uvicorn

        port = config.api_port
        uvicorn.run(
            "src.main:app",
            host=config.api_host,
            port=port,
            reload=config.debug,
        )
    ```

tests/
└── __init__.py

    ```py
    """Test package for webhook service"""
    ```

.python-version
Dockerfile

```
# services/webhook-service/Dockerfile
# ──────────────────────────────────────────────────────────────
# 📦  Stage 1 ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim AS builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry
RUN poetry config virtualenvs.create false

# ---- 1️⃣  Install shared package dependencies
COPY shared /shared
WORKDIR /shared
RUN poetry install --no-dev

# ---- 2️⃣  Install service dependencies
WORKDIR /app
COPY services/webhook-service/pyproject.toml services/webhook-service/poetry.lock* ./
RUN poetry install --no-dev --no-interaction --no-ansi

# ---- 3️⃣  Copy Prisma schema and generate client
COPY services/webhook-service/prisma ./prisma
RUN prisma generate

# ---- 4️⃣  Copy service code
COPY services/webhook-service /app

# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app /app
COPY --from=builder /shared /shared

ENV PYTHONPATH="/shared:/app"
ENV DOCKER_CONTAINER=1

WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

# Run migrations and start server
CMD ["sh", "-c", "prisma migrate deploy && uvicorn src.main:app --host 0.0.0.0 --port 8000"]
```

poetry.lock
poetry.toml

```toml
[virtualenvs]
in-project = true
```

pyproject.toml

```toml
[tool.poetry]
name = "webhook-service"
version = "1.0.0"
description = "Webhook service for receiving and processing external webhooks"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = {extras = ["email"], version = "^2.11.7"}
prisma = "^0.15.0"
nats-py = "^2.6.0"
shared = {path = "../../shared", develop = true}

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
ruff = "^0.1.9"
```

README.md

```md
# Webhook Service

Receives platform webhooks from the Shopify BFF and publishes domain events into the system.
This service **does not** accept raw Shopify calls directly — all requests are relayed from the BFF with internal JWT authentication.

---

## Overview

### Responsibilities
- Accept webhook payloads from the BFF at a **single unified endpoint**:
  `POST /api/v1/webhooks/shopify`
- Validate required headers and content type.
- Enforce a payload size limit.
- Store webhook records and ensure **idempotency** (via DB unique constraint on `webhook_id`).
- Publish mapped domain events for downstream services.

### Not in scope
- Shopify HMAC validation (done in BFF).
- Raw merchant access token handling (BFF handles platform auth).
- Redis-based idempotency (handled by DB uniqueness).

---

## Configuration

Environment variables:

| Name | Required | Description |
|------|----------|-------------|
| `INTERNAL_JWT_SECRET` | ✅ | Shared secret for internal JWT verification between BFF and this service. |
| `BODY_LIMIT_BYTES` | ❌ (default: `2097152`) | Maximum request body size in bytes (default 2 MB). |
| `SERVICE_PORT` | ❌ (default: `8000`) | Service HTTP port. |

---

## API

### **POST** `/api/v1/webhooks/shopify`

Receives a webhook payload from the BFF.

#### Required Headers
| Header | Description |
|--------|-------------|
| `Authorization` | `Bearer <JWT>` signed with `INTERNAL_JWT_SECRET` — must have `scope: "bff:call"`. |
| `Content-Type` | Must include `application/json`. |
| `X-Shopify-Shop-Domain` | Shop domain (e.g., `test-shop.myshopify.com`). |
| `X-Shopify-Topic` | Shopify webhook topic (e.g., `orders/create`). |
| `X-Shopify-Webhook-Id` | Unique webhook delivery ID from Shopify. |

#### Request Body
- JSON payload exactly as received from Shopify (via BFF).

#### Responses
| Status | When |
|--------|------|
| `200 OK` | Webhook accepted (new or duplicate). Returns `{ "success": true, "webhook_id": "<uuid>" }`. |
| `400 Bad Request` | Missing or invalid headers, payload not JSON, or content type not `application/json`. |
| `403 Forbidden` | JWT scope not `bff:call` or shop domain mismatch with JWT. |
| `413 Payload Too Large` | Body exceeds configured limit. |

---

## Webhook Processing Flow

1. **Shopify → BFF**
   Shopify delivers webhook to your Remix BFF endpoint.
   The BFF validates HMAC, extracts the payload + headers, signs an internal JWT, and relays to this service.

2. **BFF → Webhook Service**
   - Calls `POST /api/v1/webhooks/shopify`
   - Passes original Shopify headers (`topic`, `shop domain`, `webhook id`).
   - Uses `Authorization: Bearer <internal-jwt>` signed with `INTERNAL_JWT_SECRET`.

3. **Webhook Service**
   - Validates JWT, headers, and payload size.
   - Stores the webhook in the database.
   - If duplicate (`webhook_id` already stored) → logs and returns success without re-publishing.
   - If new → publishes mapped domain event via `WebhookEventPublisher`.

---

## Example Request (curl)

```bash
curl -X POST http://localhost:8112/api/v1/webhooks/shopify \
  -H "Authorization: Bearer $(jwtgen)" \
  -H "Content-Type: application/json" \
  -H "X-Shopify-Topic: orders/create" \
  -H "X-Shopify-Shop-Domain: test-shop.myshopify.com" \
  -H "X-Shopify-Webhook-Id: webhook-123456" \
  -d '{
        "id": 123456789,
        "total_price": "10.00",
        "currency": "USD",
        "created_at": "2025-08-09T12:00:00Z",
        "line_items": []
      }'

**Note**
`jwtgen` above is a placeholder for generating a valid JWT with payload:
```json
{
  "sub": "test-shop.myshopify.com",
  "scope": "bff:call",
  "iat": 1691587200
}
```

Sign it using **HS256** with `INTERNAL_JWT_SECRET`.

### Event Mapping

| Shopify Topic                       | Domain Event                         |
|------------------------------------|--------------------------------------|
| `app/uninstalled`                  | `app_uninstalled`                    |
| `orders/create`                    | `order_created`                      |
| `app_subscriptions/update`         | `app_subscription_updated`           |
| `app_purchases_one_time/update`    | `app_purchase_updated`               |
| `products/create`                  | `catalog_product_event (created)`    |
| `products/update`                  | `catalog_product_event (updated)`    |
| `products/delete`                  | `catalog_product_event (deleted)`    |
| `collections/create`               | `catalog_collection_event (created)` |
| `collections/update`               | `catalog_collection_event (updated)` |
| `collections/delete`               | `catalog_collection_event (deleted)` |
| `inventory_levels/update`          | `inventory_updated`                  |
| `customers/data_request`           | `gdpr_data_request`                  |
| `customers/redact`                 | `gdpr_customer_redact`               |
| `shop/redact`                      | `gdpr_shop_redact`                   |
| *(unknown)*                        | Logged as warning; no event published |

### Local Development

Run with Docker:
```bash
docker compose up webhook-service
```

Test locally (with valid JWT):

```bash
python scripts/test_webhook.py
```

```bash
python scripts/test_webhook.py
```
This way the part after the curl example won’t break the Markdown structure again.
```


================================================================================
Output includes file contents
================================================================================
