================================================================================
Directory Structure: /home/bellabe/glam-app/services/webhook-service
================================================================================

webhook-service/
alembic/
├── versions/
├── alembic.ini
│   
│   ```ini
│   [alembic]
│   script_location = alembic
│   prepend_sys_path = .
│   version_path_separator = os
│   
│   sqlalchemy.url = postgresql+asyncpg://webhook:webhook123@localhost:5432/webhook_db
│   
│   [post_write_hooks]
│   
│   [loggers]
│   keys = root,sqlalchemy,alembic
│   
│   [handlers]
│   keys = console
│   
│   [formatters]
│   keys = generic
│   
│   [logger_root]
│   level = WARN
│   handlers = console
│   qualname =
│   
│   [logger_sqlalchemy]
│   level = WARN
│   handlers =
│   qualname = sqlalchemy.engine
│   
│   [logger_alembic]
│   level = INFO
│   handlers =
│   qualname = alembic
│   
│   [handler_console]
│   class = StreamHandler
│   args = (sys.stderr,)
│   level = NOTSET
│   formatter = generic
│   
│   [formatter_generic]
│   format = %(levelname)-5.5s [%(name)s] %(message)s
│   datefmt = %H:%M:%S
│   ```
│   
└── env.py
    
    ```py
    # services/webhook-service/alembic/env.py
    """Alembic environment configuration for webhook service."""
    
    import asyncio
    import os
    from logging.config import fileConfig
    
    from sqlalchemy import pool
    from sqlalchemy.engine import Connection
    from sqlalchemy.ext.asyncio import create_async_engine
    
    from alembic import context
    
    # Import all models to ensure they're registered with Base
    from src.models import webhook_entry, platform_configuration
    from shared.database.base import Base
    
    # This is the Alembic Config object
    config = context.config
    
    # Interpret the config file for Python logging
    if config.config_file_name is not None:
        fileConfig(config.config_file_name)
    
    # Set the target metadata
    target_metadata = Base.metadata
    
    def get_database_url() -> str:
        """Get database URL from environment or config."""
        return os.getenv("DATABASE_URL") or config.get_main_option("sqlalchemy.url")
    
    def run_migrations_offline() -> None:
        """Run migrations in 'offline' mode."""
        url = get_database_url()
        context.configure(
            url=url,
            target_metadata=target_metadata,
            literal_binds=True,
            dialect_opts={"paramstyle": "named"},
        )
    
        with context.begin_transaction():
            context.run_migrations()
    
    def do_run_migrations(connection: Connection) -> None:
        """Run migrations with connection."""
        context.configure(connection=connection, target_metadata=target_metadata)
    
        with context.begin_transaction():
            context.run_migrations()
    
    async def run_async_migrations() -> None:
        """Run migrations in async mode."""
        connectable = create_async_engine(
            get_database_url(),
            poolclass=pool.NullPool,
        )
    
        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)
    
        await connectable.dispose()
    
    def run_migrations_online() -> None:
        """Run migrations in 'online' mode."""
        asyncio.run(run_async_migrations())
    
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        run_migrations_online()
    ```
    
logs/
scripts/
├── load_test.py
│   
│   ```py
│   # services/webhook-service/scripts/load_test.py
│   #!/usr/bin/env python3
│   """
│   Load test script for webhook service.
│   
│   This script simulates high-volume webhook traffic to test
│   the service's performance and reliability.
│   """
│   
│   import asyncio
│   import aiohttp
│   import json
│   import hmac
│   import hashlib
│   import base64
│   import time
│   from datetime import datetime
│   from typing import Dict, List, Any
│   from dataclasses import dataclass
│   from concurrent.futures import ThreadPoolExecutor
│   import random
│   
│   
│   @dataclass
│   class LoadTestConfig:
│       """Configuration for load testing."""
│       
│       webhook_service_url: str = "http://localhost:8012"
│       shopify_secret: str = "test_secret_key"
│       concurrent_requests: int = 50
│       total_requests: int = 1000
│       request_delay_ms: int = 10
│       timeout_seconds: int = 30
│   
│   
│   @dataclass
│   class LoadTestResult:
│       """Result of load testing."""
│       
│       total_requests: int
│       successful_requests: int
│       failed_requests: int
│       average_response_time: float
│       min_response_time: float
│       max_response_time: float
│       requests_per_second: float
│       error_distribution: Dict[str, int]
│   
│   
│   class WebhookLoadTester:
│       """Load tester for webhook service."""
│       
│       def __init__(self, config: LoadTestConfig):
│           self.config = config
│           self.results: List[Dict[str, Any]] = []
│           self.start_time = None
│           self.end_time = None
│       
│       def create_shopify_signature(self, body: str) -> str:
│           """Create Shopify HMAC signature."""
│           calculated = hmac.new(
│               self.config.shopify_secret.encode('utf-8'),
│               body.encode('utf-8'),
│               hashlib.sha256
│           ).digest()
│           return base64.b64encode(calculated).decode()
│       
│       def generate_webhook_payload(self, webhook_type: str, index: int) -> Dict[str, Any]:
│           """Generate webhook payload for different types."""
│           
│           base_time = datetime.utcnow().isoformat() + "Z"
│           
│           if webhook_type == "orders/create":
│               return {
│                   "id": 1000000 + index,
│                   "order_number": f"#{1000 + index}",
│                   "total_price": f"{random.uniform(10, 500):.2f}",
│                   "currency": "USD",
│                   "created_at": base_time,
│                   "updated_at": base_time,
│                   "line_items": [
│                       {
│                           "id": 2000000 + index,
│                           "product_id": 3000000 + (index % 100),
│                           "quantity": random.randint(1, 5),
│                           "price": f"{random.uniform(10, 100):.2f}"
│                       }
│                   ],
│                   "customer": {
│                       "id": 4000000 + (index % 1000),
│                       "email": f"customer{index}@example.com"
│                   },
│                   "shop": {
│                       "domain": f"loadtest-shop-{index % 10}.myshopify.com",
│                       "id": 5000000 + (index % 10)
│                   }
│               }
│           
│           elif webhook_type == "products/create":
│               return {
│                   "id": 6000000 + index,
│                   "title": f"Load Test Product {index}",
│                   "handle": f"load-test-product-{index}",
│                   "product_type": "Test Product",
│                   "vendor": "Load Test Vendor",
│                   "created_at": base_time,
│                   "updated_at": base_time,
│                   "shop": {
│                       "domain": f"loadtest-shop-{index % 10}.myshopify.com",
│                       "id": 5000000 + (index % 10)
│                   }
│               }
│           
│           elif webhook_type == "inventory_levels/update":
│               return {
│                   "inventory_item_id": 7000000 + index,
│                   "location_id": 8000000 + (index % 5),
│                   "available": random.randint(0, 100),
│                   "updated_at": base_time,
│                   "shop": {
│                       "domain": f"loadtest-shop-{index % 10}.myshopify.com",
│                       "id": 5000000 + (index % 10)
│                   }
│               }
│           
│           else:
│               return {
│                   "id": 9000000 + index,
│                   "created_at": base_time,
│                   "updated_at": base_time,
│                   "shop": {
│                       "domain": f"loadtest-shop-{index % 10}.myshopify.com",
│                       "id": 5000000 + (index % 10)
│                   }
│               }
│       
│       async def send_webhook_request(
│           self,
│           session: aiohttp.ClientSession,
│           webhook_type: str,
│           index: int
│       ) -> Dict[str, Any]:
│           """Send a single webhook request."""
│           
│           # Generate payload
│           payload = self.generate_webhook_payload(webhook_type, index)
│           body = json.dumps(payload)
│           signature = self.create_shopify_signature(body)
│           
│           # Prepare headers
│           headers = {
│               "Content-Type": "application/json",
│               "X-Shopify-Topic": webhook_type,
│               "X-Shopify-Hmac-Sha256": signature,
│               "X-Shopify-Shop-Domain": payload["shop"]["domain"],
│               "X-Shopify-API-Version": "2024-01",
│               "X-Shopify-Webhook-Id": f"load-test-{index}-{int(time.time())}"
│           }
│           
│           # Send request
│           url = f"{self.config.webhook_service_url}/webhooks/shopify/{webhook_type.replace('/', '%2F')}"
│           
│           start_time = time.time()
│           result = {
│               "index": index,
│               "webhook_type": webhook_type,
│               "start_time": start_time,
│               "success": False,
│               "status_code": None,
│               "response_time": None,
│               "error": None
│           }
│           
│           try:
│               async with session.post(url, headers=headers, data=body) as response:
│                   end_time = time.time()
│                   result["response_time"] = end_time - start_time
│                   result["status_code"] = response.status
│                   result["success"] = response.status == 200
│                   
│                   if response.status != 200:
│                       result["error"] = f"HTTP {response.status}"
│                       response_text = await response.text()
│                       result["error_details"] = response_text[:200]
│                   
│           except asyncio.TimeoutError:
│               result["error"] = "timeout"
│               result["response_time"] = time.time() - start_time
│           except Exception as e:
│               result["error"] = str(e)
│               result["response_time"] = time.time() - start_time
│           
│           return result
│       
│       async def run_load_test(self) -> LoadTestResult:
│           """Run the load test."""
│           
│           print(f"🚀 Starting load test with {self.config.total_requests} requests")
│           print(f"📊 Concurrency: {self.config.concurrent_requests}")
│           print(f"🎯 Target: {self.config.webhook_service_url}")
│           print()
│           
│           # Webhook types to test
│           webhook_types = [
│               "orders/create",
│               "products/create", 
│               "inventory_levels/update",
│               "orders/updated"
│           ]
│           
│           self.start_time = time.time()
│           
│           # Create semaphore for concurrency control
│           semaphore = asyncio.Semaphore(self.config.concurrent_requests)
│           
│           async def bounded_request(session, webhook_type, index):
│               async with semaphore:
│                   if self.config.request_delay_ms > 0:
│                       await asyncio.sleep(self.config.request_delay_ms / 1000)
│                   return await self.send_webhook_request(session, webhook_type, index)
│           
│           # Create HTTP session with timeout
│           timeout = aiohttp.ClientTimeout(total=self.config.timeout_seconds)
│           connector = aiohttp.TCPConnector(limit=self.config.concurrent_requests * 2)
│           
│           async with aiohttp.ClientSession(timeout=timeout, connector=connector) as session:
│               # Create tasks
│               tasks = []
│               for i in range(self.config.total_requests):
│                   webhook_type = webhook_types[i % len(webhook_types)]
│                   task = bounded_request(session, webhook_type, i)
│                   tasks.append(task)
│               
│               # Execute tasks with progress reporting
│               completed = 0
│               for coro in asyncio.as_completed(tasks):
│                   result = await coro
│                   self.results.append(result)
│                   completed += 1
│                   
│                   if completed % 100 == 0:
│                       print(f"📈 Progress: {completed}/{self.config.total_requests} requests completed")
│           
│           self.end_time = time.time()
│           
│           # Analyze results
│           return self.analyze_results()
│       
│       def analyze_results(self) -> LoadTestResult:
│           """Analyze load test results."""
│           
│           successful_requests = sum(1 for r in self.results if r["success"])
│           failed_requests = len(self.results) - successful_requests
│           
│           # Calculate response times
│           response_times = [r["response_time"] for r in self.results if r["response_time"]]
│           avg_response_time = sum(response_times) / len(response_times) if response_times else 0
│           min_response_time = min(response_times) if response_times else 0
│           max_response_time = max(response_times) if response_times else 0
│           
│           # Calculate RPS
│           total_duration = self.end_time - self.start_time
│           requests_per_second = len(self.results) / total_duration if total_duration > 0 else 0
│           
│           # Error distribution
│           error_distribution = {}
│           for result in self.results:
│               if not result["success"]:
│                   error = result["error"] or "unknown"
│                   error_distribution[error] = error_distribution.get(error, 0) + 1
│           
│           return LoadTestResult(
│               total_requests=len(self.results),
│               successful_requests=successful_requests,
│               failed_requests=failed_requests,
│               average_response_time=avg_response_time,
│               min_response_time=min_response_time,
│               max_response_time=max_response_time,
│               requests_per_second=requests_per_second,
│               error_distribution=error_distribution
│           )
│       
│       def print_results(self, result: LoadTestResult) -> None:
│           """Print load test results."""
│           
│           print("\n" + "="*60)
│           print("📊 LOAD TEST RESULTS")
│           print("="*60)
│           
│           print(f"🎯 Total Requests: {result.total_requests}")
│           print(f"✅ Successful: {result.successful_requests} ({result.successful_requests/result.total_requests*100:.1f}%)")
│           print(f"❌ Failed: {result.failed_requests} ({result.failed_requests/result.total_requests*100:.1f}%)")
│           print()
│           
│           print("⏱️  Response Times:")
│           print(f"   Average: {result.average_response_time*1000:.2f}ms")
│           print(f"   Min: {result.min_response_time*1000:.2f}ms")
│           print(f"   Max: {result.max_response_time*1000:.2f}ms")
│           print()
│           
│           print(f"🚀 Requests/Second: {result.requests_per_second:.2f}")
│           print()
│           
│           if result.error_distribution:
│               print("❌ Error Distribution:")
│               for error, count in result.error_distribution.items():
│                   print(f"   {error}: {count}")
│           
│           print("="*60)
│           
│           # Performance assessment
│           success_rate = result.successful_requests / result.total_requests * 100
│           
│           if success_rate >= 99:
│               print("🎉 EXCELLENT: >99% success rate")
│           elif success_rate >= 95:
│               print("👍 GOOD: >95% success rate")
│           elif success_rate >= 90:
│               print("⚠️  ACCEPTABLE: >90% success rate")
│           else:
│               print("💥 POOR: <90% success rate")
│           
│           if result.average_response_time < 0.1:
│               print("⚡ FAST: <100ms average response time")
│           elif result.average_response_time < 0.5:
│               print("👍 GOOD: <500ms average response time")
│           elif result.average_response_time < 1.0:
│               print("⚠️  ACCEPTABLE: <1s average response time")
│           else:
│               print("🐌 SLOW: >1s average response time")
│   
│   
│   async def main():
│       """Main function to run load test."""
│       
│       # Configuration
│       config = LoadTestConfig(
│           webhook_service_url="http://localhost:8012",
│           shopify_secret="test_secret_key",
│           concurrent_requests=50,
│           total_requests=1000,
│           request_delay_ms=10,
│           timeout_seconds=30
│       )
│       
│       # Create and run load tester
│       tester = WebhookLoadTester(config)
│       result = await tester.run_load_test()
│       tester.print_results(result)
│   
│   
│   if __name__ == "__main__":
│       asyncio.run(main())
│   ```
│   
├── setup_shopify_webhooks.py
│   
│   ```py
│   # services/webhook-service/scripts/setup_shopify_webhooks.py
│   #!/usr/bin/env python3
│   """
│   Script to set up Shopify webhooks for development.
│   
│   This script helps configure Shopify webhooks to point to your local
│   webhook service during development.
│   """
│   
│   import requests
│   import json
│   import os
│   from typing import Dict, List, Optional
│   
│   
│   class ShopifyWebhookManager:
│       """Manages Shopify webhook configuration."""
│       
│       def __init__(self, shop_domain: str, access_token: str):
│           self.shop_domain = shop_domain
│           self.access_token = access_token
│           self.base_url = f"https://{shop_domain}/admin/api/2024-01"
│           self.headers = {
│               "X-Shopify-Access-Token": access_token,
│               "Content-Type": "application/json"
│           }
│       
│       def list_webhooks(self) -> List[Dict]:
│           """List all existing webhooks."""
│           
│           response = requests.get(
│               f"{self.base_url}/webhooks.json",
│               headers=self.headers
│           )
│           
│           if response.status_code == 200:
│               return response.json().get("webhooks", [])
│           else:
│               print(f"Failed to list webhooks: {response.status_code} - {response.text}")
│               return []
│       
│       def create_webhook(self, topic: str, address: str) -> bool:
│           """Create a new webhook."""
│           
│           webhook_data = {
│               "webhook": {
│                   "topic": topic,
│                   "address": address,
│                   "format": "json"
│               }
│           }
│           
│           response = requests.post(
│               f"{self.base_url}/webhooks.json",
│               headers=self.headers,
│               json=webhook_data
│           )
│           
│           if response.status_code == 201:
│               webhook = response.json()["webhook"]
│               print(f"✅ Created webhook: {topic} -> {address} (ID: {webhook['id']})")
│               return True
│           else:
│               print(f"❌ Failed to create webhook for {topic}: {response.status_code} - {response.text}")
│               return False
│       
│       def delete_webhook(self, webhook_id: int) -> bool:
│           """Delete a webhook."""
│           
│           response = requests.delete(
│               f"{self.base_url}/webhooks/{webhook_id}.json",
│               headers=self.headers
│           )
│           
│           if response.status_code == 200:
│               print(f"🗑️  Deleted webhook ID: {webhook_id}")
│               return True
│           else:
│               print(f"❌ Failed to delete webhook {webhook_id}: {response.status_code} - {response.text}")
│               return False
│       
│       def setup_development_webhooks(self, webhook_service_url: str) -> None:
│           """Set up webhooks for development."""
│           
│           # Define the webhooks we want to create
│           webhook_topics = [
│               "app/uninstalled",
│               "orders/create",
│               "orders/updated",
│               "orders/fulfilled",
│               "orders/cancelled",
│               "products/create",
│               "products/update",
│               "products/delete",
│               "inventory_levels/update",
│               "inventory_items/update",
│               "customers/data_request",
│               "customers/redact",
│               "shop/redact"
│           ]
│           
│           print(f"🔧 Setting up webhooks for {self.shop_domain}")
│           print(f"📡 Webhook service URL: {webhook_service_url}")
│           print()
│           
│           # List existing webhooks
│           existing_webhooks = self.list_webhooks()
│           print(f"📋 Found {len(existing_webhooks)} existing webhooks")
│           
│           # Create webhooks for each topic
│           success_count = 0
│           for topic in webhook_topics:
│               # Convert topic format (e.g., "orders/create" -> "orders/create")
│               webhook_url = f"{webhook_service_url}/webhooks/shopify/{topic.replace('/', '%2F')}"
│               
│               # Check if webhook already exists
│               exists = any(
│                   webhook["topic"] == topic and webhook["address"] == webhook_url
│                   for webhook in existing_webhooks
│               )
│               
│               if exists:
│                   print(f"⏭️  Webhook already exists: {topic}")
│                   success_count += 1
│               else:
│                   if self.create_webhook(topic, webhook_url):
│                       success_count += 1
│           
│           print()
│           print(f"🎯 Successfully configured {success_count}/{len(webhook_topics)} webhooks")
│       
│       def cleanup_webhooks(self, webhook_service_url: str) -> None:
│           """Clean up webhooks pointing to the webhook service."""
│           
│           existing_webhooks = self.list_webhooks()
│           
│           webhooks_to_delete = [
│               webhook for webhook in existing_webhooks
│               if webhook["address"].startswith(webhook_service_url)
│           ]
│           
│           if not webhooks_to_delete:
│               print("🧹 No webhooks to clean up")
│               return
│           
│           print(f"🧹 Cleaning up {len(webhooks_to_delete)} webhooks")
│           
│           for webhook in webhooks_to_delete:
│               self.delete_webhook(webhook["id"])
│           
│           print("✅ Cleanup complete")
│   
│   
│   def main():
│       """Main function to set up Shopify webhooks."""
│       
│       # Configuration
│       shop_domain = os.getenv("SHOPIFY_SHOP_DOMAIN", "your-shop.myshopify.com")
│       access_token = os.getenv("SHOPIFY_ACCESS_TOKEN")
│       webhook_service_url = os.getenv("WEBHOOK_SERVICE_URL", "https://your-ngrok-url.ngrok.io")
│       
│       if not access_token:
│           print("❌ SHOPIFY_ACCESS_TOKEN environment variable is required")
│           print("   Get this from your Shopify app configuration")
│           return
│       
│       if "your-shop" in shop_domain:
│           print("❌ Please set SHOPIFY_SHOP_DOMAIN environment variable")
│           print("   Example: export SHOPIFY_SHOP_DOMAIN=your-shop.myshopify.com")
│           return
│       
│       if "ngrok" in webhook_service_url and "your-ngrok" in webhook_service_url:
│           print("❌ Please set WEBHOOK_SERVICE_URL environment variable")
│           print("   Example: export WEBHOOK_SERVICE_URL=https://abc123.ngrok.io")
│           return
│       
│       # Initialize manager
│       manager = ShopifyWebhookManager(shop_domain, access_token)
│       
│       # Show current webhooks
│       print("📋 Current webhooks:")
│       webhooks = manager.list_webhooks()
│       for webhook in webhooks:
│           print(f"   {webhook['topic']} -> {webhook['address']}")
│       print()
│       
│       # Ask user what to do
│       action = input("What would you like to do? (setup/cleanup/list): ").strip().lower()
│       
│       if action == "setup":
│           manager.setup_development_webhooks(webhook_service_url)
│       elif action == "cleanup":
│           manager.cleanup_webhooks(webhook_service_url)
│       elif action == "list":
│           print("📋 All webhooks listed above")
│       else:
│           print("❌ Invalid action. Use 'setup', 'cleanup', or 'list'")
│   
│   
│   if __name__ == "__main__":
│       main()
│   ```
│   
└── test_webhook.py
    
    ```py
    # services/webhook-service/scripts/test_webhook.py
    #!/usr/bin/env python3
    """
    Test script for webhook service.
    
    This script sends sample webhooks to the webhook service for testing.
    """
    
    import json
    import hmac
    import hashlib
    import base64
    import requests
    from datetime import datetime
    
    # Configuration
    WEBHOOK_SERVICE_URL = "http://localhost:8012"
    SHOPIFY_SECRET = "test_secret_key"  # Should match your .env
    
    def create_shopify_signature(body: str, secret: str) -> str:
        """Create Shopify HMAC signature."""
        calculated = hmac.new(
            secret.encode('utf-8'),
            body.encode('utf-8'),
            hashlib.sha256
        ).digest()
        return base64.b64encode(calculated).decode()
    
    def test_shopify_product_create():
        """Test Shopify product create webhook."""
        
        payload = {
            "id": 123456789,
            "title": "Test Product",
            "handle": "test-product",
            "created_at": datetime.utcnow().isoformat() + "Z",
            "updated_at": datetime.utcnow().isoformat() + "Z",
            "shop": {
                "domain": "test-shop.myshopify.com",
                "id": 987654321
            }
        }
        
        body = json.dumps(payload)
        signature = create_shopify_signature(body, SHOPIFY_SECRET)
        
        headers = {
            "Content-Type": "application/json",
            "X-Shopify-Topic": "products/create",
            "X-Shopify-Hmac-Sha256": signature,
            "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
            "X-Shopify-API-Version": "2024-01",
            "X-Shopify-Webhook-Id": "12345678-1234-1234-1234-123456789012"
        }
        
        print("Testing Shopify product create webhook...")
        
        # Test topic in URL
        response = requests.post(
            f"{WEBHOOK_SERVICE_URL}/webhooks/shopify/products/create",
            headers=headers,
            data=body
        )
        
        print(f"Response Status: {response.status_code}")
        print(f"Response Body: {response.text}")
        
        if response.status_code == 200:
            print("✅ Webhook processed successfully!")
        else:
            print("❌ Webhook processing failed!")
        
        return response.status_code == 200
    
    def test_shopify_order_create():
        """Test Shopify order create webhook."""
        
        payload = {
            "id": 456789123,
            "order_number": 1001,
            "total_price": "29.99",
            "currency": "USD",
            "created_at": datetime.utcnow().isoformat() + "Z",
            "line_items": [
                {
                    "id": 789123456,
                    "product_id": 123456789,
                    "quantity": 1,
                    "price": "29.99"
                }
            ],
            "customer": {
                "id": 321654987,
                "email": "customer@example.com"
            },
            "shop": {
                "domain": "test-shop.myshopify.com",
                "id": 987654321
            }
        }
        
        body = json.dumps(payload)
        signature = create_shopify_signature(body, SHOPIFY_SECRET)
        
        headers = {
            "Content-Type": "application/json",
            "X-Shopify-Topic": "orders/create",
            "X-Shopify-Hmac-Sha256": signature,
            "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
            "X-Shopify-API-Version": "2024-01",
            "X-Shopify-Webhook-Id": "87654321-4321-4321-4321-210987654321"
        }
        
        print("\nTesting Shopify order create webhook...")
        
        # Test generic endpoint
        response = requests.post(
            f"{WEBHOOK_SERVICE_URL}/webhooks/shopify",
            headers=headers,
            data=body
        )
        
        print(f"Response Status: {response.status_code}")
        print(f"Response Body: {response.text}")
        
        if response.status_code == 200:
            print("✅ Webhook processed successfully!")
        else:
            print("❌ Webhook processing failed!")
        
        return response.status_code == 200
    
    def test_health_check():
        """Test health check endpoint."""
        
        print("\nTesting health check...")
        
        response = requests.get(f"{WEBHOOK_SERVICE_URL}/api/v1/health")
        
        print(f"Response Status: {response.status_code}")
        print(f"Response Body: {response.text}")
        
        if response.status_code == 200:
            print("✅ Health check passed!")
        else:
            print("❌ Health check failed!")
        
        return response.status_code == 200
    
    def test_invalid_signature():
        """Test webhook with invalid signature."""
        
        payload = {"test": "data"}
        body = json.dumps(payload)
        
        headers = {
            "Content-Type": "application/json",
            "X-Shopify-Topic": "products/create",
            "X-Shopify-Hmac-Sha256": "invalid_signature",
            "X-Shopify-Shop-Domain": "test-shop.myshopify.com",
            "X-Shopify-API-Version": "2024-01",
            "X-Shopify-Webhook-Id": "test-id"
        }
        
        print("\nTesting invalid signature...")
        
        response = requests.post(
            f"{WEBHOOK_SERVICE_URL}/webhooks/shopify/products/create",
            headers=headers,
            data=body
        )
        
        print(f"Response Status: {response.status_code}")
        print(f"Response Body: {response.text}")
        
        if response.status_code == 401:
            print("✅ Invalid signature properly rejected!")
            return True
        else:
            print("❌ Invalid signature not properly handled!")
            return False
    
    def main():
        """Run all tests."""
        
        print("🧪 Starting webhook service tests...\n")
        
        tests = [
            ("Health Check", test_health_check),
            ("Shopify Product Create", test_shopify_product_create),
            ("Shopify Order Create", test_shopify_order_create),
            ("Invalid Signature", test_invalid_signature),
        ]
        
        results = []
        
        for test_name, test_func in tests:
            try:
                result = test_func()
                results.append((test_name, result))
            except Exception as e:
                print(f"❌ {test_name} failed with error: {e}")
                results.append((test_name, False))
        
        print("\n" + "="*50)
        print("📊 Test Results Summary:")
        print("="*50)
        
        passed = 0
        total = len(results)
        
        for test_name, result in results:
            status = "✅ PASS" if result else "❌ FAIL"
            print(f"{test_name}: {status}")
            if result:
                passed += 1
        
        print(f"\n🎯 {passed}/{total} tests passed")
        
        if passed == total:
            print("🎉 All tests passed!")
        else:
            print("⚠️  Some tests failed. Check the webhook service logs for details.")
    
    if __name__ == "__main__":
        main()
    ```
    
src/
├── api/
│   ├── v1/
│   │   ├── __init__.py
│   │   │   
│   │   │   ```py
│   │   │   # services/webhook-service/src/api/v1/__init__.py
│   │   │   """API v1 routes for webhook service."""
│   │   │   ```
│   │   │   
│   │   ├── error_handlers.py
│   │   │   
│   │   │   ```py
│   │   │   # services/webhook-service/src/api/v1/error_handlers.py
│   │   │   """Error handlers for webhook API endpoints."""
│   │   │   
│   │   │   from fastapi import HTTPException, Request
│   │   │   from fastapi.responses import JSONResponse
│   │   │   from starlette.status import HTTP_401_UNAUTHORIZED, HTTP_413_REQUEST_ENTITY_TOO_LARGE, HTTP_422_UNPROCESSABLE_ENTITY
│   │   │   
│   │   │   from ...errors import (
│   │   │       InvalidSignatureError,
│   │   │       WebhookValidationError,
│   │   │       PayloadTooLargeError,
│   │   │       DuplicateWebhookError,
│   │   │       PlatformNotSupportedError
│   │   │   )
│   │   │   
│   │   │   
│   │   │   async def invalid_signature_handler(request: Request, exc: InvalidSignatureError) -> JSONResponse:
│   │   │       """Handle invalid signature errors."""
│   │   │       return JSONResponse(
│   │   │           status_code=HTTP_401_UNAUTHORIZED,
│   │   │           content={
│   │   │               "error": "invalid_signature",
│   │   │               "message": exc.message,
│   │   │               "code": exc.error_code
│   │   │           }
│   │   │       )
│   │   │   
│   │   │   
│   │   │   async def webhook_validation_handler(request: Request, exc: WebhookValidationError) -> JSONResponse:
│   │   │       """Handle webhook validation errors."""
│   │   │       return JSONResponse(
│   │   │           status_code=HTTP_422_UNPROCESSABLE_ENTITY,
│   │   │           content={
│   │   │               "error": "validation_error",
│   │   │               "message": exc.message,
│   │   │               "code": exc.error_code
│   │   │           }
│   │   │       )
│   │   │   
│   │   │   
│   │   │   async def payload_too_large_handler(request: Request, exc: PayloadTooLargeError) -> JSONResponse:
│   │   │       """Handle payload too large errors."""
│   │   │       return JSONResponse(
│   │   │           status_code=HTTP_413_REQUEST_ENTITY_TOO_LARGE,
│   │   │           content={
│   │   │               "error": "payload_too_large",
│   │   │               "message": exc.message,
│   │   │               "code": exc.error_code
│   │   │           }
│   │   │       )
│   │   │   
│   │   │   
│   │   │   async def duplicate_webhook_handler(request: Request, exc: DuplicateWebhookError) -> JSONResponse:
│   │   │       """Handle duplicate webhook errors."""
│   │   │       return JSONResponse(
│   │   │           status_code=200,  # Return 200 for duplicates to prevent retries
│   │   │           content={
│   │   │               "success": True,
│   │   │               "message": exc.message,
│   │   │               "code": exc.error_code
│   │   │           }
│   │   │       )
│   │   │   
│   │   │   
│   │   │   async def platform_not_supported_handler(request: Request, exc: PlatformNotSupportedError) -> JSONResponse:
│   │   │       """Handle platform not supported errors."""
│   │   │       return JSONResponse(
│   │   │           status_code=HTTP_422_UNPROCESSABLE_ENTITY,
│   │   │           content={
│   │   │               "error": "platform_not_supported",
│   │   │               "message": exc.message,
│   │   │               "code": exc.error_code
│   │   │           }
│   │   │       )
│   │   │   ```
│   │   │   
│   │   ├── health.py
│   │   │   
│   │   │   ```py
│   │   │   # services/webhook-service/src/api/v1/health.py
│   │   │   """Health check endpoints for webhook service."""
│   │   │   
│   │   │   from fastapi import APIRouter, Depends
│   │   │   from typing import Dict, Any
│   │   │   
│   │   │   from shared.api.dependencies import RequestIdDep
│   │   │   from shared.database.dependencies import get_database_health
│   │   │   
│   │   │   from ...dependencies import LifecycleDep, ConfigDep
│   │   │   
│   │   │   router = APIRouter(tags=["Health"])
│   │   │   
│   │   │   
│   │   │   @router.get("/health")
│   │   │   async def health_check(
│   │   │       request_id: RequestIdDep,
│   │   │       config: ConfigDep
│   │   │   ) -> Dict[str, Any]:
│   │   │       """Basic health check endpoint."""
│   │   │       
│   │   │       return {
│   │   │           "status": "healthy",
│   │   │           "service": config.service_name,
│   │   │           "version": config.service_version,
│   │   │           "request_id": request_id
│   │   │       }
│   │   │   
│   │   │   
│   │   │   @router.get("/health/detailed")
│   │   │   async def detailed_health_check(
│   │   │       request_id: RequestIdDep,
│   │   │       lifecycle: LifecycleDep,
│   │   │       config: ConfigDep
│   │   │   ) -> Dict[str, Any]:
│   │   │       """Detailed health check with component status."""
│   │   │       
│   │   │       health_data = {
│   │   │           "status": "healthy",
│   │   │           "service": config.service_name,
│   │   │           "version": config.service_version,
│   │   │           "request_id": request_id,
│   │   │           "components": {}
│   │   │       }
│   │   │       
│   │   │       # Check database
│   │   │       if config.db_enabled and lifecycle.db_manager:
│   │   │           try:
│   │   │               db_health = await get_database_health()
│   │   │               health_data["components"]["database"] = {
│   │   │                   "status": "healthy" if db_health["connected"] else "unhealthy",
│   │   │                   "details": db_health
│   │   │               }
│   │   │           except Exception as e:
│   │   │               health_data["components"]["database"] = {
│   │   │                   "status": "unhealthy",
│   │   │                   "error": str(e)
│   │   │               }
│   │   │       
│   │   │       # Check Redis
│   │   │       if lifecycle.redis_client:
│   │   │           try:
│   │   │               await lifecycle.redis_client.ping()
│   │   │               health_data["components"]["redis"] = {"status": "healthy"}
│   │   │           except Exception as e:
│   │   │               health_data["components"]["redis"] = {
│   │   │                   "status": "unhealthy",
│   │   │                   "error": str(e)
│   │   │               }
│   │   │       
│   │   │       # Check NATS
│   │   │       if lifecycle.messaging_wrapper:
│   │   │           try:
│   │   │               is_connected = lifecycle.messaging_wrapper._nats.is_connected
│   │   │               health_data["components"]["nats"] = {
│   │   │                   "status": "healthy" if is_connected else "unhealthy",
│   │   │                   "connected": is_connected
│   │   │               }
│   │   │           except Exception as e:
│   │   │               health_data["components"]["nats"] = {
│   │   │                   "status": "unhealthy",
│   │   │                   "error": str(e)
│   │   │               }
│   │   │       
│   │   │       # Check if any component is unhealthy
│   │   │       unhealthy_components = [
│   │   │           name for name, component in health_data["components"].items()
│   │   │           if component["status"] == "unhealthy"
│   │   │       ]
│   │   │       
│   │   │       if unhealthy_components:
│   │   │           health_data["status"] = "degraded"
│   │   │           health_data["unhealthy_components"] = unhealthy_components
│   │   │       
│   │   │       return health_data
│   │   │   ```
│   │   │   
│   │   └── webhooks.py
│   │       
│   │       ```py
│   │       # services/webhook-service/src/api/v1/webhooks.py
│   │       """Webhook endpoints for receiving external webhooks."""
│   │       
│   │       import json
│   │       from typing import Dict, Any
│   │       from fastapi import APIRouter, Request, HTTPException, Header, Body, status
│   │       from fastapi.responses import JSONResponse
│   │       
│   │       from shared.api.dependencies import RequestIdDep
│   │       from shared.utils.logger import ServiceLogger
│   │       
│   │       from ...dependencies import (
│   │           LifecycleDep,
│   │           ConfigDep,
│   │           WebhookServiceDep,
│   │           PlatformHandlerServiceDep
│   │       )
│   │       from ...schemas.webhook import WebhookResponse
│   │       from ...exceptions import (
│   │           InvalidSignatureError,
│   │           WebhookValidationError,
│   │           PayloadTooLargeError
│   │       )
│   │       
│   │       router = APIRouter(tags=["Webhooks"])
│   │       
│   │       
│   │       @router.post("/shopify/{topic}")
│   │       async def receive_shopify_webhook_with_topic(
│   │           topic: str,
│   │           request: Request,
│   │           request_id: RequestIdDep,
│   │           config: ConfigDep,
│   │           webhook_service: WebhookServiceDep,
│   │           platform_handler_service: PlatformHandlerServiceDep,
│   │           x_shopify_topic: str = Header(..., alias="X-Shopify-Topic"),
│   │           x_shopify_hmac_sha256: str = Header(..., alias="X-Shopify-Hmac-Sha256"),
│   │           x_shopify_shop_domain: str = Header(..., alias="X-Shopify-Shop-Domain"),
│   │           x_shopify_api_version: str = Header(..., alias="X-Shopify-API-Version"),
│   │           x_shopify_webhook_id: str = Header(..., alias="X-Shopify-Webhook-Id"),
│   │       ) -> WebhookResponse:
│   │           """
│   │           Receive Shopify webhook with topic in URL path.
│   │           
│   │           This endpoint handles Shopify webhooks where the topic is specified
│   │           in the URL path (e.g., /webhooks/shopify/orders/create).
│   │           """
│   │           
│   │           return await _process_shopify_webhook(
│   │               topic=topic,
│   │               request=request,
│   │               request_id=request_id,
│   │               config=config,
│   │               webhook_service=webhook_service,
│   │               platform_handler_service=platform_handler_service,
│   │               headers={
│   │                   "X-Shopify-Topic": x_shopify_topic,
│   │                   "X-Shopify-Hmac-Sha256": x_shopify_hmac_sha256,
│   │                   "X-Shopify-Shop-Domain": x_shopify_shop_domain,
│   │                   "X-Shopify-API-Version": x_shopify_api_version,
│   │                   "X-Shopify-Webhook-Id": x_shopify_webhook_id,
│   │               }
│   │           )
│   │       
│   │       
│   │       @router.post("/shopify")
│   │       async def receive_shopify_webhook_generic(
│   │           request: Request,
│   │           request_id: RequestIdDep,
│   │           config: ConfigDep,
│   │           webhook_service: WebhookServiceDep,
│   │           platform_handler_service: PlatformHandlerServiceDep,
│   │           x_shopify_topic: str = Header(..., alias="X-Shopify-Topic"),
│   │           x_shopify_hmac_sha256: str = Header(..., alias="X-Shopify-Hmac-Sha256"),
│   │           x_shopify_shop_domain: str = Header(..., alias="X-Shopify-Shop-Domain"),
│   │           x_shopify_api_version: str = Header(..., alias="X-Shopify-API-Version"),
│   │           x_shopify_webhook_id: str = Header(..., alias="X-Shopify-Webhook-Id"),
│   │       ) -> WebhookResponse:
│   │           """
│   │           Receive Shopify webhook with topic in header.
│   │           
│   │           This endpoint handles Shopify webhooks where the topic is specified
│   │           in the X-Shopify-Topic header.
│   │           """
│   │           
│   │           return await _process_shopify_webhook(
│   │               topic=x_shopify_topic,
│   │               request=request,
│   │               request_id=request_id,
│   │               config=config,
│   │               webhook_service=webhook_service,
│   │               platform_handler_service=platform_handler_service,
│   │               headers={
│   │                   "X-Shopify-Topic": x_shopify_topic,
│   │                   "X-Shopify-Hmac-Sha256": x_shopify_hmac_sha256,
│   │                   "X-Shopify-Shop-Domain": x_shopify_shop_domain,
│   │                   "X-Shopify-API-Version": x_shopify_api_version,
│   │                   "X-Shopify-Webhook-Id": x_shopify_webhook_id,
│   │               }
│   │           )
│   │       
│   │       
│   │       async def _process_shopify_webhook(
│   │           topic: str,
│   │           request: Request,
│   │           request_id: str,
│   │           config: Any,
│   │           webhook_service: Any,
│   │           platform_handler_service: Any,
│   │           headers: Dict[str, str]
│   │       ) -> WebhookResponse:
│   │           """Internal function to process Shopify webhooks."""
│   │           
│   │           logger = ServiceLogger(config.service_name)
│   │           
│   │           try:
│   │               # Read raw body
│   │               body = await request.body()
│   │               
│   │               # Check payload size
│   │               if len(body) > config.webhook_max_payload_size_mb * 1024 * 1024:
│   │                   raise PayloadTooLargeError(
│   │                       f"Payload size {len(body)} exceeds maximum {config.webhook_max_payload_size_mb}MB"
│   │                   )
│   │               
│   │               # Validate signature
│   │               if not platform_handler_service.validate_webhook("shopify", body, headers):
│   │                   logger.warning(
│   │                       "Invalid webhook signature",
│   │                       extra={
│   │                           "platform": "shopify",
│   │                           "topic": topic,
│   │                           "request_id": request_id,
│   │                           "shop_domain": headers.get("X-Shopify-Shop-Domain")
│   │                       }
│   │                   )
│   │                   raise InvalidSignatureError("Invalid webhook signature")
│   │               
│   │               # Parse JSON payload
│   │               try:
│   │                   payload = json.loads(body.decode('utf-8'))
│   │               except (json.JSONDecodeError, UnicodeDecodeError) as e:
│   │                   logger.error(
│   │                       "Failed to parse webhook payload",
│   │                       extra={
│   │                           "platform": "shopify",
│   │                           "topic": topic,
│   │                           "request_id": request_id,
│   │                           "error": str(e)
│   │                       }
│   │                   )
│   │                   raise WebhookValidationError(f"Invalid JSON payload: {str(e)}")
│   │               
│   │               # Process webhook
│   │               webhook_entry = await webhook_service.process_webhook(
│   │                   platform="shopify",
│   │                   topic=topic,
│   │                   payload=payload,
│   │                   headers=headers,
│   │                   signature=headers["X-Shopify-Hmac-Sha256"]
│   │               )
│   │               
│   │               logger.info(
│   │                   "Webhook processed successfully",
│   │                   extra={
│   │                       "platform": "shopify",
│   │                       "topic": topic,
│   │                       "request_id": request_id,
│   │                       "webhook_id": str(webhook_entry.id),
│   │                       "shop_domain": headers.get("X-Shopify-Shop-Domain")
│   │                   }
│   │               )
│   │               
│   │               return WebhookResponse(
│   │                   success=True,
│   │                   webhook_id=webhook_entry.id,
│   │                   message="Webhook processed successfully"
│   │               )
│   │               
│   │           except (InvalidSignatureError, WebhookValidationError, PayloadTooLargeError):
│   │               # Re-raise known webhook errors
│   │               raise
│   │           
│   │           except Exception as e:
│   │               logger.error(
│   │                   "Unexpected error processing webhook",
│   │                   extra={
│   │                       "platform": "shopify",
│   │                       "topic": topic,
│   │                       "request_id": request_id,
│   │                       "error": str(e)
│   │                   },
│   │                   exc_info=True
│   │               )
│   │               
│   │               # Return 200 OK even for processing errors to prevent retries
│   │               # The webhook entry will be marked as failed in the database
│   │               return WebhookResponse(
│   │                   success=False,
│   │                   webhook_id="00000000-0000-0000-0000-000000000000",  # Placeholder UUID
│   │                   message=f"Webhook processing failed: {str(e)}"
│   │               )
│   │       ```
│   │       
│   └── __init__.py
│       
│       ```py
│       # services/webhook-service/src/api/__init__.py
│       """API routes for webhook service."""
│       ```
│       
├── events/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/events/__init__.py
│   │   """Events for webhook service."""
│   │   
│   │   from .publishers import WebhookEventPublisher
│   │   
│   │   __all__ = [
│   │       "WebhookEventPublisher",
│   │   ]
│   │   ```
│   │   
│   ├── domain_events.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/events/domain_events.py
│   │   """Domain events for webhook service."""
│   │   
│   │   from __future__ import annotations
│   │   
│   │   from datetime import datetime
│   │   from typing import Dict, Any, List
│   │   
│   │   from shared.events.base import EventWrapper
│   │   from shared.events.context import EventContext
│   │   from pydantic import BaseModel
│   │   
│   │   
│   │   # Event payload schemas
│   │   class AppUninstalledPayload(BaseModel):
│   │       shop_id: str
│   │       shop_domain: str
│   │       timestamp: str
│   │   
│   │   
│   │   class CatalogItemPayload(BaseModel):
│   │       shop_id: str
│   │       item_id: str
│   │       external_id: str
│   │   
│   │   
│   │   class CatalogItemUpdatedPayload(CatalogItemPayload):
│   │       changes: List[str]
│   │   
│   │   
│   │   class OrderCreatedPayload(BaseModel):
│   │       shop_id: str
│   │       order_id: str
│   │       total: float
│   │       items: List[Dict[str, Any]]
│   │   
│   │   
│   │   class InventoryUpdatedPayload(BaseModel):
│   │       shop_id: str
│   │       item_id: str
│   │       location_id: str
│   │       available: int
│   │   
│   │   
│   │   # Domain Events
│   │   class AppUninstalledEvent(EventWrapper[AppUninstalledPayload]):
│   │       """Event emitted when an app is uninstalled"""
│   │       
│   │       subject: str = "evt.webhook.app.uninstalled"
│   │       
│   │       @classmethod
│   │       def create(
│   │           cls,
│   │           shop_id: str,
│   │           shop_domain: str,
│   │           timestamp: datetime
│   │       ) -> "AppUninstalledEvent":
│   │           """Create event with auto-generated context"""
│   │           context = EventContext.create()
│   │           return cls.create_from_context(
│   │               context=context,
│   │               payload={
│   │                   "shop_id": shop_id,
│   │                   "shop_domain": shop_domain,
│   │                   "timestamp": timestamp.isoformat()
│   │               }
│   │           )
│   │       
│   │       @classmethod
│   │       def create_from_context(
│   │           cls, context: EventContext, payload: Dict[str, Any]
│   │       ) -> "AppUninstalledEvent":
│   │           """Create event with context"""
│   │           return cls(
│   │               subject=cls.subject,
│   │               idempotency_key=context.idempotency_key,
│   │               event_id=context.event_id,
│   │               correlation_id=context.correlation_id,
│   │               timestamp=context.timestamp,
│   │               metadata=context.metadata,
│   │               data=AppUninstalledPayload(**payload),
│   │           )
│   │   
│   │   
│   │   class CatalogItemCreatedEvent(EventWrapper[CatalogItemPayload]):
│   │       """Event emitted when a catalog item is created"""
│   │       
│   │       subject: str = "evt.webhook.catalog.item_created"
│   │       
│   │       @classmethod
│   │       def create(
│   │           cls,
│   │           shop_id: str,
│   │           item_id: str,
│   │           external_id: str
│   │       ) -> "CatalogItemCreatedEvent":
│   │           """Create event with auto-generated context"""
│   │           context = EventContext.create()
│   │           return cls.create_from_context(
│   │               context=context,
│   │               payload={
│   │                   "shop_id": shop_id,
│   │                   "item_id": item_id,
│   │                   "external_id": external_id
│   │               }
│   │           )
│   │       
│   │       @classmethod
│   │       def create_from_context(
│   │           cls, context: EventContext, payload: Dict[str, Any]
│   │       ) -> "CatalogItemCreatedEvent":
│   │           """Create event with context"""
│   │           return cls(
│   │               subject=cls.subject,
│   │               idempotency_key=context.idempotency_key,
│   │               event_id=context.event_id,
│   │               correlation_id=context.correlation_id,
│   │               timestamp=context.timestamp,
│   │               metadata=context.metadata,
│   │               data=CatalogItemPayload(**payload),
│   │           )
│   │   
│   │   
│   │   class CatalogItemUpdatedEvent(EventWrapper[CatalogItemUpdatedPayload]):
│   │       """Event emitted when a catalog item is updated"""
│   │       
│   │       subject: str = "evt.webhook.catalog.item_updated"
│   │       
│   │       @classmethod
│   │       def create(
│   │           cls,
│   │           shop_id: str,
│   │           item_id: str,
│   │           external_id: str,
│   │           changes: List[str]
│   │       ) -> "CatalogItemUpdatedEvent":
│   │           """Create event with auto-generated context"""
│   │           context = EventContext.create()
│   │           return cls.create_from_context(
│   │               context=context,
│   │               payload={
│   │                   "shop_id": shop_id,
│   │                   "item_id": item_id,
│   │                   "external_id": external_id,
│   │                   "changes": changes
│   │               }
│   │           )
│   │       
│   │       @classmethod
│   │       def create_from_context(
│   │           cls, context: EventContext, payload: Dict[str, Any]
│   │       ) -> "CatalogItemUpdatedEvent":
│   │           """Create event with context"""
│   │           return cls(
│   │               subject=cls.subject,
│   │               idempotency_key=context.idempotency_key,
│   │               event_id=context.event_id,
│   │               correlation_id=context.correlation_id,
│   │               timestamp=context.timestamp,
│   │               metadata=context.metadata,
│   │               data=CatalogItemUpdatedPayload(**payload),
│   │           )
│   │   
│   │   
│   │   class CatalogItemDeletedEvent(EventWrapper[CatalogItemPayload]):
│   │       """Event emitted when a catalog item is deleted"""
│   │       
│   │       subject: str = "evt.webhook.catalog.item_deleted"
│   │       
│   │       @classmethod
│   │       def create(
│   │           cls,
│   │           shop_id: str,
│   │           item_id: str,
│   │           external_id: str
│   │       ) -> "CatalogItemDeletedEvent":
│   │           """Create event with auto-generated context"""
│   │           context = EventContext.create()
│   │           return cls.create_from_context(
│   │               context=context,
│   │               payload={
│   │                   "shop_id": shop_id,
│   │                   "item_id": item_id,
│   │                   "external_id": external_id
│   │               }
│   │           )
│   │       
│   │       @classmethod
│   │       def create_from_context(
│   │           cls, context: EventContext, payload: Dict[str, Any]
│   │       ) -> "CatalogItemDeletedEvent":
│   │           """Create event with context"""
│   │           return cls(
│   │               subject=cls.subject,
│   │               idempotency_key=context.idempotency_key,
│   │               event_id=context.event_id,
│   │               correlation_id=context.correlation_id,
│   │               timestamp=context.timestamp,
│   │               metadata=context.metadata,
│   │               data=CatalogItemPayload(**payload),
│   │           )
│   │   
│   │   
│   │   class OrderCreatedEvent(EventWrapper[OrderCreatedPayload]):
│   │       """Event emitted when an order is created"""
│   │       
│   │       subject: str = "evt.webhook.order.created"
│   │       
│   │       @classmethod
│   │       def create(
│   │           cls,
│   │           shop_id: str,
│   │           order_id: str,
│   │           total: float,
│   │           items: List[Dict[str, Any]]
│   │       ) -> "OrderCreatedEvent":
│   │           """Create event with auto-generated context"""
│   │           context = EventContext.create()
│   │           return cls.create_from_context(
│   │               context=context,
│   │               payload={
│   │                   "shop_id": shop_id,
│   │                   "order_id": order_id,
│   │                   "total": total,
│   │                   "items": items
│   │               }
│   │           )
│   │       
│   │       @classmethod
│   │       def create_from_context(
│   │           cls, context: EventContext, payload: Dict[str, Any]
│   │       ) -> "OrderCreatedEvent":
│   │           """Create event with context"""
│   │           return cls(
│   │               subject=cls.subject,
│   │               idempotency_key=context.idempotency_key,
│   │               event_id=context.event_id,
│   │               correlation_id=context.correlation_id,
│   │               timestamp=context.timestamp,
│   │               metadata=context.metadata,
│   │               data=OrderCreatedPayload(**payload),
│   │           )
│   │   
│   │   
│   │   class InventoryUpdatedEvent(EventWrapper[InventoryUpdatedPayload]):
│   │       """Event emitted when inventory is updated"""
│   │       
│   │       subject: str = "evt.webhook.inventory.updated"
│   │       
│   │       @classmethod
│   │       def create(
│   │           cls,
│   │           shop_id: str,
│   │           item_id: str,
│   │           location_id: str,
│   │           available: int
│   │       ) -> "InventoryUpdatedEvent":
│   │           """Create event with auto-generated context"""
│   │           context = EventContext.create()
│   │           return cls.create_from_context(
│   │               context=context,
│   │               payload={
│   │                   "shop_id": shop_id,
│   │                   "item_id": item_id,
│   │                   "location_id": location_id,
│   │                   "available": available
│   │               }
│   │           )
│   │       
│   │       @classmethod
│   │       def create_from_context(
│   │           cls, context: EventContext, payload: Dict[str, Any]
│   │       ) -> "InventoryUpdatedEvent":
│   │           """Create event with context"""
│   │           return cls(
│   │               subject=cls.subject,
│   │               idempotency_key=context.idempotency_key,
│   │               event_id=context.event_id,
│   │               correlation_id=context.correlation_id,
│   │               timestamp=context.timestamp,
│   │               metadata=context.metadata,
│   │               data=InventoryUpdatedPayload(**payload),
│   │           )
│   │   ```
│   │   
│   └── publishers.py
│       
│       ```py
│       # services/webhook-service/src/events/publishers.py
│       """Event publishers for webhook service."""
│       
│       from __future__ import annotations
│       
│       from typing import Any
│       
│       from shared.events.base_publisher import DomainEventPublisher
│       from shared.events.context import EventContext
│       
│       from .domain_events import (
│           AppUninstalledEvent,
│           CatalogItemCreatedEvent, 
│           CatalogItemUpdatedEvent,
│           CatalogItemDeletedEvent,
│           OrderCreatedEvent,
│           InventoryUpdatedEvent
│       )
│       
│       
│       class WebhookEventPublisher(DomainEventPublisher):
│           """Publisher for webhook domain events."""
│           
│           async def publish_app_uninstalled(
│               self,
│               context: EventContext,
│               shop_id: str,
│               shop_domain: str
│           ) -> None:
│               """Publish app uninstalled event."""
│               
│               event = AppUninstalledEvent.create_from_context(
│                   context=context,
│                   payload={
│                       "shop_id": shop_id,
│                       "shop_domain": shop_domain,
│                       "timestamp": context.timestamp.isoformat()
│                   }
│               )
│               
│               await self.publish_event(event)
│           
│           async def publish_catalog_item_created(
│               self,
│               context: EventContext,
│               shop_id: str,
│               item_id: str,
│               external_id: str
│           ) -> None:
│               """Publish catalog item created event."""
│               
│               event = CatalogItemCreatedEvent.create_from_context(
│                   context=context,
│                   payload={
│                       "shop_id": shop_id,
│                       "item_id": item_id,
│                       "external_id": external_id
│                   }
│               )
│               
│               await self.publish_event(event)
│           
│           async def publish_catalog_item_updated(
│               self,
│               context: EventContext,
│               shop_id: str,
│               item_id: str,
│               external_id: str,
│               changes: list
│           ) -> None:
│               """Publish catalog item updated event."""
│               
│               event = CatalogItemUpdatedEvent.create_from_context(
│                   context=context,
│                   payload={
│                       "shop_id": shop_id,
│                       "item_id": item_id,
│                       "external_id": external_id,
│                       "changes": changes
│                   }
│               )
│               
│               await self.publish_event(event)
│           
│           async def publish_catalog_item_deleted(
│               self,
│               context: EventContext,
│               shop_id: str,
│               item_id: str,
│               external_id: str
│           ) -> None:
│               """Publish catalog item deleted event."""
│               
│               event = CatalogItemDeletedEvent.create_from_context(
│                   context=context,
│                   payload={
│                       "shop_id": shop_id,
│                       "item_id": item_id,
│                       "external_id": external_id
│                   }
│               )
│               
│               await self.publish_event(event)
│           
│           async def publish_order_created(
│               self,
│               context: EventContext,
│               shop_id: str,
│               order_id: str,
│               total: float,
│               items: list
│           ) -> None:
│               """Publish order created event."""
│               
│               event = OrderCreatedEvent.create_from_context(
│                   context=context,
│                   payload={
│                       "shop_id": shop_id,
│                       "order_id": order_id,
│                       "total": total,
│                       "items": items
│                   }
│               )
│               
│               await self.publish_event(event)
│           
│           async def publish_inventory_updated(
│               self,
│               context: EventContext,
│               shop_id: str,
│               item_id: str,
│               location_id: str,
│               available: int
│           ) -> None:
│               """Publish inventory updated event."""
│               
│               event = InventoryUpdatedEvent.create_from_context(
│                   context=context,
│                   payload={
│                       "shop_id": shop_id,
│                       "item_id": item_id,
│                       "location_id": location_id,
│                       "available": available
│                   }
│               )
│               
│               await self.publish_event(event)
│       ```
│       
├── handlers/
│   ├── base.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/handlers/shopify.py
│   │   """Shopify webhook handler following established patterns."""
│   │   
│   │   import hashlib
│   │   from typing import Dict, Any, Optional
│   │   from datetime import datetime
│   │   
│   │   from .base import WebhookHandler, WebhookData, DomainEvent
│   │   
│   │   
│   │   class ShopifyWebhookHandler(WebhookHandler):
│   │       """Handler for Shopify webhooks"""
│   │   
│   │       # Topic to domain event mapping
│   │       TOPIC_EVENT_MAP = {
│   │           # App lifecycle
│   │           "app/uninstalled": "evt.webhook.app.uninstalled",
│   │           "app_subscriptions/update": "evt.webhook.app.subscription_updated",
│   │           "app_purchases_one_time/update": "evt.webhook.app.purchase_updated",
│   │           # Catalog
│   │           "products/create": "evt.webhook.catalog.item_created",
│   │           "products/update": "evt.webhook.catalog.item_updated",
│   │           "products/delete": "evt.webhook.catalog.item_deleted",
│   │           # Orders
│   │           "orders/create": "evt.webhook.order.created",
│   │           "orders/updated": "evt.webhook.order.updated",
│   │           "orders/fulfilled": "evt.webhook.order.fulfilled",
│   │           "orders/cancelled": "evt.webhook.order.cancelled",
│   │           # Inventory
│   │           "inventory_levels/update": "evt.webhook.inventory.updated",
│   │           "inventory_items/update": "evt.webhook.inventory.item_updated",
│   │           # Compliance (no domain events)
│   │           "customers/data_request": None,
│   │           "customers/redact": None,
│   │           "shop/redact": None,
│   │       }
│   │   
│   │       def parse_webhook(
│   │           self, body: Dict[str, Any], topic: Optional[str], headers: Dict[str, str]
│   │       ) -> WebhookData:
│   │           """Parse Shopify webhook"""
│   │   
│   │           # Get topic from header if not in path
│   │           if not topic:
│   │               topic = headers.get("x-shopify-topic", "unknown")
│   │   
│   │           # Extract shop info
│   │           merchant_domain = headers.get("x-shopify-shop-domain", "")
│   │           merchant_id = merchant_domain.split(".")[0] if merchant_domain else None
│   │   
│   │           # Generate idempotency key
│   │           idempotency_key = self.get_idempotency_key(body, topic, headers)
│   │   
│   │           # Build metadata
│   │           metadata = {
│   │               "webhook_id": headers.get("x-shopify-webhook-id"),
│   │               "api_version": headers.get("x-shopify-api-version"),
│   │               "triggered_at": headers.get("x-shopify-triggered-at"),
│   │           }
│   │   
│   │           return WebhookData(
│   │               topic=topic,
│   │               merchant_id=merchant_id,
│   │               merchant_domain=merchant_domain,
│   │               idempotency_key=idempotency_key,
│   │               payload=body,
│   │               metadata={k: v for k, v in metadata.items() if v},
│   │           )
│   │   
│   │       def get_idempotency_key(
│   │           self, body: Dict[str, Any], topic: str, headers: Dict[str, str]
│   │       ) -> str:
│   │           """Generate idempotency key for Shopify webhook"""
│   │   
│   │           # Use webhook ID if available
│   │           webhook_id = headers.get("x-shopify-webhook-id")
│   │           if webhook_id:
│   │               return f"shopify:{webhook_id}"
│   │   
│   │           # Fallback to hash of key components
│   │           merchant_domain = headers.get("x-shopify-shop-domain", "")
│   │   
│   │           # For orders/products, use their ID
│   │           if "id" in body:
│   │               key_parts = f"shopify:{topic}:{merchant_domain}:{body['id']}"
│   │           else:
│   │               # Hash the entire payload as last resort
│   │               payload_hash = hashlib.sha256(str(body).encode()).hexdigest()[:16]
│   │               key_parts = f"shopify:{topic}:{merchant_domain}:{payload_hash}"
│   │   
│   │           return hashlib.sha256(key_parts.encode()).hexdigest()
│   │   
│   │       def map_to_domain_event(self, webhook_data: WebhookData) -> Optional[DomainEvent]:
│   │           """Map Shopify webhook to domain event"""
│   │   
│   │           subject = self.TOPIC_EVENT_MAP.get(webhook_data.topic)
│   │           if not subject:
│   │               self.logger.debug(
│   │                   f"No domain event mapping for topic: {webhook_data.topic}"
│   │               )
│   │               return None
│   │   
│   │           # Build event payload based on topic
│   │           payload = self._build_event_payload(
│   │               webhook_data.topic,
│   │               webhook_data.payload,
│   │               webhook_data.merchant_id,
│   │               webhook_data.merchant_domain,
│   │           )
│   │   
│   │           return DomainEvent(subject=subject, payload=payload)
│   │   
│   │       def _build_event_payload(
│   │           self,
│   │           topic: str,
│   │           webhook_payload: Dict[str, Any],
│   │           merchant_id: Optional[str],
│   │           merchant_domain: Optional[str],
│   │       ) -> Dict[str, Any]:
│   │           """Build domain event payload based on topic"""
│   │   
│   │           base_payload = {
│   │               "merchant_id": merchant_id,
│   │               "merchant_domain": merchant_domain,
│   │               "timestamp": datetime.utcnow().isoformat(),
│   │           }
│   │   
│   │           # App lifecycle events
│   │           if topic == "app/uninstalled":
│   │               return {**base_payload}
│   │   
│   │           elif topic == "app_subscriptions/update":
│   │               subscription = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "subscription_id": str(subscription.get("id")),
│   │                   "status": subscription.get("status"),
│   │                   "plan": subscription.get("name"),
│   │                   "trial_ends_at": subscription.get("trial_ends_on"),
│   │               }
│   │   
│   │           # Product events
│   │           elif topic.startswith("products/"):
│   │               product = webhook_payload
│   │               payload = {
│   │                   **base_payload,
│   │                   "item_id": str(product.get("id")),
│   │                   "external_id": str(product.get("id")),
│   │                   "title": product.get("title"),
│   │                   "vendor": product.get("vendor"),
│   │                   "product_type": product.get("product_type"),
│   │                   "status": product.get("status"),
│   │               }
│   │   
│   │               if topic == "products/update":
│   │                   payload["changes"] = ["data"]  # Would need previous state
│   │   
│   │               return payload
│   │   
│   │           # Order events
│   │           elif topic.startswith("orders/"):
│   │               order = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "order_id": str(order.get("id")),
│   │                   "order_number": order.get("order_number"),
│   │                   "total": order.get("total_price"),
│   │                   "currency": order.get("currency"),
│   │                   "financial_status": order.get("financial_status"),
│   │                   "fulfillment_status": order.get("fulfillment_status"),
│   │                   "customer_id": str(order.get("customer", {}).get("id", "")),
│   │                   "items": [
│   │                       {
│   │                           "item_id": str(item.get("product_id")),
│   │                           "variant_id": str(item.get("variant_id")),
│   │                           "quantity": item.get("quantity"),
│   │                           "price": item.get("price"),
│   │                       }
│   │                       for item in order.get("line_items", [])
│   │                   ],
│   │               }
│   │   
│   │           # Default fallback
│   │           return {**base_payload, "data": webhook_payload}
│   │   ```
│   │   
│   ├── shopify.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/handlers/shopify.py
│   │   """Shopify webhook handler."""
│   │   
│   │   import hashlib
│   │   from typing import Dict, Any, Optional
│   │   from datetime import datetime
│   │   
│   │   from .base import WebhookHandler, WebhookData, DomainEvent
│   │   
│   │   
│   │   class ShopifyWebhookHandler(WebhookHandler):
│   │       """Handler for Shopify webhooks"""
│   │   
│   │       # Topic to domain event mapping
│   │       TOPIC_EVENT_MAP = {
│   │           # App lifecycle
│   │           "app/uninstalled": "evt.webhook.app.uninstalled",
│   │           "app_subscriptions/update": "evt.webhook.app.subscription_updated",
│   │           "app_purchases_one_time/update": "evt.webhook.app.purchase_updated",
│   │           # Catalog
│   │           "products/create": "evt.webhook.catalog.item_created",
│   │           "products/update": "evt.webhook.catalog.item_updated",
│   │           "products/delete": "evt.webhook.catalog.item_deleted",
│   │           # Orders
│   │           "orders/create": "evt.webhook.order.created",
│   │           "orders/updated": "evt.webhook.order.updated",
│   │           "orders/fulfilled": "evt.webhook.order.fulfilled",
│   │           "orders/cancelled": "evt.webhook.order.cancelled",
│   │           # Inventory
│   │           "inventory_levels/update": "evt.webhook.inventory.updated",
│   │           "inventory_items/update": "evt.webhook.inventory.item_updated",
│   │           # Compliance (no domain events)
│   │           "customers/data_request": None,
│   │           "customers/redact": None,
│   │           "shop/redact": None,
│   │       }
│   │   
│   │       def parse_webhook(
│   │           self, body: Dict[str, Any], topic: Optional[str], headers: Dict[str, str]
│   │       ) -> WebhookData:
│   │           """Parse Shopify webhook"""
│   │   
│   │           # Get topic from header if not in path
│   │           if not topic:
│   │               topic = headers.get("x-shopify-topic", "unknown")
│   │   
│   │           # Extract shop info
│   │           merchant_domain = headers.get("x-shopify-shop-domain", "")
│   │           merchant_id = merchant_domain.split(".")[0] if merchant_domain else None
│   │   
│   │           # Generate idempotency key
│   │           idempotency_key = self.get_idempotency_key(body, topic, headers)
│   │   
│   │           # Build metadata
│   │           metadata = {
│   │               "webhook_id": headers.get("x-shopify-webhook-id"),
│   │               "api_version": headers.get("x-shopify-api-version"),
│   │               "triggered_at": headers.get("x-shopify-triggered-at"),
│   │           }
│   │   
│   │           return WebhookData(
│   │               topic=topic,
│   │               merchant_id=merchant_id,
│   │               merchant_domain=merchant_domain,
│   │               idempotency_key=idempotency_key,
│   │               payload=body,
│   │               metadata={k: v for k, v in metadata.items() if v},
│   │           )
│   │   
│   │       def get_idempotency_key(
│   │           self, body: Dict[str, Any], topic: str, headers: Dict[str, str]
│   │       ) -> str:
│   │           """Generate idempotency key for Shopify webhook"""
│   │   
│   │           # Use webhook ID if available
│   │           webhook_id = headers.get("x-shopify-webhook-id")
│   │           if webhook_id:
│   │               return f"shopify:{webhook_id}"
│   │   
│   │           # Fallback to hash of key components
│   │           merchant_domain = headers.get("x-shopify-shop-domain", "")
│   │   
│   │           # For orders/products, use their ID
│   │           if "id" in body:
│   │               key_parts = f"shopify:{topic}:{merchant_domain}:{body['id']}"
│   │           else:
│   │               # Hash the entire payload as last resort
│   │               payload_hash = hashlib.sha256(str(body).encode()).hexdigest()[:16]
│   │               key_parts = f"shopify:{topic}:{merchant_domain}:{payload_hash}"
│   │   
│   │           return hashlib.sha256(key_parts.encode()).hexdigest()
│   │   
│   │       def map_to_domain_event(self, webhook_data: WebhookData) -> Optional[DomainEvent]:
│   │           """Map Shopify webhook to domain event"""
│   │   
│   │           subject = self.TOPIC_EVENT_MAP.get(webhook_data.topic)
│   │           if not subject:
│   │               self.logger.debug(
│   │                   f"No domain event mapping for topic: {webhook_data.topic}"
│   │               )
│   │               return None
│   │   
│   │           # Build event payload based on topic
│   │           payload = self._build_event_payload(
│   │               webhook_data.topic,
│   │               webhook_data.payload,
│   │               webhook_data.merchant_id,
│   │               webhook_data.merchant_domain,
│   │           )
│   │   
│   │           return DomainEvent(subject=subject, payload=payload)
│   │   
│   │       def _build_event_payload(
│   │           self,
│   │           topic: str,
│   │           webhook_payload: Dict[str, Any],
│   │           merchant_id: Optional[str],
│   │           merchant_domain: Optional[str],
│   │       ) -> Dict[str, Any]:
│   │           """Build domain event payload based on topic"""
│   │   
│   │           base_payload = {
│   │               "merchant_id": merchant_id,
│   │               "merchant_domain": merchant_domain,
│   │               "timestamp": datetime.utcnow().isoformat(),
│   │           }
│   │   
│   │           # App lifecycle events
│   │           if topic == "app/uninstalled":
│   │               return {**base_payload}
│   │   
│   │           elif topic == "app_subscriptions/update":
│   │               subscription = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "subscription_id": str(subscription.get("id")),
│   │                   "status": subscription.get("status"),
│   │                   "plan": subscription.get("name"),
│   │                   "trial_ends_at": subscription.get("trial_ends_on"),
│   │               }
│   │   
│   │           # Product events
│   │           elif topic.startswith("products/"):
│   │               product = webhook_payload
│   │               payload = {
│   │                   **base_payload,
│   │                   "item_id": str(product.get("id")),
│   │                   "external_id": str(product.get("id")),
│   │                   "title": product.get("title"),
│   │                   "vendor": product.get("vendor"),
│   │                   "product_type": product.get("product_type"),
│   │                   "status": product.get("status"),
│   │               }
│   │   
│   │               if topic == "products/update":
│   │                   # Add change detection (simplified)
│   │                   payload["changes"] = ["data"]  # Would need previous state
│   │   
│   │               return payload
│   │   
│   │           # Order events
│   │           elif topic.startswith("orders/"):
│   │               order = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "order_id": str(order.get("id")),
│   │                   "order_number": order.get("order_number"),
│   │                   "total": order.get("total_price"),
│   │                   "currency": order.get("currency"),
│   │                   "financial_status": order.get("financial_status"),
│   │                   "fulfillment_status": order.get("fulfillment_status"),
│   │                   "customer_id": str(order.get("customer", {}).get("id", "")),
│   │                   "items": [
│   │                       {
│   │                           "item_id": str(item.get("product_id")),
│   │                           "variant_id": str(item.get("variant_id")),
│   │                           "quantity": item.get("quantity"),
│   │                           "price": item.get("price"),
│   │                       }
│   │                       for item in order.get("line_items", [])
│   │                   ],
│   │               }
│   │   
│   │           # Inventory events
│   │           elif topic == "inventory_levels/update":
│   │               return {
│   │                   **base_payload,
│   │                   "item_id": str(webhook_payload.get("inventory_item_id")),
│   │                   "location_id": str(webhook_payload.get("location_id")),
│   │                   "available": webhook_payload.get("available"),
│   │                   "updated_at": webhook_payload.get("updated_at"),
│   │               }
│   │   
│   │           elif topic == "inventory_items/update":
│   │               item = webhook_payload
│   │               return {
│   │                   **base_payload,
│   │                   "item_id": str(item.get("id")),
│   │                   "sku": item.get("sku"),
│   │                   "tracked": item.get("tracked"),
│   │                   "requires_shipping": item.get("requires_shipping"),
│   │               }
│   │   
│   │           # Default fallback
│   │           return {**base_payload, "data": webhook_payload}
│   │   ```
│   │   
│   └── stripe.py
│       
│       ```py
│       # services/webhook-service/src/handlers/stripe.py
│       """Stripe webhook handler."""
│       
│       import hashlib
│       from typing import Dict, Any, Optional
│       
│       from .base import WebhookHandler, WebhookData, DomainEvent
│       
│       
│       class StripeWebhookHandler(WebhookHandler):
│           """Handler for Stripe webhooks"""
│       
│           # Event type to domain event mapping
│           subject_MAP = {
│               # Payment events
│               "payment_intent.succeeded": "evt.webhook.payment.succeeded",
│               "payment_intent.failed": "evt.webhook.payment.failed",
│               # Subscription events
│               "customer.subscription.created": "evt.webhook.subscription.created",
│               "customer.subscription.updated": "evt.webhook.subscription.updated",
│               "customer.subscription.deleted": "evt.webhook.subscription.cancelled",
│               # Customer events
│               "customer.created": "evt.webhook.customer.created",
│               "customer.updated": "evt.webhook.customer.updated",
│           }
│       
│           def parse_webhook(
│               self, body: Dict[str, Any], topic: Optional[str], headers: Dict[str, str]
│           ) -> WebhookData:
│               """Parse Stripe webhook"""
│       
│               # Extract event type
│               subject = body.get("type", "unknown")
│               if topic and topic != subject:
│                   self.logger.warning(f"Topic mismatch: path={topic}, body={subject}")
│       
│               # Extract data
│               data = body.get("data", {}).get("object", {})
│       
│               # Get shop info from metadata if available
│               metadata = data.get("metadata", {})
│               merchant_id = metadata.get("merchant_id")
│               merchant_domain = metadata.get("merchant_domain")
│       
│               # Generate idempotency key
│               idempotency_key = self.get_idempotency_key(body, subject, headers)
│       
│               # Build metadata
│               webhook_metadata = {
│                   "event_id": body.get("id"),
│                   "api_version": body.get("api_version"),
│                   "created": body.get("created"),
│                   "livemode": body.get("livemode"),
│               }
│       
│               return WebhookData(
│                   topic=subject,
│                   merchant_id=merchant_id,
│                   merchant_domain=merchant_domain,
│                   idempotency_key=idempotency_key,
│                   payload=data,
│                   metadata=webhook_metadata,
│               )
│       
│           def get_idempotency_key(
│               self, body: Dict[str, Any], topic: str, headers: Dict[str, str]
│           ) -> str:
│               """Generate idempotency key for Stripe webhook"""
│       
│               # Use event ID
│               event_id = body.get("id")
│               if event_id:
│                   return f"stripe:{event_id}"
│       
│               # Fallback (shouldn't happen with valid Stripe events)
│               payload_hash = hashlib.sha256(str(body).encode()).hexdigest()[:16]
│       
│               return f"stripe:{topic}:{payload_hash}"
│       
│           def map_to_domain_event(self, webhook_data: WebhookData) -> Optional[DomainEvent]:
│               """Map Stripe webhook to domain event"""
│       
│               subject = self.subject_MAP.get(webhook_data.topic)
│               if not subject:
│                   self.logger.debug(
│                       f"No domain event mapping for Stripe event: {webhook_data.topic}"
│                   )
│                   return None
│       
│               # Build event payload
│               payload = self._build_event_payload(
│                   webhook_data.topic,
│                   webhook_data.payload,
│                   webhook_data.merchant_id,
│                   webhook_data.merchant_domain,
│               )
│       
│               return DomainEvent(subject=subject, payload=payload)
│       
│           def _build_event_payload(
│               self,
│               subject: str,
│               stripe_data: Dict[str, Any],
│               merchant_id: Optional[str],
│               merchant_domain: Optional[str],
│           ) -> Dict[str, Any]:
│               """Build domain event payload for Stripe events"""
│       
│               base_payload = {
│                   "merchant_id": merchant_id,
│                   "merchant_domain": merchant_domain,
│                   "stripe_object_id": stripe_data.get("id"),
│                   "created": stripe_data.get("created"),
│               }
│       
│               # Payment events
│               if subject.startswith("payment_intent."):
│                   return {
│                       **base_payload,
│                       "payment_intent_id": stripe_data.get("id"),
│                       "amount": stripe_data.get("amount"),
│                       "currency": stripe_data.get("currency"),
│                       "status": stripe_data.get("status"),
│                       "customer_id": stripe_data.get("customer"),
│                   }
│       
│               # Subscription events
│               elif subject.startswith("customer.subscription."):
│                   return {
│                       **base_payload,
│                       "subscription_id": stripe_data.get("id"),
│                       "customer_id": stripe_data.get("customer"),
│                       "status": stripe_data.get("status"),
│                       "plan_id": stripe_data.get("items", {})
│                       .get("data", [{}])[0]
│                       .get("price", {})
│                       .get("id"),
│                       "current_period_end": stripe_data.get("current_period_end"),
│                   }
│       
│               # Customer events
│               elif subject.startswith("customer."):
│                   return {
│                       **base_payload,
│                       "customer_id": stripe_data.get("id"),
│                       "email": stripe_data.get("email"),
│                       "name": stripe_data.get("name"),
│                   }
│       
│               # Default
│               return {**base_payload, "data": stripe_data}
│       ```
│       
├── mappers/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/mappers/__init__.py
│   │   """Mappers for webhook service."""
│   │   
│   │   from .webhook_entry_mapper import WebhookEntryMapper
│   │   
│   │   __all__ = [
│   │       "WebhookEntryMapper",
│   │   ]
│   │   ```
│   │   
│   └── webhook_entry_mapper.py
│       
│       ```py
│       # services/webhook-service/src/mappers/webhook_entry_mapper.py
│       """Mapper for webhook entry model to response schemas."""
│       
│       from __future__ import annotations
│       
│       from typing import List
│       from uuid import UUID
│       
│       from shared.mappers.base import BaseMapper
│       
│       from ..models.webhook_entry import WebhookEntry
│       from ..schemas.webhook import WebhookEntryResponse, CreateWebhookSchema
│       
│       
│       class WebhookEntryMapper(BaseMapper[WebhookEntry, CreateWebhookSchema, None, WebhookEntryResponse]): #type: ignore
│           """Mapper for webhook entry operations."""
│           
│           
│           def create_to_model(self, create_schema: CreateWebhookSchema, **kwargs) -> WebhookEntry:
│               """Convert create schema to webhook entry model."""
│               webhook_entry_data = WebhookEntry(
│                   id=UUID(),
│                   platform=create_schema.platform,
│                   topic=create_schema.topic,
│                   shop_id=create_schema.shop_id,
│                   status=create_schema.status,
│                   attempts=create_schema.attempts,
│                   error=create_schema.error,
│                   received_at=create_schema.received_at,
│                   processed_at=create_schema.processed_at,
│               )
│               return webhook_entry_data
│       
│           def model_to_response(self, model: WebhookEntry) -> WebhookEntryResponse:
│               """Convert webhook entry model to response schema."""
│               return WebhookEntryResponse(
│                   id=model.id,
│                   platform=model.platform,
│                   topic=model.topic,
│                   shop_id=model.shop_id,
│                   status=model.status,
│                   attempts=model.attempts,
│                   error=model.error,
│                   received_at=model.received_at,
│                   processed_at=model.processed_at,
│                   created_at=model.created_at,
│                   updated_at=model.updated_at
│               )
│       
│           def to_response_list(self, models: List[WebhookEntry]) -> List[WebhookEntryResponse]:
│               """Convert list of webhook entries to response schemas."""
│               return [self.model_to_response(model) for model in models]
│           
│           
│       ```
│       
├── models/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/models/__init__.py
│   │   """Models for webhook service."""
│   │   
│   │   from .webhook_entry import WebhookEntry, WebhookStatus
│   │   from .platform_configuration import PlatformConfiguration
│   │   
│   │   __all__ = [
│   │       "WebhookEntry",
│   │       "WebhookStatus", 
│   │       "PlatformConfiguration",
│   │   ]
│   │   ```
│   │   
│   ├── platform_configuration.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/models/platform_configuration.py
│   │   """Platform configuration database model."""
│   │   
│   │   from __future__ import annotations
│   │   
│   │   from datetime import datetime
│   │   from typing import Dict, Any
│   │   from uuid import UUID, uuid4
│   │   
│   │   from sqlalchemy import String, Text, Boolean, JSON, DateTime
│   │   from sqlalchemy.orm import Mapped, mapped_column
│   │   
│   │   from shared.database.base import Base, TimestampedMixin
│   │   
│   │   
│   │   class PlatformConfiguration(Base, TimestampedMixin):
│   │       """
│   │       Platform configuration model for storing webhook platform settings.
│   │       """
│   │       
│   │       __tablename__ = "platform_configurations"
│   │       
│   │       id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid4)
│   │       platform: Mapped[str] = mapped_column(String(50), nullable=False, unique=True, index=True)
│   │       webhook_secret: Mapped[str] = mapped_column(Text, nullable=False)  # Should be encrypted
│   │       api_version: Mapped[str] = mapped_column(String(20), nullable=False)
│   │       active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)
│   │       endpoints: Mapped[Dict[str, Any]] = mapped_column(JSON, nullable=False, default=dict)
│   │       
│   │       def __repr__(self) -> str:
│   │           return f"<PlatformConfiguration(id={self.id}, platform={self.platform}, active={self.active})>"
│   │   ```
│   │   
│   └── webhook_entry.py
│       
│       ```py
│       # services/webhook-service/src/models/webhook_entry.py
│       """Webhook entry database model."""
│       
│       from __future__ import annotations
│       
│       import enum
│       from datetime import datetime
│       from typing import Optional, Dict, Any
│       from uuid import UUID, uuid4
│       
│       from sqlalchemy import String, Text, Integer, DateTime, Enum as SQLEnum, JSON
│       from sqlalchemy.orm import Mapped, mapped_column
│       
│       from shared.database.base import Base, TimestampedMixin
│       
│       
│       class WebhookStatus(enum.Enum):
│           """Webhook processing status"""
│           RECEIVED = "received"
│           PROCESSING = "processing"
│           PROCESSED = "processed"
│           FAILED = "failed"
│       
│       
│       class WebhookEntry(Base, TimestampedMixin):
│           """
│           Webhook entry model for storing webhook data and processing status.
│           """
│           
│           __tablename__ = "webhook_entries"
│           
│           id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid4)
│           platform: Mapped[str] = mapped_column(String(50), nullable=False, index=True)
│           topic: Mapped[str] = mapped_column(String(100), nullable=False, index=True)
│           shop_id: Mapped[str] = mapped_column(String(100), nullable=False, index=True)
│           payload: Mapped[Dict[str, Any]] = mapped_column(JSON, nullable=False)
│           headers: Mapped[Dict[str, str]] = mapped_column(JSON, nullable=False)
│           signature: Mapped[str] = mapped_column(Text, nullable=False)
│           status: Mapped[WebhookStatus] = mapped_column(
│               SQLEnum(WebhookStatus), 
│               nullable=False, 
│               default=WebhookStatus.RECEIVED,
│               index=True
│           )
│           attempts: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
│           error: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
│           received_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, default=datetime.utcnow)
│           processed_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
│           
│           def __repr__(self) -> str:
│               return f"<WebhookEntry(id={self.id}, platform={self.platform}, topic={self.topic}, status={self.status.value})>"
│       
│       ```
│       
├── repositories/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/repositories/__init__.py
│   │   """Repositories for webhook service."""
│   │   
│   │   from .webhook_entry_repository import WebhookEntryRepository
│   │   from .platform_configuration_repository import PlatformConfigurationRepository
│   │   
│   │   __all__ = [
│   │       "WebhookEntryRepository",
│   │       "PlatformConfigurationRepository",
│   │   ]
│   │   
│   │   ```
│   │   
│   ├── platform_configuration_repository.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/repositories/platform_configuration_repository.py
│   │   """Repository for platform configuration operations."""
│   │   
│   │   from __future__ import annotations
│   │   
│   │   from typing import Optional, List
│   │   
│   │   from sqlalchemy import select
│   │   from sqlalchemy.ext.asyncio import AsyncSession
│   │   
│   │   from shared.database.repository import Repository
│   │   
│   │   from ..models.platform_configuration import PlatformConfiguration
│   │   
│   │   
│   │   class PlatformConfigurationRepository(Repository[PlatformConfiguration]):
│   │       """Repository for platform configuration CRUD operations."""
│   │       
│   │       model = PlatformConfiguration
│   │       
│   │       async def find_by_platform(
│   │           self,
│   │           session: AsyncSession,
│   │           platform: str
│   │       ) -> Optional[PlatformConfiguration]:
│   │           """Find platform configuration by platform name."""
│   │           
│   │           stmt = select(self.model).where(self.model.platform == platform)
│   │           result = await session.execute(stmt)
│   │           return result.scalar_one_or_none()
│   │       
│   │       async def find_active_platforms(
│   │           self,
│   │           session: AsyncSession
│   │       ) -> List[PlatformConfiguration]:
│   │           """Find all active platform configurations."""
│   │           
│   │           stmt = (
│   │               select(self.model)
│   │               .where(self.model.active == True)
│   │               .order_by(self.model.platform)
│   │           )
│   │           
│   │           result = await session.execute(stmt)
│   │           return list(result.scalars().all())
│   │   ```
│   │   
│   └── webhook_entry_repository.py
│       
│       ```py
│       # services/webhook-service/src/repositories/webhook_entry_repository.py
│       """Repository for webhook entry operations."""
│       
│       from __future__ import annotations
│       
│       from typing import Optional, List
│       from uuid import UUID
│       from datetime import datetime
│       
│       from sqlalchemy import select, and_
│       from sqlalchemy.ext.asyncio import AsyncSession
│       
│       from shared.database.repository import Repository
│       
│       from ..models.webhook_entry import WebhookEntry, WebhookStatus
│       
│       
│       class WebhookEntryRepository(Repository[WebhookEntry]):
│           """Repository for webhook entry CRUD operations."""
│           
│           model = WebhookEntry
│           
│           async def find_by_platform_and_shop(
│               self,
│               session: AsyncSession,
│               platform: str,
│               shop_id: str,
│               limit: int = 100
│           ) -> List[WebhookEntry]:
│               """Find webhook entries by platform and shop ID."""
│               
│               stmt = (
│                   select(self.model)
│                   .where(
│                       and_(
│                           self.model.platform == platform,
│                           self.model.shop_id == shop_id
│                       )
│                   )
│                   .order_by(self.model.received_at.desc())
│                   .limit(limit)
│               )
│               
│               result = await session.execute(stmt)
│               return list(result.scalars().all())
│           
│           async def find_by_status(
│               self,
│               session: AsyncSession,
│               status: WebhookStatus,
│               limit: int = 100
│           ) -> List[WebhookEntry]:
│               """Find webhook entries by status."""
│               
│               stmt = (
│                   select(self.model)
│                   .where(self.model.status == status)
│                   .order_by(self.model.received_at.desc())
│                   .limit(limit)
│               )
│               
│               result = await session.execute(stmt)
│               return list(result.scalars().all())
│           
│           async def find_failed_webhooks(
│               self,
│               session: AsyncSession,
│               max_attempts: int = 3,
│               limit: int = 100
│           ) -> List[WebhookEntry]:
│               """Find failed webhook entries that haven't exceeded max attempts."""
│               
│               stmt = (
│                   select(self.model)
│                   .where(
│                       and_(
│                           self.model.status == WebhookStatus.FAILED,
│                           self.model.attempts < max_attempts
│                       )
│                   )
│                   .order_by(self.model.received_at.desc())
│                   .limit(limit)
│               )
│               
│               result = await session.execute(stmt)
│               return list(result.scalars().all())
│           
│           async def update_status(
│               self,
│               session: AsyncSession,
│               webhook_id: UUID,
│               status: WebhookStatus,
│               error: Optional[str] = None,
│               processed_at: Optional[datetime] = None
│           ) -> Optional[WebhookEntry]:
│               """Update webhook entry status."""
│               
│               webhook_entry = await self.find_by_id(session, webhook_id)
│               if not webhook_entry:
│                   return None
│               
│               webhook_entry.status = status
│               webhook_entry.attempts += 1
│               
│               if error:
│                   webhook_entry.error = error
│               
│               if processed_at:
│                   webhook_entry.processed_at = processed_at
│               elif status == WebhookStatus.PROCESSED:
│                   webhook_entry.processed_at = datetime.utcnow()
│               
│               await session.commit()
│               await session.refresh(webhook_entry)
│               return webhook_entry
│       ```
│       
├── schemas/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/schemas/__init__.py
│   │   """Schemas for webhook service."""
│   │   
│   │   from .webhook import (
│   │       WebhookRequest,
│   │       WebhookResponse,
│   │       ShopifyWebhookHeaders,
│   │       WebhookEntryResponse,
│   │       WebhookListResponse
│   │   )
│   │   
│   │   __all__ = [
│   │       "WebhookRequest",
│   │       "WebhookResponse", 
│   │       "ShopifyWebhookHeaders",
│   │       "WebhookEntryResponse",
│   │       "WebhookListResponse",
│   │   ]
│   │   ```
│   │   
│   └── webhook.py
│       
│       ```py
│       # services/webhook-service/src/schemas/webhook.py
│       """Webhook-related request/response schemas"""
│       
│       from pydantic import BaseModel, Field
│       from typing import Dict, List, Optional, Any
│       from datetime import datetime
│       from uuid import UUID
│       
│       from ..models.webhook_entry import WebhookStatus
│       
│       
│       class CreateWebhookSchema(BaseModel):
│           id: UUID = Field(default_factory=UUID, description="Unique identifier for the webhook entry")
│           platform: str = Field(..., description="Platform for which the webhook is created")
│           topic: str = Field(..., description="Webhook topic (e.g., 'orders/create')")
│           shop_id: str = Field(..., description="Shop identifier where the webhook is registered")
│           status: WebhookStatus = Field(..., description="Current status of the webhook entry")
│           attempts: int = Field(0, description="Number of processing attempts")
│           error: Optional[str] = Field(None, description="Error message if processing failed")
│           received_at: datetime = Field(default_factory=datetime.utcnow, description="When the webhook was received")
│           processed_at: Optional[datetime] = Field(None, description="When the webhook was processed")
│       
│       class ShopifyWebhookHeaders(BaseModel):
│           """Expected headers for Shopify webhooks"""
│           
│           x_shopify_topic: str = Field(..., alias="X-Shopify-Topic")
│           x_shopify_hmac_sha256: str = Field(..., alias="X-Shopify-Hmac-Sha256")
│           x_shopify_shop_domain: str = Field(..., alias="X-Shopify-Shop-Domain")
│           x_shopify_api_version: str = Field(..., alias="X-Shopify-API-Version")
│           x_shopify_webhook_id: str = Field(..., alias="X-Shopify-Webhook-Id")
│       
│       
│       class WebhookRequest(BaseModel):
│           """Generic webhook request body"""
│           
│           data: Dict[str, Any] = Field(..., description="Webhook payload data")
│           
│           class Config:
│               json_schema_extra = {
│                   "example": {
│                       "data": {
│                           "id": 12345,
│                           "shop_domain": "example-shop.myshopify.com",
│                           "created_at": "2025-01-15T10:00:00Z"
│                       }
│                   }
│               }
│       
│       
│       class WebhookResponse(BaseModel):
│           """Webhook processing response"""
│           
│           success: bool = Field(..., description="Whether webhook was processed successfully")
│           webhook_id: UUID = Field(..., description="Internal webhook entry ID")
│           message: str = Field(..., description="Processing result message")
│           
│           class Config:
│               json_schema_extra = {
│                   "example": {
│                       "success": True,
│                       "webhook_id": "550e8400-e29b-41d4-a716-446655440000",
│                       "message": "Webhook processed successfully"
│                   }
│               }
│       
│       
│       class WebhookEntryResponse(BaseModel):
│           """Webhook entry response schema"""
│           
│           id: UUID
│           platform: str
│           topic: str
│           shop_id: str
│           status: WebhookStatus
│           attempts: int
│           error: Optional[str] = None
│           received_at: datetime
│           processed_at: Optional[datetime] = None
│           created_at: datetime
│           updated_at: datetime
│           
│           class Config:
│               from_attributes = True
│       
│       
│       class WebhookListResponse(BaseModel):
│           """Paginated list of webhook entries"""
│           
│           webhooks: List[WebhookEntryResponse]
│           total: int
│           page: int
│           limit: int
│           has_next: bool
│           has_previous: bool
│       ```
│       
├── services/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/services/__init__.py
│   │   """Services for webhook service."""
│   │   
│   │   from .webhook_service import WebhookService
│   │   from .platform_handler_service import PlatformHandlerService
│   │   
│   │   __all__ = [
│   │       "WebhookService",
│   │       "PlatformHandlerService",
│   │   ]
│   │   ```
│   │   
│   ├── platform_handler_service.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/services/platform_handler_service.py
│   │   """Platform-specific webhook handling service."""
│   │   
│   │   from __future__ import annotations
│   │   
│   │   import hmac
│   │   import hashlib
│   │   import base64
│   │   from typing import Dict, Any, Optional
│   │   from abc import ABC, abstractmethod
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   
│   │   from ..config import WebhookServiceConfig
│   │   
│   │   
│   │   class WebhookHandler(ABC):
│   │       """Abstract base class for platform-specific webhook handlers."""
│   │       
│   │       @abstractmethod
│   │       def validate_signature(self, body: bytes, headers: Dict[str, str]) -> bool:
│   │           """Validate webhook signature."""
│   │           pass
│   │       
│   │       @abstractmethod
│   │       def parse_webhook(self, body: Dict[str, Any], topic: str) -> Dict[str, Any]:
│   │           """Parse webhook payload."""
│   │           pass
│   │       
│   │       @abstractmethod
│   │       def get_shop_id(self, body: Dict[str, Any]) -> str:
│   │           """Extract shop ID from webhook payload."""
│   │           pass
│   │   
│   │   
│   │   class ShopifyWebhookHandler(WebhookHandler):
│   │       """Handler for Shopify webhooks."""
│   │       
│   │       def __init__(self, webhook_secret: str):
│   │           self.webhook_secret = webhook_secret
│   │       
│   │       def validate_signature(self, body: bytes, headers: Dict[str, str]) -> bool:
│   │           """Validate Shopify HMAC signature."""
│   │           
│   │           signature = headers.get("X-Shopify-Hmac-Sha256")
│   │           if not signature:
│   │               return False
│   │           
│   │           calculated = hmac.new(
│   │               self.webhook_secret.encode('utf-8'),
│   │               body,
│   │               hashlib.sha256
│   │           ).digest()
│   │           expected = base64.b64encode(calculated).decode()
│   │           
│   │           return hmac.compare_digest(expected, signature)
│   │       
│   │       def parse_webhook(self, body: Dict[str, Any], topic: str) -> Dict[str, Any]:
│   │           """Parse Shopify webhook payload."""
│   │           return body  # Shopify sends clean JSON
│   │       
│   │       def get_shop_id(self, body: Dict[str, Any]) -> str:
│   │           """Extract shop ID from Shopify payload."""
│   │           
│   │           # Try different possible shop identifier fields
│   │           for field in ["shop_domain", "domain", "myshopify_domain"]:
│   │               if field in body:
│   │                   return str(body[field])
│   │           
│   │           # Try nested shop object
│   │           if "shop" in body and isinstance(body["shop"], dict):
│   │               shop = body["shop"]
│   │               for field in ["domain", "myshopify_domain", "id"]:
│   │                   if field in shop:
│   │                       return str(shop[field])
│   │           
│   │           # Fallback to a default value
│   │           return "unknown"
│   │   
│   │   
│   │   class PlatformHandlerService:
│   │       """Service for managing platform-specific webhook handlers."""
│   │       
│   │       def __init__(self, config: WebhookServiceConfig, logger: ServiceLogger):
│   │           self.config = config
│   │           self.logger = logger
│   │           self._handlers: Dict[str, WebhookHandler] = {}
│   │           
│   │           # Initialize platform handlers
│   │           self._initialize_handlers()
│   │       
│   │       def _initialize_handlers(self) -> None:
│   │           """Initialize platform-specific handlers."""
│   │           
│   │           # Shopify handler
│   │           if self.config.shopify_webhook_secret:
│   │               self._handlers["shopify"] = ShopifyWebhookHandler(
│   │                   webhook_secret=self.config.shopify_webhook_secret
│   │               )
│   │               self.logger.info("Shopify webhook handler initialized")
│   │       
│   │       def get_handler(self, platform: str) -> Optional[WebhookHandler]:
│   │           """Get handler for specific platform."""
│   │           return self._handlers.get(platform)
│   │       
│   │       def validate_webhook(
│   │           self,
│   │           platform: str,
│   │           body: bytes,
│   │           headers: Dict[str, str]
│   │       ) -> bool:
│   │           """Validate webhook signature for platform."""
│   │           
│   │           handler = self.get_handler(platform)
│   │           if not handler:
│   │               self.logger.warning(f"No handler found for platform: {platform}")
│   │               return False
│   │           
│   │           try:
│   │               return handler.validate_signature(body, headers)
│   │           except Exception as e:
│   │               self.logger.error(f"Signature validation failed for {platform}: {e}")
│   │               return False
│   │       
│   │       def parse_webhook(
│   │           self,
│   │           platform: str,
│   │           body: Dict[str, Any],
│   │           topic: str
│   │       ) -> Optional[Dict[str, Any]]:
│   │           """Parse webhook payload for platform."""
│   │           
│   │           handler = self.get_handler(platform)
│   │           if not handler:
│   │               self.logger.warning(f"No handler found for platform: {platform}")
│   │               return None
│   │           
│   │           try:
│   │               return handler.parse_webhook(body, topic)
│   │           except Exception as e:
│   │               self.logger.error(f"Webhook parsing failed for {platform}: {e}")
│   │               return None
│   │       
│   │       def get_shop_id(
│   │           self,
│   │           platform: str,
│   │           body: Dict[str, Any]
│   │       ) -> Optional[str]:
│   │           """Get shop ID from webhook payload."""
│   │           
│   │           handler = self.get_handler(platform)
│   │           if not handler:
│   │               self.logger.warning(f"No handler found for platform: {platform}")
│   │               return None
│   │           
│   │           try:
│   │               return handler.get_shop_id(body)
│   │           except Exception as e:
│   │               self.logger.error(f"Shop ID extraction failed for {platform}: {e}")
│   │               return None
│   │   ```
│   │   
│   └── webhook_service.py
│       
│       ```py
│       # services/webhook-service/src/services/webhook_service.py
│       """Core webhook processing service."""
│       
│       from __future__ import annotations
│       
│       import json
│       import hashlib
│       from typing import Optional, Dict, Any
│       from uuid import UUID
│       from datetime import datetime, timedelta
│       
│       import redis.asyncio as redis
│       from sqlalchemy.ext.asyncio import AsyncSession
│       
│       from shared.utils.logger import ServiceLogger
│       from shared.database.dependencies import get_db_session
│       
│       from ..config import WebhookServiceConfig
│       from ..models.webhook_entry import WebhookEntry, WebhookStatus
│       from ..repositories.webhook_entry_repository import WebhookEntryRepository
│       from ..repositories.platform_configuration_repository import PlatformConfigurationRepository
│       from ..events.publishers import WebhookEventPublisher
│       from ..events.domain_events import (
│           AppUninstalledEvent,
│           CatalogItemCreatedEvent,
│           OrderCreatedEvent,
│           InventoryUpdatedEvent
│       )
│       
│       
│       class WebhookService:
│           """Core service for webhook processing."""
│           
│           def __init__(
│               self,
│               webhook_entry_repo: WebhookEntryRepository,
│               platform_config_repo: PlatformConfigurationRepository,
│               redis_client: redis.Redis,
│               publisher: WebhookEventPublisher,
│               config: WebhookServiceConfig,
│               logger: ServiceLogger
│           ):
│               self.webhook_entry_repo = webhook_entry_repo
│               self.platform_config_repo = platform_config_repo
│               self.redis_client = redis_client
│               self.publisher = publisher
│               self.config = config
│               self.logger = logger
│           
│           async def process_webhook(
│               self,
│               platform: str,
│               topic: str,
│               payload: Dict[str, Any],
│               headers: Dict[str, str],
│               signature: str
│           ) -> WebhookEntry:
│               """
│               Process an incoming webhook.
│               
│               Returns:
│                   WebhookEntry: The created webhook entry
│               """
│               
│               # Extract shop ID from payload
│               shop_id = self._extract_shop_id(platform, payload)
│               
│               # Check for duplicates
│               webhook_id = self._generate_webhook_id(platform, topic, shop_id, payload)
│               if await self._is_duplicate(webhook_id):
│                   self.logger.info(
│                       f"Duplicate webhook detected",
│                       extra={
│                           "platform": platform,
│                           "topic": topic,
│                           "shop_id": shop_id,
│                           "webhook_id": webhook_id
│                       }
│                   )
│                   # Return existing webhook entry or create a dummy one
│                   # For now, we'll create a new entry but mark it as duplicate in logs
│               
│               # Create webhook entry
│               async with get_db_session() as session:
│                   webhook_entry = WebhookEntry(
│                       platform=platform,
│                       topic=topic,
│                       shop_id=shop_id,
│                       payload=payload,
│                       headers=headers,
│                       signature=signature,
│                       status=WebhookStatus.RECEIVED,
│                       received_at=datetime.utcnow()
│                   )
│                   
│                   await self.webhook_entry_repo.create(session, webhook_entry)
│                   
│                   try:
│                       # Mark as processing
│                       webhook_entry.status = WebhookStatus.PROCESSING
│                       await session.commit()
│                       
│                       # Transform and publish domain event
│                       domain_event = self._transform_to_domain_event(platform, topic, payload, shop_id)
│                       if domain_event:
│                           await self.publisher.publish_event(domain_event)
│                           self.logger.info(
│                               f"Domain event published",
│                               extra={
│                                   "subject": domain_event.subject,
│                                   "shop_id": shop_id,
│                                   "webhook_id": str(webhook_entry.id)
│                               }
│                           )
│                       
│                       # Mark as processed
│                       webhook_entry.status = WebhookStatus.PROCESSED
│                       webhook_entry.processed_at = datetime.utcnow()
│                       await session.commit()
│                       
│                       # Store in Redis for deduplication
│                       await self._store_for_deduplication(webhook_id)
│                       
│                       self.logger.info(
│                           f"Webhook processed successfully",
│                           extra={
│                               "platform": platform,
│                               "topic": topic,
│                               "shop_id": shop_id,
│                               "webhook_id": str(webhook_entry.id)
│                           }
│                       )
│                       
│                   except Exception as e:
│                       # Mark as failed
│                       webhook_entry.status = WebhookStatus.FAILED
│                       webhook_entry.error = str(e)
│                       await session.commit()
│                       
│                       self.logger.error(
│                           f"Webhook processing failed",
│                           extra={
│                               "platform": platform,
│                               "topic": topic,
│                               "shop_id": shop_id,
│                               "webhook_id": str(webhook_entry.id),
│                               "error": str(e)
│                           },
│                           exc_info=True
│                       )
│                       raise
│                   
│                   await session.refresh(webhook_entry)
│                   return webhook_entry
│           
│           def _extract_shop_id(self, platform: str, payload: Dict[str, Any]) -> str:
│               """Extract shop ID from webhook payload based on platform."""
│               
│               if platform == "shopify":
│                   # Try multiple possible shop identifier fields
│                   for field in ["shop_domain", "domain", "myshopify_domain"]:
│                       if field in payload:
│                           return str(payload[field])
│                   
│                   # Fallback: extract from nested objects
│                   if "shop" in payload and isinstance(payload["shop"], dict):
│                       for field in ["domain", "myshopify_domain", "id"]:
│                           if field in payload["shop"]:
│                               return str(payload["shop"][field])
│               
│               # Generic fallback
│               for field in ["shop_id", "store_id", "merchant_id", "account_id"]:
│                   if field in payload:
│                       return str(payload[field])
│               
│               # Ultimate fallback - use a hash of the payload
│               payload_str = json.dumps(payload, sort_keys=True)
│               return hashlib.md5(payload_str.encode()).hexdigest()[:16]
│           
│           def _generate_webhook_id(
│               self,
│               platform: str,
│               topic: str,
│               shop_id: str,
│               payload: Dict[str, Any]
│           ) -> str:
│               """Generate a unique ID for webhook deduplication."""
│               
│               # Try to use platform-specific webhook ID first
│               if platform == "shopify" and "id" in payload:
│                   return f"{platform}:{topic}:{shop_id}:{payload['id']}"
│               
│               # Fallback to hash-based ID
│               content = f"{platform}:{topic}:{shop_id}:{json.dumps(payload, sort_keys=True)}"
│               webhook_hash = hashlib.sha256(content.encode()).hexdigest()[:16]
│               return f"{platform}:{topic}:{shop_id}:{webhook_hash}"
│           
│           async def _is_duplicate(self, webhook_id: str) -> bool:
│               """Check if webhook has already been processed."""
│               
│               try:
│                   result = await self.redis_client.get(f"webhook:processed:{webhook_id}")
│                   return result is not None
│               except Exception as e:
│                   self.logger.warning(f"Redis deduplication check failed: {e}")
│                   return False
│           
│           async def _store_for_deduplication(self, webhook_id: str) -> None:
│               """Store webhook ID in Redis for deduplication."""
│               
│               try:
│                   ttl_seconds = self.config.webhook_dedup_ttl_hours * 3600
│                   await self.redis_client.setex(
│                       f"webhook:processed:{webhook_id}",
│                       ttl_seconds,
│                       "1"
│                   )
│               except Exception as e:
│                   self.logger.warning(f"Redis deduplication storage failed: {e}")
│           
│           def _transform_to_domain_event(
│               self,
│               platform: str,
│               topic: str,
│               payload: Dict[str, Any],
│               shop_id: str
│           ) -> Optional[Any]:
│               """Transform webhook payload to domain event."""
│               
│               if platform != "shopify":
│                   self.logger.info(f"No transformation available for platform: {platform}")
│                   return None
│               
│               # Shopify event transformations
│               if topic == "app/uninstalled":
│                   return AppUninstalledEvent.create(
│                       shop_id=shop_id,
│                       shop_domain=payload.get("domain", shop_id),
│                       timestamp=datetime.utcnow()
│                   )
│               
│               elif topic in ["products/create"]:
│                   return CatalogItemCreatedEvent.create(
│                       shop_id=shop_id,
│                       item_id=str(payload.get("id", "")),
│                       external_id=str(payload.get("id", ""))
│                   )
│               
│               elif topic == "orders/create":
│                   return OrderCreatedEvent.create(
│                       shop_id=shop_id,
│                       order_id=str(payload.get("id", "")),
│                       total=float(payload.get("total_price", 0.0)),
│                       items=payload.get("line_items", [])
│                   )
│               
│               elif topic == "inventory_levels/update":
│                   return InventoryUpdatedEvent.create(
│                       shop_id=shop_id,
│                       item_id=str(payload.get("inventory_item_id", "")),
│                       location_id=str(payload.get("location_id", "")),
│                       available=int(payload.get("available", 0))
│                   )
│               
│               else:
│                   self.logger.info(f"No transformation available for topic: {topic}")
│                   return None
│       ```
│       
├── utils/
│   ├── __init__.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/utils/__init__.py
│   │   """Utilities for webhook service."""
│   │   
│   │   from .deduplication import DeduplicationManager
│   │   from .signature_validator import SignatureValidator
│   │   
│   │   __all__ = [
│   │       "DeduplicationManager",
│   │       "SignatureValidator",
│   │   ]
│   │   ```
│   │   
│   ├── deduplication.py
│   │   
│   │   ```py
│   │   # services/webhook-service/src/utils/deduplication.py
│   │   """Deduplication utilities for webhook service."""
│   │   
│   │   import hashlib
│   │   import json
│   │   from typing import Dict, Any, Optional
│   │   from datetime import datetime, timedelta
│   │   
│   │   import redis.asyncio as redis
│   │   
│   │   from shared.utils.logger import ServiceLogger
│   │   
│   │   
│   │   class DeduplicationManager:
│   │       """Manages webhook deduplication using Redis."""
│   │       
│   │       def __init__(self, redis_client: redis.Redis, logger: ServiceLogger, ttl_hours: int = 24):
│   │           self.redis_client = redis_client
│   │           self.logger = logger
│   │           self.ttl_seconds = ttl_hours * 3600
│   │           self.key_prefix = "webhook:dedup"
│   │       
│   │       def generate_dedup_key(
│   │           self,
│   │           platform: str,
│   │           topic: str,
│   │           shop_id: str,
│   │           payload: Dict[str, Any],
│   │           webhook_id: Optional[str] = None
│   │       ) -> str:
│   │           """Generate deduplication key for webhook."""
│   │           
│   │           if webhook_id:
│   │               # Use platform-provided webhook ID if available
│   │               return f"{self.key_prefix}:{platform}:{topic}:{shop_id}:{webhook_id}"
│   │           
│   │           # Fallback to content-based hash
│   │           content = {
│   │               "platform": platform,
│   │               "topic": topic,
│   │               "shop_id": shop_id,
│   │               "payload": payload
│   │           }
│   │           
│   │           # Create deterministic hash
│   │           content_str = json.dumps(content, sort_keys=True, separators=(',', ':'))
│   │           content_hash = hashlib.sha256(content_str.encode()).hexdigest()[:16]
│   │           
│   │           return f"{self.key_prefix}:{platform}:{topic}:{shop_id}:{content_hash}"
│   │       
│   │       async def is_duplicate(self, dedup_key: str) -> bool:
│   │           """Check if webhook is a duplicate."""
│   │           
│   │           try:
│   │               result = await self.redis_client.get(dedup_key)
│   │               return result is not None
│   │           except Exception as e:
│   │               self.logger.warning(f"Deduplication check failed: {e}")
│   │               return False
│   │       
│   │       async def mark_processed(self, dedup_key: str, webhook_id: str) -> None:
│   │           """Mark webhook as processed."""
│   │           
│   │           try:
│   │               await self.redis_client.setex(
│   │                   dedup_key,
│   │                   self.ttl_seconds,
│   │                   json.dumps({
│   │                       "webhook_id": webhook_id,
│   │                       "processed_at": datetime.utcnow().isoformat()
│   │                   })
│   │               )
│   │           except Exception as e:
│   │               self.logger.warning(f"Failed to mark webhook as processed: {e}")
│   │       
│   │       async def get_processed_info(self, dedup_key: str) -> Optional[Dict[str, Any]]:
│   │           """Get information about processed webhook."""
│   │           
│   │           try:
│   │               result = await self.redis_client.get(dedup_key)
│   │               if result:
│   │                   return json.loads(result)
│   │               return None
│   │           except Exception as e:
│   │               self.logger.warning(f"Failed to get processed info: {e}")
│   │               return None
│   │       
│   │       async def cleanup_expired(self) -> int:
│   │           """Clean up expired deduplication entries."""
│   │           
│   │           try:
│   │               # Get all deduplication keys
│   │               keys = await self.redis_client.keys(f"{self.key_prefix}:*")
│   │               
│   │               if not keys:
│   │                   return 0
│   │               
│   │               # Check TTL for each key and count expired ones
│   │               expired_count = 0
│   │               for key in keys:
│   │                   ttl = await self.redis_client.ttl(key)
│   │                   if ttl == -1:  # Key exists but has no TTL
│   │                       await self.redis_client.delete(key)
│   │                       expired_count += 1
│   │               
│   │               return expired_count
│   │               
│   │           except Exception as e:
│   │               self.logger.error(f"Failed to cleanup expired entries: {e}")
│   │               return 0
│   │   ```
│   │   
│   └── signature_validation.py
│       
│       ```py
│       # services/webhook-service/src/utils/signature_validator.py
│       """Signature validation utilities for webhooks."""
│       
│       import hmac
│       import hashlib
│       import base64
│       from typing import Dict, Optional
│       
│       from shared.utils.logger import ServiceLogger
│       
│       
│       class SignatureValidator:
│           """Validates webhook signatures for different platforms."""
│           
│           def __init__(self, logger: ServiceLogger):
│               self.logger = logger
│           
│           def validate_shopify_signature(
│               self,
│               body: bytes,
│               headers: Dict[str, str],
│               secret: str
│           ) -> bool:
│               """Validate Shopify HMAC signature."""
│               
│               signature = headers.get("X-Shopify-Hmac-Sha256")
│               if not signature:
│                   self.logger.warning("Missing X-Shopify-Hmac-Sha256 header")
│                   return False
│               
│               try:
│                   # Calculate expected signature
│                   calculated = hmac.new(
│                       secret.encode('utf-8'),
│                       body,
│                       hashlib.sha256
│                   ).digest()
│                   expected = base64.b64encode(calculated).decode()
│                   
│                   # Use constant-time comparison to prevent timing attacks
│                   is_valid = hmac.compare_digest(expected, signature)
│                   
│                   if not is_valid:
│                       self.logger.warning(
│                           "Shopify signature validation failed",
│                           extra={
│                               "expected_length": len(expected),
│                               "received_length": len(signature),
│                               "signature_prefix": signature[:10] if len(signature) >= 10 else signature
│                           }
│                       )
│                   
│                   return is_valid
│                   
│               except Exception as e:
│                   self.logger.error(f"Shopify signature validation error: {e}")
│                   return False
│           
│           def validate_stripe_signature(
│               self,
│               body: bytes,
│               headers: Dict[str, str],
│               secret: str
│           ) -> bool:
│               """Validate Stripe webhook signature."""
│               
│               signature = headers.get("Stripe-Signature")
│               if not signature:
│                   self.logger.warning("Missing Stripe-Signature header")
│                   return False
│               
│               try:
│                   # Parse Stripe signature format: t=timestamp,v1=signature
│                   sig_parts = {}
│                   for part in signature.split(','):
│                       if '=' in part:
│                           key, value = part.split('=', 1)
│                           sig_parts[key] = value
│                   
│                   timestamp = sig_parts.get('t')
│                   signature_v1 = sig_parts.get('v1')
│                   
│                   if not timestamp or not signature_v1:
│                       self.logger.warning("Invalid Stripe signature format")
│                       return False
│                   
│                   # Create payload for verification
│                   payload = f"{timestamp}.{body.decode('utf-8')}"
│                   
│                   # Calculate expected signature
│                   calculated = hmac.new(
│                       secret.encode('utf-8'),
│                       payload.encode('utf-8'),
│                       hashlib.sha256
│                   ).hexdigest()
│                   
│                   # Use constant-time comparison
│                   is_valid = hmac.compare_digest(calculated, signature_v1)
│                   
│                   if not is_valid:
│                       self.logger.warning("Stripe signature validation failed")
│                   
│                   return is_valid
│                   
│               except Exception as e:
│                   self.logger.error(f"Stripe signature validation error: {e}")
│                   return False
│           
│           def validate_github_signature(
│               self,
│               body: bytes,
│               headers: Dict[str, str],
│               secret: str
│           ) -> bool:
│               """Validate GitHub webhook signature."""
│               
│               signature = headers.get("X-Hub-Signature-256")
│               if not signature:
│                   self.logger.warning("Missing X-Hub-Signature-256 header")
│                   return False
│               
│               try:
│                   # GitHub signature format: sha256=<signature>
│                   if not signature.startswith('sha256='):
│                       self.logger.warning("Invalid GitHub signature format")
│                       return False
│                   
│                   expected_sig = signature[7:]  # Remove 'sha256=' prefix
│                   
│                   # Calculate expected signature
│                   calculated = hmac.new(
│                       secret.encode('utf-8'),
│                       body,
│                       hashlib.sha256
│                   ).hexdigest()
│                   
│                   # Use constant-time comparison
│                   is_valid = hmac.compare_digest(calculated, expected_sig)
│                   
│                   if not is_valid:
│                       self.logger.warning("GitHub signature validation failed")
│                   
│                   return is_valid
│                   
│               except Exception as e:
│                   self.logger.error(f"GitHub signature validation error: {e}")
│                   return False
│           
│           def validate_signature(
│               self,
│               platform: str,
│               body: bytes,
│               headers: Dict[str, str],
│               secret: str
│           ) -> bool:
│               """Validate signature for any supported platform."""
│               
│               if platform == "shopify":
│                   return self.validate_shopify_signature(body, headers, secret)
│               elif platform == "stripe":
│                   return self.validate_stripe_signature(body, headers, secret)
│               elif platform == "github":
│                   return self.validate_github_signature(body, headers, secret)
│               else:
│                   self.logger.warning(f"Unsupported platform for signature validation: {platform}")
│                   return False
│       ```
│       
├── __init__.py
├── config.py
│   
│   ```py
│   # services/webhook-service/src/config.py
│   from functools import lru_cache
│   from pydantic import BaseModel, Field
│   from shared.config.loader import merged_config, flatten_config
│   from shared.database import DatabaseConfig, create_database_config
│   import os
│   
│   
│   class WebhookServiceConfig(BaseModel):
│       # Service Identity (from shared + service YAML)
│       service_name: str = Field(..., alias="service.name")
│       service_version: str = Field(..., alias="service.version")
│       environment: str
│       debug: bool
│       
│       # API Configuration - BOTH PORTS
│       api_host: str = Field(..., alias="api.host")
│       api_port: int = Field(..., alias="api.port")                    # Internal/container port
│       api_external_port: int = Field(..., alias="api.external_port")  # Local development port
│       api_cors_origins: list = Field(..., alias="api.cors_origins")
│       
│       # Infrastructure (from shared YAML)
│       infrastructure_nats_url: str = Field(..., alias="infrastructure.nats_url")
│       infrastructure_redis_url: str = Field(..., alias="infrastructure.redis_url")
│       
│       # Database Configuration
│       db_enabled: bool = Field(..., alias="database.enabled")
│       
│       # Logging (from shared YAML)
│       logging_level: str = Field(..., alias="logging.level")
│       logging_format: str = Field(..., alias="logging.format")
│       
│       # Rate Limiting (from shared YAML)
│       rate_limiting_enabled: bool = Field(..., alias="rate_limiting.enabled")
│       rate_limiting_window_seconds: int = Field(..., alias="rate_limiting.window_seconds")
│   
│       # Monitoring (from shared YAML)
│       monitoring_metrics_enabled: bool = Field(..., alias="monitoring.metrics_enabled")
│       monitoring_tracing_enabled: bool = Field(..., alias="monitoring.tracing_enabled")
│       
│       # Cache (service override of shared defaults)
│       cache_ttl_seconds: int = Field(..., alias="cache.ttl_seconds")
│       
│       # Webhook Configuration (service-specific)
│       webhook_max_payload_size_mb: int = Field(..., alias="webhook.max_payload_size_mb")
│       webhook_timeout_seconds: int = Field(..., alias="webhook.timeout_seconds")
│       webhook_dedup_ttl_hours: int = Field(..., alias="webhook.dedup_ttl_hours")
│       
│       # Shopify Configuration
│       shopify_webhook_secret: str = Field(..., alias="shopify.webhook_secret")
│       shopify_api_version: str = Field(..., alias="shopify.api_version")
│   
│       @property
│       def database_config(self) -> DatabaseConfig:
│           """Get database configuration"""
│           cfg = create_database_config(prefix="WEBHOOK_")
│           return cfg
│   
│       @property
│       def effective_port(self) -> int:
│           """
│           Get the effective port to use based on environment.
│           
│           Logic:
│           - Local development (not in Docker): use external_port
│           - Docker/container environment: use internal port
│           - Environment override: WEBHOOK_USE_EXTERNAL_PORT=true forces external_port
│           """
│           # Check if explicitly requested to use external port
│           use_external = os.getenv("WEBHOOK_USE_EXTERNAL_PORT", "false").lower() == "true"
│           
│           # Check if running in container (common Docker environment variables)
│           in_container = any([
│               os.getenv("DOCKER_CONTAINER"),
│               os.getenv("HOSTNAME", "").startswith("webhook-service"),
│               os.path.exists("/.dockerenv")
│           ])
│           
│           if use_external or (not in_container and self.environment == "development"):
│               return self.api_external_port
│           else:
│               return self.api_port
│   
│   
│   @lru_cache
│   def get_service_config() -> WebhookServiceConfig:
│       """Load and cache service configuration"""
│       cfg_dict = merged_config("webhook", env_prefix="WEBHOOK") 
│       flattened = flatten_config(cfg_dict)
│       return WebhookServiceConfig(**flattened)
│   ```
│   
├── dependencies.py
│   
│   ```py
│   # services/webhook-service/src/dependencies.py
│   """
│   FastAPI dependencies for webhook service.
│   
│   Follows the same pattern as notification and credit services.
│   """
│   
│   from typing import Annotated, Any
│   from fastapi import Depends, Request, HTTPException
│   import redis.asyncio as redis
│   
│   from shared.database.dependencies import DBSessionDep
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   
│   from .lifecycle import ServiceLifecycle
│   from .services.webhook_service import WebhookService
│   from .services.platform_handler_service import PlatformHandlerService
│   from .repositories.webhook_entry_repository import WebhookEntryRepository
│   from .repositories.platform_configuration_repository import PlatformConfigurationRepository
│   from .events.publishers import WebhookEventPublisher
│   from .mappers.webhook_entry_mapper import WebhookEntryMapper
│   
│   
│   # Core dependencies
│   def get_lifecycle(request: Request) -> ServiceLifecycle:
│       """Get service lifecycle from app state"""
│       return request.app.state.lifecycle
│   
│   
│   def get_config(request: Request):
│       """Get service config from app state"""
│       return request.app.state.config
│   
│   
│   # Type aliases for core dependencies
│   LifecycleDep = Annotated[ServiceLifecycle, Depends(get_lifecycle)]
│   ConfigDep = Annotated[Any, Depends(get_config)]
│   
│   
│   # Messaging dependencies
│   def get_messaging_wrapper(lifecycle: LifecycleDep) -> JetStreamWrapper:
│       """Get messaging wrapper"""
│       if not lifecycle.messaging_wrapper:
│           raise HTTPException(500, "Messaging not initialized")
│       return lifecycle.messaging_wrapper
│   
│   
│   def get_publisher(
│       wrapper: Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)],
│   ) -> WebhookEventPublisher:
│       """Get webhook event publisher"""
│       pub = wrapper.get_publisher(WebhookEventPublisher)
│       if not pub:
│           raise HTTPException(500, "WebhookEventPublisher not initialized")
│       return pub
│   
│   
│   # Type aliases for messaging
│   MessagingDep = Annotated[JetStreamWrapper, Depends(get_messaging_wrapper)]
│   PublisherDep = Annotated[WebhookEventPublisher, Depends(get_publisher)]
│   
│   
│   # Repository dependencies
│   def get_webhook_entry_repo(lifecycle: LifecycleDep) -> WebhookEntryRepository:
│       """Get webhook entry repository"""
│       if not lifecycle.webhook_entry_repo:
│           raise HTTPException(500, "WebhookEntryRepository not initialized")
│       return lifecycle.webhook_entry_repo
│   
│   
│   def get_platform_config_repo(lifecycle: LifecycleDep) -> PlatformConfigurationRepository:
│       """Get platform configuration repository"""
│       if not lifecycle.platform_config_repo:
│           raise HTTPException(500, "PlatformConfigurationRepository not initialized")
│       return lifecycle.platform_config_repo
│   
│   
│   # Type aliases for repositories
│   WebhookEntryRepoDep = Annotated[WebhookEntryRepository, Depends(get_webhook_entry_repo)]
│   PlatformConfigRepoDep = Annotated[PlatformConfigurationRepository, Depends(get_platform_config_repo)]
│   
│   
│   # Service dependencies
│   def get_webhook_service(lifecycle: LifecycleDep) -> WebhookService:
│       """Get webhook service"""
│       if not lifecycle.webhook_service:
│           raise HTTPException(500, "WebhookService not initialized")
│       return lifecycle.webhook_service
│   
│   
│   def get_platform_handler_service(lifecycle: LifecycleDep) -> PlatformHandlerService:
│       """Get platform handler service"""
│       if not lifecycle.platform_handler_service:
│           raise HTTPException(500, "PlatformHandlerService not initialized")
│       return lifecycle.platform_handler_service
│   
│   
│   # Type aliases for services
│   WebhookServiceDep = Annotated[WebhookService, Depends(get_webhook_service)]
│   PlatformHandlerServiceDep = Annotated[PlatformHandlerService, Depends(get_platform_handler_service)]
│   
│   
│   # Mapper dependencies
│   def get_webhook_entry_mapper(lifecycle: LifecycleDep) -> WebhookEntryMapper:
│       """Get webhook entry mapper"""
│       if not lifecycle.webhook_entry_mapper:
│           raise HTTPException(500, "WebhookEntryMapper not initialized")
│       return lifecycle.webhook_entry_mapper
│   
│   
│   # Type aliases for mappers
│   WebhookEntryMapperDep = Annotated[WebhookEntryMapper, Depends(get_webhook_entry_mapper)]
│   
│   
│   # Redis dependency
│   def get_redis_client(lifecycle: LifecycleDep) -> redis.Redis:
│       """Get Redis client"""
│       if not lifecycle.redis_client:
│           raise HTTPException(500, "Redis client not initialized")
│       return lifecycle.redis_client
│   
│   
│   RedisDep = Annotated[redis.Redis, Depends(get_redis_client)]
│   ```
│   
├── exceptions.py
│   
│   ```py
│   # services/webhook-service/src/errors.py
│   """Custom exceptions for webhook service."""
│   
│   from typing import Optional
│   
│   
│   class WebhookServiceError(Exception):
│       """Base exception for webhook service errors."""
│       
│       def __init__(self, message: str, error_code: Optional[str] = None):
│           self.message = message
│           self.error_code = error_code
│           super().__init__(self.message)
│   
│   
│   class InvalidSignatureError(WebhookServiceError):
│       """Raised when webhook signature validation fails."""
│       
│       def __init__(self, message: str = "Invalid webhook signature"):
│           super().__init__(message, "INVALID_SIGNATURE")
│   
│   
│   class WebhookValidationError(WebhookServiceError):
│       """Raised when webhook payload validation fails."""
│       
│       def __init__(self, message: str = "Webhook validation failed"):
│           super().__init__(message, "VALIDATION_ERROR")
│   
│   
│   class PayloadTooLargeError(WebhookServiceError):
│       """Raised when webhook payload exceeds size limit."""
│       
│       def __init__(self, message: str = "Webhook payload too large"):
│           super().__init__(message, "PAYLOAD_TOO_LARGE")
│   
│   
│   class DuplicateWebhookError(WebhookServiceError):
│       """Raised when duplicate webhook is detected."""
│       
│       def __init__(self, message: str = "Duplicate webhook detected"):
│           super().__init__(message, "DUPLICATE_WEBHOOK")
│   
│   
│   class PlatformNotSupportedError(WebhookServiceError):
│       """Raised when webhook platform is not supported."""
│       
│       def __init__(self, platform: str):
│           super().__init__(f"Platform '{platform}' is not supported", "PLATFORM_NOT_SUPPORTED")
│   
│   
│   class WebhookProcessingError(WebhookServiceError):
│       """Raised when webhook processing fails."""
│       
│       def __init__(self, message: str = "Webhook processing failed"):
│           super().__init__(message, "PROCESSING_ERROR")
│   ```
│   
├── lifecycle.py
│   
│   ```py
│   # services/webhook-service/src/lifecycle.py
│   """
│   Service lifecycle management for webhook service.
│   
│   Manages startup and shutdown of all service components following
│   the same pattern as notification and credit services.
│   """
│   
│   from __future__ import annotations
│   
│   import asyncio
│   from typing import Optional, List, cast
│   
│   import redis.asyncio as redis
│   from nats.js.api import StreamConfig, RetentionPolicy, StorageType
│   
│   from shared.utils.logger import ServiceLogger
│   from shared.database import DatabaseSessionManager, set_database_manager
│   from shared.messaging.jetstream_wrapper import JetStreamWrapper
│   
│   from .config import WebhookServiceConfig
│   from .services.webhook_service import WebhookService
│   from .services.platform_handler_service import PlatformHandlerService
│   
│   # Repositories
│   from .repositories.webhook_entry_repository import WebhookEntryRepository
│   from .repositories.platform_configuration_repository import PlatformConfigurationRepository
│   
│   # Models
│   from .models.webhook_entry import WebhookEntry
│   from .models.platform_configuration import PlatformConfiguration
│   
│   # Events
│   from .events.publishers import WebhookEventPublisher
│   
│   # Mappers
│   from .mappers.webhook_entry_mapper import WebhookEntryMapper
│   
│   
│   class ServiceLifecycle:
│       """Manages service lifecycle and dependencies"""
│       
│       def __init__(self, config: WebhookServiceConfig, logger: ServiceLogger):
│           self.config = config
│           self.logger = logger
│           
│           # External connections
│           self.messaging_wrapper: Optional[JetStreamWrapper] = None
│           self.db_manager: Optional[DatabaseSessionManager] = None
│           self.redis_client: Optional[redis.Redis] = None
│           
│           # Repositories
│           self.webhook_entry_repo: Optional[WebhookEntryRepository] = None
│           self.platform_config_repo: Optional[PlatformConfigurationRepository] = None
│           
│           # Mappers
│           self.webhook_entry_mapper: Optional[WebhookEntryMapper] = None
│           
│           # Services
│           self.webhook_service: Optional[WebhookService] = None
│           self.platform_handler_service: Optional[PlatformHandlerService] = None
│           
│           # Publishers
│           self.webhook_event_publisher: Optional[WebhookEventPublisher] = None
│           
│           # Tasks
│           self._tasks: List[asyncio.Task] = []
│           self._shutdown_event = asyncio.Event()
│   
│       async def startup(self) -> None:
│           """Start all service components"""
│   
│           try:
│               self.logger.info("Starting service components...")
│               
│               # 1. Initialize database
│               await self._init_database()
│               
│               # 2. Initialize Redis
│               await self._init_redis()
│               
│               # 3. Initialize messaging
│               await self._init_messaging()
│               
│                # 4. Initialize repositories
│               self._init_repositories()
│               
│               # 5. Initialize mappers
│               self._init_mappers()
│   
│               # 6. Initialize services
│               self._init_local_services()     
│               
│               self.logger.info("All webhook service components initialized successfully")
│               
│           except Exception as e:
│               self.logger.error(f"Failed to start service: {e}", exc_info=True)
│               await self.shutdown()
│               raise
│   
│       async def shutdown(self) -> None:
│           """Cleanup all service components"""
│           
│           self.logger.info("Shutting down service components...")
│           
│            # Stop background tasks
│           for t in self._tasks:
│               t.cancel()
│           if self._tasks:
│               await asyncio.gather(*self._tasks, return_exceptions=True)
│               
│           # Close Redis
│           if self.redis_client:
│               try:
│                   await self.redis_client.aclose()
│                   self.logger.info("Redis connection closed")
│               except Exception as e:
│                   self.logger.error(f"Error closing Redis connection: {e}")
│           
│           # Close messaging
│           if self.messaging_wrapper:
│               try:
│                   await self.messaging_wrapper.close()
│                   self.logger.info("Messaging connection closed")
│               except Exception as e:
│                   self.logger.warning(f"Error closing messaging: {e}")
│           
│           
│           # Close database
│           if self.db_manager:
│               try:
│                   await self.db_manager.close()
│                   self.logger.info("Database connection closed")
│               except Exception as e:
│                   self.logger.error(f"Error closing database connection: {e}")
│           
│           self.logger.info("Webhook service shutdown complete")
│   
│       
│       async def _init_messaging(self) -> None:
│           self.messaging_wrapper = JetStreamWrapper(self.logger)
│           await self.messaging_wrapper.connect([self.config.infrastructure_nats_url])
│           self.logger.info("Connected to NATS %s", self.config.infrastructure_nats_url)
│   
│           js = self.messaging_wrapper.js
│           cfg = StreamConfig(
│               name      = "WEBHOOK",
│               subjects  = ["evt.webhook.*"],
│               retention = RetentionPolicy.LIMITS,
│               max_age   = 7 * 24 * 60 * 60,
│               max_msgs  = 1_000_000,
│               max_bytes = 1_024 ** 3,
│               storage   = StorageType.FILE,
│               duplicate_window = 60,
│           )
│           try:
│               await js.stream_info("WEBHOOK")
│           except Exception:
│               await js.add_stream(cfg)
│               self.logger.info("Created WEBHOOK stream")
│   
│       
│       async def _init_database(self) -> None:
│           if not (self.config.db_enabled and self.config.database_config):
│               self.logger.warning("DB disabled; repositories will not be initialised")
│               return
│           
│           print("Database URL:", self.config.database_config.database_url)
│   
│           self.db_manager = DatabaseSessionManager(
│               database_url=self.config.database_config.database_url,
│               echo=self.config.database_config.DB_ECHO,
│               pool_size=self.config.database_config.DB_POOL_SIZE,
│               max_overflow=self.config.database_config.DB_MAX_OVERFLOW,
│           )
│           await self.db_manager.init()
│           set_database_manager(self.db_manager)
│           self.logger.info("Connected to DB")
│   
│           from shared.database.base import Base
│           async with self.db_manager.engine.begin() as conn:
│               await conn.run_sync(Base.metadata.create_all)
│       
│       
│       def _init_repositories(self) -> None:
│           """Initialize repositories"""
│           
│           if not self.db_manager:
│               self.logger.warning("DB manager not initialized, repositories will not be set up")
│               return
│           
│           self.logger.info("Setting up repositories...")
│           
│           session_factory = self.db_manager.session_factory
│           
│           self.webhook_entry_repo = WebhookEntryRepository(WebhookEntry, session_factory)
│           self.platform_config_repo = PlatformConfigurationRepository(PlatformConfiguration, session_factory)
│   
│           self.logger.info("Repositories setup complete")
│       
│       async def _init_redis(self) -> None:
│           """Initialize Redis connection"""
│           
│           self.logger.info("Setting up Redis...")
│           
│           if not self.config.infrastructure_redis_url:
│               self.logger.warning("INFRASTRUCTURE_REDIS_URL not configured, skipping Redis setup")
│               return
│           
│           self.redis_client = redis.from_url(
│               self.config.infrastructure_redis_url,
│               decode_responses=True,
│               retry_on_timeout=True,
│               health_check_interval=30
│           )
│           
│           # Test connection
│           await self.redis_client.ping()
│           
│           self.logger.info("Redis setup complete")
│       
│       def _init_mappers(self) -> None:
│           """Initialize mappers"""
│           
│           self.logger.info("Setting up mappers...")
│           
│           self.webhook_entry_mapper = WebhookEntryMapper()
│           self.logger.info("Mappers setup complete")
│   
│       def _init_local_services(self) -> None:
│           """Initialize business services"""
│           
│           self.logger.info("Setting up services...")
│           
│           if not self.messaging_wrapper:
│               raise RuntimeError("Messaging wrapper is not initialized")
│           
│           publisher = cast(
│               WebhookEventPublisher,
│               self.messaging_wrapper.create_publisher(WebhookEventPublisher),
│           )
│           if not self.webhook_entry_repo:
│               raise RuntimeError("WebhookEntryRepository is not initialized")
│           
│           if not self.platform_config_repo:
│               raise RuntimeError("PlatformConfigurationRepository is not initialized")
│           
│           if not self.redis_client:
│               raise RuntimeError("Redis client is not initialized")
│               
│           self.webhook_service = WebhookService(
│               webhook_entry_repo=self.webhook_entry_repo,
│               platform_config_repo=self.platform_config_repo,
│               redis_client=self.redis_client,
│               publisher=publisher,
│               config=self.config,
│               logger=self.logger
│           )
│           
│           self.logger.info("Services setup complete")
│   
│       # Convenience methods
│       def add_task(self, coro) -> asyncio.Task:
│           t = asyncio.create_task(coro)
│           self._tasks.append(t)
│           return t
│   
│       async def wait_for_shutdown(self) -> None:
│           await self._shutdown_event.wait()
│   
│       def signal_shutdown(self) -> None:
│           self._shutdown_event.set()
│   ```
│   
├── main.py
│   
│   ```py
│   # services/webhook-service/src/main.py
│   """Main entry point for the Webhook Service"""
│   
│   from fastapi import FastAPI
│   from contextlib import asynccontextmanager
│   
│   from shared.utils.logger import create_logger
│   from shared.api import setup_middleware
│   
│   from .config import get_service_config
│   from .lifecycle import ServiceLifecycle
│   from .api.v1 import health, webhooks
│   
│   # Global singletons
│   config = get_service_config()
│   logger = create_logger(config.service_name)
│   lifecycle = ServiceLifecycle(config, logger)
│   
│   
│   @asynccontextmanager
│   async def lifespan(app: FastAPI):
│       """Application lifespan management"""
│       
│       logger.info(
│           f"Starting {config.service_name}",
│           extra={
│               "version": config.service_version,
│               "environment": config.environment,
│               "api_host": config.api_host,
│               "api_port": config.effective_port,
│           }
│       )
│       
│       app.state.lifecycle = lifecycle
│       app.state.config = config
│       app.state.logger = logger
│       
│       try:
│           await lifecycle.startup()
│           logger.info("Webhook Service started successfully")
│           yield
│       finally:
│           logger.info("Shutting down Webhook Service")
│           await lifecycle.shutdown()
│           logger.info("Webhook Service stopped")
│   
│   
│   def create_application() -> FastAPI:
│       """Create and configure the FastAPI application."""
│       
│       # Create FastAPI app
│       app = FastAPI(
│           title=config.service_name,
│           version=config.service_version,
│           lifespan=lifespan,
│           description="Webhook service for receiving and processing webhooks from external platforms",
│           exception_handlers={}  # Use shared middleware for exception handling
│       )
│   
│       setup_middleware(
│           app,
│           service_name=config.service_name,
│           enable_metrics=True
│       )
│   
│       # Include routers
│       app.include_router(health.router, prefix="/api/v1")
│       app.include_router(webhooks.router, prefix="/webhooks")
│       
│       return app
│   
│   
│   app = create_application()
│   
│   if __name__ == "__main__":
│       import uvicorn
│       
│       # Smart port selection
│       port = config.effective_port
│       
│       logger.info(f"Starting server", extra={
│           "internal_port": config.api_port,
│           "external_port": config.api_external_port,
│           "effective_port": port,
│           "environment": config.environment
│       })
│       
│       uvicorn.run(
│           "src.main:app",
│           host=config.api_host,
│           port=port,
│           reload=config.debug
│       )
│   ```
│   
└── metrics.py
    
    ```py
    # services/webhook-service/src/metrics.py
    """Metrics for webhook service."""
    
    from prometheus_client import Counter, Histogram, Gauge
    from shared.metrics import get_metrics_registry
    
    # Get the shared metrics registry
    registry = get_metrics_registry()
    
    # Webhook processing metrics
    webhooks_received_total = Counter(
        'webhooks_received_total',
        'Total number of webhooks received',
        ['platform', 'topic', 'status'],
        registry=registry
    )
    
    webhook_validation_failures_total = Counter(
        'webhook_validation_failures_total',
        'Total number of webhook validation failures',
        ['platform', 'reason'],
        registry=registry
    )
    
    webhook_processing_duration_seconds = Histogram(
        'webhook_processing_duration_seconds',
        'Time spent processing webhooks',
        ['platform', 'topic'],
        registry=registry
    )
    
    webhook_duplicate_total = Counter(
        'webhook_duplicate_total',
        'Total number of duplicate webhooks detected',
        ['platform'],
        registry=registry
    )
    
    # Current webhook status counts
    webhooks_by_status = Gauge(
        'webhooks_by_status',
        'Current number of webhooks by status',
        ['platform', 'status'],
        registry=registry
    )
    
    # Platform handler metrics
    platform_handlers_active = Gauge(
        'platform_handlers_active',
        'Number of active platform handlers',
        ['platform'],
        registry=registry
    )
    ```
    
tests/
└── __init__.py
.env.example
.gitignore
.python-version
docker_compose.yml

```yml
version: '3.8'

services:
  webhook-service:
    build:
      context: ../..
      dockerfile: services/webhook-service/Dockerfile
    container_name: webhook-service
    ports:
      - "8012:8012"
    environment:
      - SERVICE_NAME=webhook-service
      - SERVICE_PORT=8012
      - DATABASE_URL=postgresql+asyncpg://webhook:webhook@postgres:5432/webhook_db
      - REDIS_URL=redis://redis:6379
      - NATS_URL=nats://nats:4222
      - SHOPIFY_WEBHOOK_SECRET=${SHOPIFY_WEBHOOK_SECRET}
      - STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
      - LOG_LEVEL=INFO
    depends_on:
      - postgres
      - redis
      - nats
    networks:
      - glam-network
    restart: unless-stopped

networks:
  glam-network:
    external: true
```

Dockerfile

```
# ──────────────────────────────────────────────────────────────
# 📦  Stage 1 ─ Builder
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim as builder

# System dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
ENV POETRY_VERSION=1.6.1
RUN pip install poetry==$POETRY_VERSION

# Copy shared package first
WORKDIR /shared
COPY shared/pyproject.toml shared/poetry.lock* ./
COPY shared/ ./

# Install shared dependencies
RUN poetry config virtualenvs.create false && \
    poetry install --no-interaction --no-ansi --no-root

# Copy service source
COPY services/webhook-service /app

# ──────────────────────────────────────────────────────────────
# 📦  Stage 2 ─ Runtime
# ──────────────────────────────────────────────────────────────
FROM python:3.11-slim

# Copy everything from builder
COPY --from=builder /usr/local /usr/local
COPY --from=builder /app       /app
COPY --from=builder /shared    /shared

ENV PYTHONPATH="/shared:/app"
WORKDIR /app

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8012

# Run with optimal settings
CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8012", "--workers", "4"]
```

poetry.lock
pyproject.toml

```toml
# services/webhook-service/pyproject.toml
[tool.poetry]
name = "webhook-service"
version = "1.0.0"
description = "Webhook service for receiving and processing webhooks from external platforms"
authors = ["GlamYouUp Team"]
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.25.0"}
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
sqlalchemy = "^2.0.23"
asyncpg = "^0.29.0"
alembic = "^1.13.0"
nats-py = "^2.6.0"
redis = "^5.0.1"
python-multipart = "^0.0.6"
httpx = "^0.25.2"
python-dotenv = "^1.0.0"
shared = { path = "../../shared", develop = true }
prometheus-client = "^0.19.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
flake8 = "^6.1.0"
mypy = "^1.7.1"
faker = "^20.1.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 88
target-version = ['py311']

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.pylance]
reportMissingImports = "error"
reportMissingTypeStubs = "warning"
reportGeneralTypeIssues = "error"
reportUnusedImport = "warning"
reportUnusedClass = "warning"
reportUnusedFunction = "warning"
reportUnusedVariable = "warning"
reportDuplicateImport = "warning"
reportPrivateUsage = "warning"
reportConstantRedefinition = "error"
reportIncompatibleMethodOverride = "error"
reportIncompatibleVariableOverride = "error"
reportOverlappingOverloads = "error"
reportUninitializedInstanceVariable = "warning"
reportCallInDefaultInitializer = "warning"
reportUnnecessaryIsInstance = "warning"
reportUnnecessaryCast = "warning"
reportUnnecessaryComparison = "warning"
reportImplicitStringConcatenation = "warning"
reportInvalidStringEscapeSequence = "error"
reportUnknownParameterType = "warning"
reportUnknownArgumentType = "warning"
reportUnknownLambdaType = "warning"
reportUnknownVariableType = "warning"
reportUnknownMemberType = "warning"
reportMissingParameterType = "warning"
reportMissingTypeArgument = "warning"
reportInvalidTypeVarUse = "error"
reportUnsupportedDunderAll = "warning"
reportUnusedCoroutine = "error"
```

README.md

```md
# Webhook Service

Unified webhook ingestion service for the GlamYouUp platform.

## Features

- **Multi-source Support**: Currently supports Shopify and Stripe webhooks
- **HMAC Signature Validation**: Secure webhook authentication
- **Idempotency**: Redis-based deduplication with configurable TTL
- **Event Mapping**: Maps external webhooks to internal domain events
- **Circuit Breakers**: Protects downstream services from cascading failures
- **Dead Letter Queue**: Failed webhooks can be replayed
- **Observability**: Structured logging, Prometheus metrics, health checks
- **Extensible**: Easy to add new webhook sources

## Architecture
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│ External        │────▶│ Webhook Service  │────▶│ Event Bus       │
│ Platforms       │     │                  │     │ (NATS)          │
└─────────────────┘     └──────────────────┘     └─────────────────┘
│
▼
┌──────────────────┐
│ PostgreSQL       │
│ Redis            │
└──────────────────┘


### Service Type
- **Type**: API Service
- **Port**: 8012
- **Database**: PostgreSQL (dedicated schema)
- **Cache**: Redis for deduplication and circuit breakers
- **Messaging**: NATS JetStream for event publishing

### Key Components

1. **Webhook Handlers**
   - Shopify: Full support for products, orders, inventory, app lifecycle
   - Stripe: Payment and subscription events
   - Extensible base handler for new sources

2. **Authentication**
   - HMAC-SHA256 validation for Shopify
   - Stripe signature validation
   - Per-source secret management

3. **Deduplication**
   - Redis-based with configurable TTL (default 24h)
   - Idempotency keys based on webhook ID or content hash

4. **Circuit Breakers**
   - Per-subject breakers with sliding window
   - Automatic recovery with half-open state
   - Configurable thresholds and timeouts

5. **Event Publishing**
   - Maps webhooks to domain events
   - Publishes to appropriate NATS streams
   - Maintains correlation IDs

## API Endpoints

### Webhooks
- `POST /api/v1/webhooks/shopify/{topic}` - Shopify webhook (topic in path)
- `POST /api/v1/webhooks/shopify` - Shopify webhook (topic in header)
- `POST /api/v1/webhooks/stripe` - Stripe webhook
- `POST /api/v1/webhooks/{source}` - Generic webhook (future)

### Health
- `GET /api/v1/health` - Comprehensive health check
- `GET /api/v1/health/ready` - Kubernetes readiness
- `GET /api/v1/health/live` - Kubernetes liveness

## Environment Variables

See `.env.example` for all configuration options. Key variables:

- `SHOPIFY_WEBHOOK_SECRET` - Required for Shopify webhooks
- `STRIPE_WEBHOOK_SECRET` - Required for Stripe webhooks
- `REDIS_URL` - Redis connection for deduplication
- `DEDUP_TTL_HOURS` - Deduplication window (default 24)
- `MAX_PAYLOAD_SIZE_MB` - Maximum webhook size (default 10)

## Development

```bash
# Install dependencies
poetry install

# Copy environment variables
cp .env.example .env
# Edit .env with your configuration

# Run database migrations
alembic upgrade head

# Start service
uvicorn src.main:app --reload --port 8012

# Run tests
pytest

# Test webhook
python scripts/test_webhook.py



Key Components Created:
1. Core Structure

Complete directory structure matching the notification service pattern
Service lifecycle management with proper startup/shutdown
Event-driven architecture with NATS JetStream
Repository pattern using SQLAlchemy's latest mapped API

2. Models & Database

WebhookEntry - Stores all received webhooks for audit/replay
PlatformConfiguration - Manages webhook secrets per source
Uses shared mixins (TimestampedMixin, ShopMixin)
Alembic migrations setup

3. Services

WebhookService - Main orchestration service
AuthService - HMAC validation for Shopify/Stripe
DeduplicationService - Redis-based idempotency
CircuitBreakerService - Downstream protection

4. Event Handling

WebhookEventPublisher - Publishes webhook events
Maps external webhooks to domain events
Maintains event context and correlation IDs

5. Webhook Handlers

ShopifyWebhookHandler - Handles all Shopify topics
StripeWebhookHandler - Handles Stripe events
Extensible base handler for new sources

6. API Endpoints

/api/v1/webhooks/shopify/{topic} - Shopify webhooks
/api/v1/webhooks/stripe - Stripe webhooks
Comprehensive health checks

7. Production Features

Docker multi-stage build
Environment-based configuration
Structured logging with correlation IDs
Prometheus metrics
Circuit breakers with sliding windows
Dead letter queue support

Key Design Patterns Followed:

Dependency Injection - FastAPI dependencies matching notification service
Repository Pattern - Generic repository with specific implementations
Event Publishing - Domain event publisher with typed payloads
Service Lifecycle - Centralized startup/shutdown management
Error Handling - Shared error classes from the shared package

The service is production-ready and maintains complete consistency with the existing platform architecture. It can handle high-throughput webhook processing with proper deduplication, circuit breaking, and observability.
```


================================================================================
Output includes file contents
================================================================================