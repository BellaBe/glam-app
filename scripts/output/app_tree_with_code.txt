================================================================================
Directory Structure: /home/bellabe/glam-app/apps/shopify-app/app
================================================================================

app/
assets/
└── help-hero.png
components/
├── BillingPlans.jsx
│   
│   ```jsx
│   import { Grid, Card, Text, Button, BlockStack, InlineStack, Badge, List } from "@shopify/polaris";
│   
│   export default function BillingPlans({ currentPlan, onSelectPlan, loading }) {
│     const plans = [
│       {
│         id: 'starter',
│         name: 'Starter',
│         price: 29,
│         credits: '1,000',
│         features: [
│           'Basic analytics',
│           'Email support',
│           'Manual catalog sync'
│         ],
│         recommended: false
│       },
│       {
│         id: 'growth',
│         name: 'Growth',
│         price: 99,
│         credits: '5,000',
│         features: [
│           'Advanced analytics',
│           'Priority support',
│           'Auto-sync daily',
│           'Export data'
│         ],
│         recommended: true
│       },
│       {
│         id: 'enterprise',
│         name: 'Enterprise',
│         price: 299,
│         credits: 'Unlimited',
│         features: [
│           'Real-time sync',
│           'Dedicated support',
│           'API access',
│           'Custom reports'
│         ],
│         recommended: false
│       }
│     ];
│   
│     return (
│       <BlockStack gap="400">
│         <Text variant="headingMd" as="h2">Choose Your Plan</Text>
│         <Grid>
│           {plans.map(plan => (
│             <Grid.Cell key={plan.id} columnSpan={{ xs: 6, sm: 6, md: 4, lg: 4, xl: 4 }}>
│               <Card>
│                 <BlockStack gap="400">
│                   {plan.recommended && (
│                     <Badge tone="success">Recommended</Badge>
│                   )}
│                   <BlockStack gap="200">
│                     <Text variant="headingLg" as="h3">{plan.name}</Text>
│                     <InlineStack gap="100" blockAlign="baseline">
│                       <Text variant="heading2xl" as="p">${plan.price}</Text>
│                       <Text tone="subdued">/month</Text>
│                     </InlineStack>
│                     <Text tone="subdued">{plan.credits} credits/month</Text>
│                   </BlockStack>
│                   <List>
│                     {plan.features.map((feature, index) => (
│                       <List.Item key={index}>{feature}</List.Item>
│                     ))}
│                   </List>
│                   <Button
│                     fullWidth
│                     primary={plan.recommended}
│                     disabled={currentPlan === plan.id || loading}
│                     loading={loading}
│                     onClick={() => onSelectPlan(plan.id)}
│                   >
│                     {currentPlan === plan.id ? 'Current Plan' : `Choose ${plan.name}`}
│                   </Button>
│                 </BlockStack>
│               </Card>
│             </Grid.Cell>
│           ))}
│         </Grid>
│       </BlockStack>
│     );
│   }
│   ```
│   
├── CatalogSync.jsx
│   
│   ```jsx
│   import { Card, Button, Banner, Text, BlockStack, InlineStack, Badge, ProgressBar } from "@shopify/polaris";
│   
│   export default function CatalogSync({ lastSync, productCount, syncing, progress, onSync }) {
│     const formatTimeAgo = (date) => {
│       if (!date) return 'Never';
│       
│       const seconds = Math.floor((new Date() - new Date(date)) / 1000);
│       
│       if (seconds < 60) return 'Just now';
│       if (seconds < 3600) return `${Math.floor(seconds / 60)} minutes ago`;
│       if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`;
│       return `${Math.floor(seconds / 86400)} days ago`;
│     };
│   
│     return (
│       <Card>
│         <BlockStack gap="400">
│           <InlineStack align="space-between">
│             <Text variant="headingMd" as="h2">Catalog Sync</Text>
│             {productCount > 0 && (
│               <Badge tone="success">{productCount} Products</Badge>
│             )}
│           </InlineStack>
│           
│           {lastSync && (
│             <InlineStack gap="200">
│               <Text tone="subdued">Last synced:</Text>
│               <Text>{formatTimeAgo(lastSync)}</Text>
│             </InlineStack>
│           )}
│   
│           {syncing ? (
│             <BlockStack gap="300">
│               <ProgressBar progress={progress?.percent || 0} />
│               <Text>{progress?.message || 'Starting sync...'}</Text>
│               {progress?.processed && (
│                 <Text tone="subdued">
│                   {progress.processed} / {progress.total} products processed
│                 </Text>
│               )}
│             </BlockStack>
│           ) : (
│             <InlineStack gap="200">
│               <Button primary onClick={onSync}>
│                 Sync Products Now
│               </Button>
│               {productCount > 0 && (
│                 <Button plain>View sync settings</Button>
│               )}
│             </InlineStack>
│           )}
│   
│           {productCount === 0 && !syncing && (
│             <Banner tone="warning">
│               <Text>No products synced yet. Sync your catalog to enable selfie recommendations.</Text>
│             </Banner>
│           )}
│         </BlockStack>
│       </Card>
│     );
│   }
│   ```
│   
├── CreditUsage.jsx
│   
│   ```jsx
│   import { Card, Text, ProgressBar, Banner, BlockStack, InlineStack, Badge, Icon, Button } from "@shopify/polaris";
│   import { AlertCircleIcon } from "@shopify/polaris-icons";
│   
│   export default function CreditUsage({ used, limit, resetsAt }) {
│     const percentage = limit > 0 ? (used / limit) * 100 : 0;
│     const remaining = limit - used;
│     const isUnlimited = limit === -1 || limit === 0;
│     
│     const getDaysUntilReset = () => {
│       if (!resetsAt) return null;
│       const days = Math.ceil((new Date(resetsAt) - new Date()) / (1000 * 60 * 60 * 24));
│       return days;
│     };
│   
│     const getToneForUsage = () => {
│       if (isUnlimited) return 'success';
│       if (percentage >= 90) return 'critical';
│       if (percentage >= 75) return 'warning';
│       return 'success';
│     };
│   
│     const tone = getToneForUsage();
│     const daysUntilReset = getDaysUntilReset();
│   
│     return (
│       <Card>
│         <BlockStack gap="400">
│           <InlineStack align="space-between">
│             <Text variant="headingMd" as="h2">Credit Usage</Text>
│             {!isUnlimited && percentage >= 75 && (
│               <Badge tone={tone}>
│                 {percentage >= 90 ? 'Low Credits' : 'Monitor Usage'}
│               </Badge>
│             )}
│           </InlineStack>
│   
│           {isUnlimited ? (
│             <BlockStack gap="300">
│               <InlineStack gap="200" blockAlign="center">
│                 <Badge tone="success">Unlimited Credits</Badge>
│                 <Text>Enterprise Plan</Text>
│               </InlineStack>
│               <Text tone="subdued">
│                 Your plan includes unlimited credits for selfie processing.
│               </Text>
│             </BlockStack>
│           ) : (
│             <BlockStack gap="300">
│               <BlockStack gap="200">
│                 <InlineStack align="space-between">
│                   <Text variant="headingLg">
│                     {used.toLocaleString()} / {limit.toLocaleString()}
│                   </Text>
│                   <Text tone="subdued">
│                     {remaining.toLocaleString()} remaining
│                   </Text>
│                 </InlineStack>
│                 <ProgressBar 
│                   progress={percentage} 
│                   tone={tone}
│                   size="small"
│                 />
│               </BlockStack>
│   
│               <InlineStack align="space-between">
│                 <Text tone="subdued">
│                   {Math.round(percentage)}% used this period
│                 </Text>
│                 {daysUntilReset && (
│                   <Text tone="subdued">
│                     Resets in {daysUntilReset} {daysUntilReset === 1 ? 'day' : 'days'}
│                   </Text>
│                 )}
│               </InlineStack>
│   
│               {percentage >= 90 && (
│                 <InlineStack gap="200" blockAlign="center">
│                   <Icon source={AlertCircleIcon} tone="critical" />
│                   <Text tone="critical">
│                     You're running low on credits. Consider upgrading your plan.
│                   </Text>
│                 </InlineStack>
│               )}
│   
│               {percentage >= 100 && (
│                 <BlockStack gap="200">
│                   <Banner tone="critical">
│                     <Text>
│                       Credit limit reached. New selfie requests will be blocked until your credits reset
│                       {daysUntilReset && ` in ${daysUntilReset} days`}.
│                     </Text>
│                   </Banner>
│                   <Button primary url="/app/billing">
│                     Upgrade Plan
│                   </Button>
│                 </BlockStack>
│               )}
│             </BlockStack>
│           )}
│   
│           <BlockStack gap="200">
│             <Text variant="headingSm" tone="subdued">Credit Usage Breakdown</Text>
│             <BlockStack gap="100">
│               <InlineStack align="space-between">
│                 <Text tone="subdued">Selfie processing</Text>
│                 <Text>{Math.round(used * 0.7).toLocaleString()} credits</Text>
│               </InlineStack>
│               <InlineStack align="space-between">
│                 <Text tone="subdued">Recommendations generated</Text>
│                 <Text>{Math.round(used * 0.3).toLocaleString()} credits</Text>
│               </InlineStack>
│             </BlockStack>
│           </BlockStack>
│   
│           {!isUnlimited && (
│             <InlineStack gap="200">
│               <Button plain>View detailed usage</Button>
│               {percentage >= 75 && (
│                 <Button plain>Set up usage alerts</Button>
│               )}
│             </InlineStack>
│           )}
│         </BlockStack>
│       </Card>
│     );
│   }
│   ```
│   
├── DashboardStats.jsx
│   
│   ```jsx
│   import { Grid, Card, Text, BlockStack, InlineStack, Badge, Icon } from "@shopify/polaris";
│   import { CameraIcon, CreditCardIcon, ProductIcon } from "@shopify/polaris-icons";
│   
│   export default function DashboardStats({ 
│     selfiesToday, 
│     creditsRemaining, 
│     creditsLimit, 
│     syncStatus, 
│     productCount 
│   }) {
│     const stats = [
│       {
│         title: 'Selfies Today',
│         value: selfiesToday.toLocaleString(),
│         icon: CameraIcon,
│         tone: 'base'
│       },
│       {
│         title: 'Credits Remaining',
│         value: `${creditsRemaining.toLocaleString()} / ${creditsLimit.toLocaleString()}`,
│         icon: CreditCardIcon,
│         tone: creditsRemaining < creditsLimit * 0.1 ? 'critical' : 'success'
│       },
│       {
│         title: 'Catalog Status',
│         value: productCount > 0 ? `${productCount} products` : 'Not synced',
│         icon: ProductIcon,
│         tone: syncStatus === 'error' ? 'critical' : productCount > 0 ? 'success' : 'warning'
│       }
│     ];
│   
│     return (
│       <Grid>
│         {stats.map((stat, index) => (
│           <Grid.Cell key={index} columnSpan={{ xs: 6, sm: 6, md: 4, lg: 4, xl: 4 }}>
│             <Card>
│               <BlockStack gap="300">
│                 <InlineStack align="space-between">
│                   <Icon source={stat.icon} tone={stat.tone} />
│                   <Badge tone={stat.tone}>{stat.tone === 'success' ? 'Good' : stat.tone === 'critical' ? 'Alert' : 'Info'}</Badge>
│                 </InlineStack>
│                 <BlockStack gap="200">
│                   <Text tone="subdued" variant="bodyMd">{stat.title}</Text>
│                   <Text variant="headingLg" as="p">{stat.value}</Text>
│                 </BlockStack>
│               </BlockStack>
│             </Card>
│           </Grid.Cell>
│         ))}
│       </Grid>
│     );
│   }
│   ```
│   
├── LoadingState.jsx
│   
│   ```jsx
│   import { Card, SkeletonBodyText, SkeletonDisplayText, BlockStack, Layout, SkeletonThumbnail, InlineStack } from "@shopify/polaris";
│   
│   export function LoadingState({ type = 'page' }) {
│     if (type === 'card') {
│       return (
│         <Card>
│           <BlockStack gap="400">
│             <SkeletonDisplayText size="small" />
│             <SkeletonBodyText lines={3} />
│           </BlockStack>
│         </Card>
│       );
│     }
│   
│     if (type === 'table') {
│       return (
│         <Card>
│           <BlockStack gap="400">
│             <SkeletonDisplayText size="small" />
│             <BlockStack gap="200">
│               {[...Array(5)].map((_, i) => (
│                 <InlineStack key={i} gap="400" align="space-between">
│                   <SkeletonBodyText lines={1} />
│                   <SkeletonBodyText lines={1} />
│                   <SkeletonBodyText lines={1} />
│                   <SkeletonBodyText lines={1} />
│                 </InlineStack>
│               ))}
│             </BlockStack>
│           </BlockStack>
│         </Card>
│       );
│     }
│   
│     if (type === 'stats') {
│       return (
│         <InlineStack gap="400">
│           {[...Array(3)].map((_, i) => (
│             <Card key={i}>
│               <BlockStack gap="300">
│                 <SkeletonThumbnail size="small" />
│                 <SkeletonDisplayText size="small" />
│                 <SkeletonBodyText lines={1} />
│               </BlockStack>
│             </Card>
│           ))}
│         </InlineStack>
│       );
│     }
│   
│     // Default: full page loading
│     return (
│       <Layout>
│         <Layout.Section>
│           <Card>
│             <BlockStack gap="400">
│               <SkeletonDisplayText size="medium" />
│               <SkeletonBodyText lines={2} />
│             </BlockStack>
│           </Card>
│         </Layout.Section>
│         <Layout.Section>
│           <Card>
│             <BlockStack gap="400">
│               <SkeletonDisplayText size="small" />
│               <SkeletonBodyText lines={4} />
│             </BlockStack>
│           </Card>
│         </Layout.Section>
│         <Layout.Section>
│           <Card>
│             <BlockStack gap="400">
│               <SkeletonDisplayText size="small" />
│               <SkeletonBodyText lines={3} />
│             </BlockStack>
│           </Card>
│         </Layout.Section>
│       </Layout>
│     );
│   }
│   
│   export function LoadingDashboard() {
│     return (
│       <Layout>
│         <Layout.Section>
│           <Card>
│             <BlockStack gap="400">
│               <InlineStack gap="400" align="space-between">
│                 <BlockStack gap="200">
│                   <SkeletonDisplayText size="medium" />
│                   <SkeletonBodyText lines={1} />
│                 </BlockStack>
│                 <SkeletonThumbnail size="medium" />
│               </InlineStack>
│             </BlockStack>
│           </Card>
│         </Layout.Section>
│         <Layout.Section>
│           <InlineStack gap="400">
│             {[...Array(3)].map((_, i) => (
│               <Card key={i}>
│                 <BlockStack gap="300">
│                   <InlineStack align="space-between">
│                     <SkeletonThumbnail size="small" />
│                     <SkeletonBodyText lines={1} />
│                   </InlineStack>
│                   <SkeletonBodyText lines={1} />
│                   <SkeletonDisplayText size="small" />
│                 </BlockStack>
│               </Card>
│             ))}
│           </InlineStack>
│         </Layout.Section>
│         <Layout.Section>
│           <Card>
│             <BlockStack gap="400">
│               <SkeletonDisplayText size="small" />
│               <SkeletonBodyText lines={3} />
│             </BlockStack>
│           </Card>
│         </Layout.Section>
│       </Layout>
│     );
│   }
│   
│   export function LoadingInline() {
│     return <SkeletonBodyText lines={1} />;
│   }
│   
│   export default LoadingState;
│   ```
│   
└── SubscriptionStatus.jsx
    
    ```jsx
    import { CalloutCard, Text, Badge, InlineStack, BlockStack } from "@shopify/polaris";
    
    export default function SubscriptionStatus({ subscription, onStartTrial, onViewPlans }) {
      const getStatusContent = () => {
        if (subscription.status === 'inactive') {
          return {
            title: "Start your free 14-day trial",
            description: "Get 500 credits to test selfie-based recommendations",
            primaryAction: {
              content: "Start Free Trial",
              onAction: onStartTrial
            },
            tone: "info"
          };
        }
    
        if (subscription.status === 'trial') {
          const daysLeft = Math.ceil(
            (new Date(subscription.trialEndsAt) - new Date()) / (1000 * 60 * 60 * 24)
          );
          
          return {
            title: `Free trial: ${daysLeft} days remaining`,
            description: "Choose a plan to continue after your trial ends",
            primaryAction: {
              content: "View Plans",
              onAction: onViewPlans
            },
            tone: daysLeft <= 3 ? "warning" : "info"
          };
        }
    
        if (subscription.status === 'active') {
          return {
            title: `${subscription.plan.charAt(0).toUpperCase() + subscription.plan.slice(1)} Plan Active`,
            description: `Next billing date: ${new Date(subscription.nextBillingDate).toLocaleDateString()}`,
            primaryAction: {
              content: "Manage Billing",
              onAction: onViewPlans
            },
            tone: "success"
          };
        }
    
        if (subscription.status === 'expired') {
          return {
            title: "Trial expired",
            description: "Choose a plan to continue using Glam You Up",
            primaryAction: {
              content: "View Plans",
              onAction: onViewPlans
            },
            tone: "critical"
          };
        }
      };
    
      const content = getStatusContent();
    
      return (
        <CalloutCard
          title={content.title}
          illustration="https://cdn.shopify.com/s/files/1/0583/6465/7734/files/tag.svg?v=1701930959"
          primaryAction={content.primaryAction}
        >
          <Text>{content.description}</Text>
        </CalloutCard>
      );
    }
    ```
    
lib/
└── apiClient.js
    
    ```js
    // apps/shopify-bff/app/lib/apiClient.js
    import jwt from "jsonwebtoken";
    
    const svc = {
      merchant:  process.env.MERCHANT_URL,   // e.g. http://merchant-service:8000/
      catalog:   process.env.CATALOG_URL,    // e.g. http://catalog-service:8000/
      credits:   process.env.CREDITS_URL,
      analytics: process.env.ANALYTICS_URL,
      webhook:   process.env.WEBHOOK_URL,    // e.g. http://localhost:8010/  (base only)
    };
    
    
    function signJwt(shop) {
      const token = jwt.sign(
        { sub: shop, scope: "bff:call", iat: Math.floor(Date.now() / 1000) },
        process.env.INTERNAL_JWT_SECRET,
        { expiresIn: "180s", algorithm: "HS256" },
      );
      if (!token) throw new Error("Failed to create internal JWT");
      return token;
    }
    
    function addHeaders(shop, { webhookId = null, topic = null } = {}) {
      const token = signJwt(shop);
    
      const headers = {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        "X-Shopify-Shop-Domain": shop,
      };
      if (webhookId) headers["X-ShopifyWebhook-Id"] = webhookId;
      if (topic) headers["X-Shopify-Topic"] = topic;
      return headers;
    }
    
    function buildUrl(base, path) {
      if (!base) throw new Error("API base URL not set");
      const baseNorm = base.endsWith("/") ? base : base + "/";
      const pathNorm = path.startsWith("/") ? path : "/" + path;
      return `${baseNorm}api/v1${pathNorm}`;
    }
    
    async function callAndForget(base, path, { method = "GET", shop, body, webhookId, topic } = {}) {
      const url = buildUrl(base, path);
      const headers = addHeaders(shop, { webhookId, topic });
      const controller = new AbortController();
      setTimeout(() => controller.abort(), 1500); // don’t hang; we’re not awaiting
      fetch(url, {
        method,
        signal: controller.signal,
        headers,
        body: body ? JSON.stringify(body) : undefined,
      }).catch((e) => console.error(`[API call ${method} ${url}] failed:`, e?.message || e));
    }
    
    async function call(base, path, { method = "GET", shop, body } = {}) {
      const url = buildUrl(base, path);
      const res = await fetch(url, {
        method,
        headers: addHeaders(shop),
        body: body ? JSON.stringify(body) : undefined,
      });
      const json = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(json?.error?.message || `API ${res.status}`);
      return json?.data ?? json;
    }
    
    export default {
      // Merchant
      syncShop: (payload) =>
        call(svc.merchant, "/merchants/sync", {
          method: "POST",
          shop: payload.myshopifyDomain,
          body: payload,
        }),
    
      startTrial: (shop) =>
        call(svc.merchant, "/merchants/trial", {
          method: "POST",
          shop,
          body: { shop },
        }),
    
      createSubscription: (shop, plan, id) =>
        call(svc.merchant, "/billing/subscription", {
          method: "POST",
          shop,
          body: { shop, plan, charge_id: id },
        }),
    
      getMerchantStatus: (shop) =>
        call(svc.merchant, `/merchants/status?shop=${shop}`, { shop }),
    
      // Catalog
      syncCatalog: (shop) =>
        call(svc.catalog, "/catalog/sync", {
          method: "POST",
          shop,
          body: { shop },
        }),
    
      getCatalogStatus: (shop) =>
        call(svc.catalog, `/catalog/status?shop=${shop}`, { shop }),
    
      // Credits
      getCreditsStatus: (shop) =>
        call(svc.credits, `/credits/status?shop=${shop}`, { shop }),
    
      // Analytics
      getAnalytics: (shop, from, to) =>
        call(svc.analytics, `/analysis/overview?shop=${shop}&from=${from}&to=${to}`, { shop }),
    
      // Webhooks (fire-and-forget)
      relayShopifyWebhook: ({ topic, shop, payload, webhookId }) =>
        callAndForget(svc.webhook, "/webhooks/shopify", {
          method: "POST",
          shop, 
          body: payload,
          webhookId,
          topic,            
        }),
    };
    ```
    
routes/
├── _index/
│   ├── route.jsx
│   │   
│   │   ```jsx
│   │   import { redirect } from "@remix-run/node";
│   │   import { Form, useLoaderData } from "@remix-run/react";
│   │   import { login } from "../../shopify.server";
│   │   import styles from "./styles.module.css";
│   │   
│   │   export const loader = async ({ request }) => {
│   │     const url = new URL(request.url);
│   │   
│   │     if (url.searchParams.get("shop")) {
│   │       throw redirect(`/app?${url.searchParams.toString()}`);
│   │     }
│   │   
│   │     return { showForm: Boolean(login) };
│   │   };
│   │   
│   │   export default function App() {
│   │     const { showForm } = useLoaderData();
│   │   
│   │     return (
│   │       <div className={styles.index}>
│   │         <div className={styles.content}>
│   │           <h1 className={styles.heading}>A short heading about [your app]</h1>
│   │           <p className={styles.text}>
│   │             A tagline about [your app] that describes your value proposition.
│   │           </p>
│   │           {showForm && (
│   │             <Form className={styles.form} method="post" action="/auth/login">
│   │               <label className={styles.label}>
│   │                 <span>Shop domain</span>
│   │                 <input className={styles.input} type="text" name="shop" />
│   │                 <span>e.g: my-shop-domain.myshopify.com</span>
│   │               </label>
│   │               <button className={styles.button} type="submit">
│   │                 Log in
│   │               </button>
│   │             </Form>
│   │           )}
│   │           <ul className={styles.list}>
│   │             <li>
│   │               <strong>Product feature</strong>. Some detail about your feature and
│   │               its benefit to your customer.
│   │             </li>
│   │             <li>
│   │               <strong>Product feature</strong>. Some detail about your feature and
│   │               its benefit to your customer.
│   │             </li>
│   │             <li>
│   │               <strong>Product feature</strong>. Some detail about your feature and
│   │               its benefit to your customer.
│   │             </li>
│   │           </ul>
│   │         </div>
│   │       </div>
│   │     );
│   │   }
│   │   ```
│   │   
│   └── styles.module.css
│       
│       ```css
│       .index {
│         align-items: center;
│         display: flex;
│         justify-content: center;
│         height: 100%;
│         width: 100%;
│         text-align: center;
│         padding: 1rem;
│       }
│       
│       .heading,
│       .text {
│         padding: 0;
│         margin: 0;
│       }
│       
│       .text {
│         font-size: 1.2rem;
│         padding-bottom: 2rem;
│       }
│       
│       .content {
│         display: grid;
│         gap: 2rem;
│       }
│       
│       .form {
│         display: flex;
│         align-items: center;
│         justify-content: flex-start;
│         margin: 0 auto;
│         gap: 1rem;
│       }
│       
│       .label {
│         display: grid;
│         gap: 0.2rem;
│         max-width: 20rem;
│         text-align: left;
│         font-size: 1rem;
│       }
│       
│       .input {
│         padding: 0.4rem;
│       }
│       
│       .button {
│         padding: 0.4rem;
│       }
│       
│       .list {
│         list-style: none;
│         padding: 0;
│         padding-top: 3rem;
│         margin: 0;
│         display: flex;
│         gap: 2rem;
│       }
│       
│       .list > li {
│         max-width: 20rem;
│         text-align: left;
│       }
│       
│       @media only screen and (max-width: 50rem) {
│         .list {
│           display: block;
│         }
│       
│         .list > li {
│           padding-bottom: 1rem;
│         }
│       }
│       ```
│       
├── auth.login/
│   ├── error.server.jsx
│   │   
│   │   ```jsx
│   │   import { LoginErrorType } from "@shopify/shopify-app-remix/server";
│   │   
│   │   export function loginErrorMessage(loginErrors) {
│   │     if (loginErrors?.shop === LoginErrorType.MissingShop) {
│   │       return { shop: "Please enter your shop domain to log in" };
│   │     } else if (loginErrors?.shop === LoginErrorType.InvalidShop) {
│   │       return { shop: "Please enter a valid shop domain to log in" };
│   │     }
│   │   
│   │     return {};
│   │   }
│   │   ```
│   │   
│   └── route.jsx
│       
│       ```jsx
│       import { useState } from "react";
│       import { Form, useActionData, useLoaderData } from "@remix-run/react";
│       import {
│         AppProvider as PolarisAppProvider,
│         Button,
│         Card,
│         FormLayout,
│         Page,
│         Text,
│         TextField,
│       } from "@shopify/polaris";
│       import polarisTranslations from "@shopify/polaris/locales/en.json";
│       import polarisStyles from "@shopify/polaris/build/esm/styles.css?url";
│       import { login } from "../../shopify.server";
│       import { loginErrorMessage } from "./error.server";
│       
│       export const links = () => [{ rel: "stylesheet", href: polarisStyles }];
│       
│       export const loader = async ({ request }) => {
│         const errors = loginErrorMessage(await login(request));
│       
│         return { errors, polarisTranslations };
│       };
│       
│       export const action = async ({ request }) => {
│         const errors = loginErrorMessage(await login(request));
│       
│         return {
│           errors,
│         };
│       };
│       
│       export default function Auth() {
│         const loaderData = useLoaderData();
│         const actionData = useActionData();
│         const [shop, setShop] = useState("");
│         const { errors } = actionData || loaderData;
│       
│         return (
│           <PolarisAppProvider i18n={loaderData.polarisTranslations}>
│             <Page>
│               <Card>
│                 <Form method="post">
│                   <FormLayout>
│                     <Text variant="headingMd" as="h2">
│                       Log in
│                     </Text>
│                     <TextField
│                       type="text"
│                       name="shop"
│                       label="Shop domain"
│                       helpText="example.myshopify.com"
│                       value={shop}
│                       onChange={setShop}
│                       autoComplete="on"
│                       error={errors.shop}
│                     />
│                     <Button submit>Log in</Button>
│                   </FormLayout>
│                 </Form>
│               </Card>
│             </Page>
│           </PolarisAppProvider>
│         );
│       }
│       ```
│       
├── app._index.jsx
│   
│   ```jsx
│   import { useLoaderData, useFetcher, useNavigate } from "@remix-run/react";
│   import { Page, Layout, Card, Button, Text, Badge, CalloutCard, DataTable, ProgressBar, Grid, BlockStack, InlineStack, Box } from "@shopify/polaris";
│   import { authenticate } from "../shopify.server";
│   import apiClient from "../lib/apiClient";
│   import { useState, useEffect } from "react";
│   import DashboardStats from "../components/DashboardStats";
│   import SubscriptionStatus from "../components/SubscriptionStatus";
│   
│   export const loader = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const shop = session.shop;
│   
│     // Fetch data from external API
│     const [merchantStatus, creditsStatus, catalogStatus, analytics] = await Promise.all([
│       apiClient.getMerchantStatus(shop),
│       apiClient.getCreditsStatus(shop),
│       apiClient.getCatalogStatus(shop),
│       apiClient.getAnalytics(shop, 
│         new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
│         new Date().toISOString()
│       )
│     ]);
│   
│     return Response.json({
│       shop,
│       subscription: merchantStatus.data || {
│         status: 'inactive',
│         plan: null,
│         trialEndsAt: null,
│         nextBillingDate: null
│       },
│       credits: creditsStatus.data || {
│         used: 0,
│         limit: 0,
│         resetsAt: null
│       },
│       catalog: catalogStatus.data || {
│         productCount: 0,
│         lastSyncAt: null,
│         syncStatus: 'idle'
│       },
│       analytics: analytics.data || {
│         selfiesToday: 0,
│         recommendationsToday: 0
│       }
│     });
│   };
│   
│   export const action = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const formData = await request.formData();
│     const action = formData.get("action");
│   
│     if (action === "start_trial") {
│       const result = await apiClient.startTrial(session.shop);
│       return Response.json(result);
│     }
│   
│     if (action === "sync_catalog") {
│       const result = await apiClient.syncCatalog(session.shop);
│       return Response(result);
│     }
│   
│     return Response.json({ error: "Invalid action" });
│   };
│   
│   export default function Index() {
│     const { shop, subscription, credits, catalog, analytics } = useLoaderData();
│     const fetcher = useFetcher();
│     const navigate = useNavigate();
│     const [syncProgress, setSyncProgress] = useState(null);
│   
│     // WebSocket for catalog sync progress
│     useEffect(() => {
│       if (fetcher.data?.websocket_url) {
│         const ws = new WebSocket(fetcher.data.websocket_url);
│         
│         ws.onmessage = (event) => {
│           const data = JSON.parse(event.data);
│           if (data.type === 'progress') {
│             setSyncProgress({
│               percent: (data.processed / data.total) * 100,
│               message: data.message
│             });
│           } else if (data.type === 'complete') {
│             setSyncProgress(null);
│             ws.close();
│             // Reload page to get updated data
│             window.location.reload();
│           }
│         };
│   
│         ws.onerror = () => {
│           setSyncProgress(null);
│           ws.close();
│         };
│   
│         return () => ws.close();
│       }
│     }, [fetcher.data]);
│   
│     const handleStartTrial = () => {
│       fetcher.submit(
│         { action: "start_trial" },
│         { method: "post" }
│       );
│     };
│   
│     const handleSyncCatalog = () => {
│       fetcher.submit(
│         { action: "sync_catalog" },
│         { method: "post" }
│       );
│     };
│   
│     const checklistItems = [
│       {
│         label: subscription.status === 'inactive' ? 'Start free trial' : 'Subscription active',
│         completed: subscription.status !== 'inactive',
│         action: subscription.status === 'inactive' ? handleStartTrial : null
│       },
│       {
│         label: catalog.productCount > 0 ? `${catalog.productCount} products synced` : 'Sync catalog',
│         completed: catalog.productCount > 0,
│         action: catalog.productCount === 0 ? handleSyncCatalog : null
│       },
│       {
│         label: 'View analytics',
│         completed: analytics.selfiesToday > 0 || analytics.recommendationsToday > 0,
│         action: () => navigate('/app/analytics')
│       }
│     ];
│   
│     return (
│       <Page>
│         <Layout>
│           <Layout.Section>
│             <SubscriptionStatus 
│               subscription={subscription}
│               onStartTrial={handleStartTrial}
│               onViewPlans={() => navigate('/app/billing')}
│             />
│           </Layout.Section>
│   
│           <Layout.Section>
│             <DashboardStats
│               selfiesToday={analytics.selfiesToday}
│               creditsRemaining={credits.limit - credits.used}
│               creditsLimit={credits.limit}
│               syncStatus={catalog.syncStatus}
│               productCount={catalog.productCount}
│             />
│           </Layout.Section>
│   
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="400">
│                 <Text variant="headingMd" as="h2">Getting Started</Text>
│                 <ProgressBar 
│                   size="small"
│                   progress={checklistItems.filter(item => item.completed).length * 33.33}
│                 />
│                 <BlockStack gap="300">
│                   {checklistItems.map((item, index) => (
│                     <InlineStack key={index} align="space-between" blockAlign="center">
│                       <InlineStack gap="200" blockAlign="center">
│                         <Box>
│                           {item.completed ? (
│                             <Badge tone="success">✓</Badge>
│                           ) : (
│                             <Badge>Pending</Badge>
│                           )}
│                         </Box>
│                         <Text>{item.label}</Text>
│                       </InlineStack>
│                       {item.action && !item.completed && (
│                         <Button size="slim" onClick={item.action}>
│                           Complete
│                         </Button>
│                       )}
│                     </InlineStack>
│                   ))}
│                 </BlockStack>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│   
│           {syncProgress && (
│             <Layout.Section>
│               <CalloutCard
│                 title="Syncing catalog..."
│                 illustration="https://cdn.shopify.com/s/files/1/0583/6465/7734/files/tag.svg?v=1701930959"
│                 primaryAction={{
│                   content: `${Math.round(syncProgress.percent)}% Complete`,
│                   disabled: true
│                 }}
│               >
│                 <Text>{syncProgress.message}</Text>
│               </CalloutCard>
│             </Layout.Section>
│           )}
│         </Layout>
│       </Page>
│     );
│   }
│   
│   export function ErrorBoundary({ error }) {
│     return (
│       <Page>
│         <Layout>
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="300">
│                 <Text variant="headingMd" as="h2">Something went wrong</Text>
│                 <Text tone="critical">{error.message}</Text>
│                 <Button url="/app" primary>
│                   Return to dashboard
│                 </Button>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│         </Layout>
│       </Page>
│     );
│   }
│   ```
│   
├── app.analytics.jsx
│   
│   ```jsx
│   import { useLoaderData, useFetcher } from "@remix-run/react";
│   import { 
│     Page, 
│     Layout, 
│     Card, 
│     Text, 
│     DatePicker, 
│     Select, 
│     Button, 
│     DataTable, 
│     BlockStack, 
│     InlineStack, 
│     Badge, 
│     Grid, 
│     Popover,
│     Banner,
│     SkeletonBodyText,
│     SkeletonDisplayText
│   } from "@shopify/polaris";
│   import { authenticate } from "../shopify.server";
│   import apiClient from "../lib/apiClient";
│   import { useState, useCallback } from "react";
│   
│   export const loader = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const shop = session.shop;
│   
│     const url = new URL(request.url);
│     const from = url.searchParams.get('from') || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
│     const to = url.searchParams.get('to') || new Date().toISOString();
│   
│     const analytics = await apiClient.getAnalytics(shop, from, to);
│   
│     return Response.json({
│       shop,
│       analytics: analytics.data || {
│         selfie_uploads: { total: 0, by_day: [] },
│         recommendations: { total: 0, click_through_rate: 0, by_product: [] },
│         conversion_metrics: { 
│           views: 0, 
│           clicks: 0, 
│           purchases: 0,
│           return_rate_before: 0,
│           return_rate_after: 0
│         }
│       },
│       dateRange: { from, to }
│     });
│   };
│   
│   export const action = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const formData = await request.formData();
│     const action = formData.get("action");
│   
│     if (action === "export") {
│       const from = formData.get("from");
│       const to = formData.get("to");
│       const format = formData.get("format");
│       
│       // In real implementation, this would trigger a download
│       // For now, we'll just return success
│       return Response.json({ 
│         success: true, 
│         message: `Export initiated in ${format} format` 
│       });
│     }
│   
│     return Response.json({ error: "Invalid action" });
│   };
│   
│   export default function Analytics() {
│     const { shop, analytics, dateRange } = useLoaderData();
│     const fetcher = useFetcher();
│     const [selectedDateRange, setSelectedDateRange] = useState({
│       start: new Date(dateRange.from),
│       end: new Date(dateRange.to)
│     });
│     const [datePickerActive, setDatePickerActive] = useState(false);
│     const [exportFormat, setExportFormat] = useState('csv');
│   
│     const handleDateChange = useCallback((value) => {
│       setSelectedDateRange(value);
│     }, []);
│   
│     const handleApplyDateRange = () => {
│       window.location.href = `/app/analytics?from=${selectedDateRange.start.toISOString()}&to=${selectedDateRange.end.toISOString()}`;
│     };
│   
│     const handleExport = () => {
│       fetcher.submit(
│         { 
│           action: "export",
│           from: selectedDateRange.start.toISOString(),
│           to: selectedDateRange.end.toISOString(),
│           format: exportFormat
│         },
│         { method: "post" }
│       );
│     };
│   
│     // Calculate key metrics
│     const conversionRate = analytics.recommendations.total > 0 
│       ? ((analytics.recommendations.click_through_rate * 100).toFixed(2))
│       : '0.00';
│   
│     const returnRateReduction = analytics.conversion_metrics.return_rate_before > 0
│       ? (((analytics.conversion_metrics.return_rate_before - analytics.conversion_metrics.return_rate_after) / analytics.conversion_metrics.return_rate_before * 100).toFixed(1))
│       : '0.0';
│   
│     // Prepare chart data
│     const chartData = analytics.selfie_uploads.by_day.map(day => ({
│       date: new Date(day.date).toLocaleDateString(),
│       selfies: day.count,
│       recommendations: day.recommendations || 0
│     }));
│   
│     // Top performing products table
│     const topProductsRows = (analytics.recommendations.by_product || [])
│       .slice(0, 10)
│       .map(product => [
│         product.name,
│         product.recommendations.toString(),
│         product.clicks.toString(),
│         `${((product.clicks / product.recommendations) * 100).toFixed(1)}%`,
│         <Badge key={product.name} tone={product.conversion_rate > 0.3 ? 'success' : 'info'}>
│           {(product.conversion_rate * 100).toFixed(1)}%
│         </Badge>
│       ]);
│   
│     // Loading state
│     if (fetcher.state === 'loading') {
│       return (
│         <Page title="Analytics" breadcrumbs={[{ content: 'Dashboard', url: '/app' }]}>
│           <Layout>
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <SkeletonDisplayText size="small" />
│                   <SkeletonBodyText lines={3} />
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           </Layout>
│         </Page>
│       );
│     }
│   
│     return (
│       <Page
│         title="Analytics"
│         breadcrumbs={[{ content: 'Dashboard', url: '/app' }]}
│         primaryAction={{
│           content: 'Export Data',
│           onAction: handleExport
│         }}
│       >
│         <Layout>
│           {fetcher.data?.success && (
│             <Layout.Section>
│               <Banner
│                 title="Export started"
│                 tone="success"
│                 onDismiss={() => {}}
│               >
│                 <Text>{fetcher.data.message}</Text>
│               </Banner>
│             </Layout.Section>
│           )}
│   
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="400">
│                 <InlineStack align="space-between">
│                   <Text variant="headingMd" as="h2">Date Range</Text>
│                   <Popover
│                     active={datePickerActive}
│                     activator={
│                       <Button onClick={() => setDatePickerActive(!datePickerActive)}>
│                         {selectedDateRange.start.toLocaleDateString()} - {selectedDateRange.end.toLocaleDateString()}
│                       </Button>
│                     }
│                     onClose={() => setDatePickerActive(false)}
│                   >
│                     <Card>
│                       <BlockStack gap="400">
│                         <DatePicker
│                           month={selectedDateRange.start.getMonth()}
│                           year={selectedDateRange.start.getFullYear()}
│                           onChange={handleDateChange}
│                           selectedDates={selectedDateRange}
│                           allowRange
│                         />
│                         <InlineStack gap="200">
│                           <Button primary onClick={handleApplyDateRange}>
│                             Apply
│                           </Button>
│                           <Button onClick={() => setDatePickerActive(false)}>
│                             Cancel
│                           </Button>
│                         </InlineStack>
│                       </BlockStack>
│                     </Card>
│                   </Popover>
│                 </InlineStack>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│   
│           <Layout.Section>
│             <Grid>
│               <Grid.Cell columnSpan={{ xs: 6, sm: 3, md: 3, lg: 3, xl: 3 }}>
│                 <Card>
│                   <BlockStack gap="200">
│                     <Text tone="subdued">Total Selfies</Text>
│                     <Text variant="heading2xl">{analytics.selfie_uploads.total.toLocaleString()}</Text>
│                     <Badge tone="success">Active</Badge>
│                   </BlockStack>
│                 </Card>
│               </Grid.Cell>
│               <Grid.Cell columnSpan={{ xs: 6, sm: 3, md: 3, lg: 3, xl: 3 }}>
│                 <Card>
│                   <BlockStack gap="200">
│                     <Text tone="subdued">Recommendations</Text>
│                     <Text variant="heading2xl">{analytics.recommendations.total.toLocaleString()}</Text>
│                     <Text tone="subdued">Generated</Text>
│                   </BlockStack>
│                 </Card>
│               </Grid.Cell>
│               <Grid.Cell columnSpan={{ xs: 6, sm: 3, md: 3, lg: 3, xl: 3 }}>
│                 <Card>
│                   <BlockStack gap="200">
│                     <Text tone="subdued">Click Rate</Text>
│                     <Text variant="heading2xl">{conversionRate}%</Text>
│                     <Badge tone={parseFloat(conversionRate) > 30 ? 'success' : 'attention'}>
│                       {parseFloat(conversionRate) > 30 ? 'Good' : 'Improve'}
│                     </Badge>
│                   </BlockStack>
│                 </Card>
│               </Grid.Cell>
│               <Grid.Cell columnSpan={{ xs: 6, sm: 3, md: 3, lg: 3, xl: 3 }}>
│                 <Card>
│                   <BlockStack gap="200">
│                     <Text tone="subdued">Return Rate ↓</Text>
│                     <Text variant="heading2xl">{returnRateReduction}%</Text>
│                     <Badge tone="success">Reduced</Badge>
│                   </BlockStack>
│                 </Card>
│               </Grid.Cell>
│             </Grid>
│           </Layout.Section>
│   
│           {chartData.length > 0 && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <Text variant="headingMd" as="h2">Usage Trends</Text>
│                   <BlockStack gap="200">
│                     <Text tone="subdued">Daily activity over selected period (last 7 days shown)</Text>
│                     <DataTable
│                       columnContentTypes={['text', 'numeric', 'numeric']}
│                       headings={['Date', 'Selfies', 'Recommendations']}
│                       rows={chartData.slice(-7).map(d => [d.date, d.selfies, d.recommendations])}
│                     />
│                   </BlockStack>
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│   
│           {topProductsRows.length > 0 && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <InlineStack align="space-between">
│                     <Text variant="headingMd" as="h2">Top Performing Products</Text>
│                     <Button plain>View all products</Button>
│                   </InlineStack>
│                   <DataTable
│                     columnContentTypes={['text', 'numeric', 'numeric', 'numeric', 'text']}
│                     headings={['Product', 'Recommendations', 'Clicks', 'CTR', 'Conversion']}
│                     rows={topProductsRows}
│                   />
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│   
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="400">
│                 <Text variant="headingMd" as="h2">Export Analytics</Text>
│                 <InlineStack gap="300">
│                   <Select
│                     label="Format"
│                     options={[
│                       { label: 'CSV', value: 'csv' },
│                       { label: 'Excel', value: 'xlsx' },
│                       { label: 'Response.json', value: 'Response.json' }
│                     ]}
│                     value={exportFormat}
│                     onChange={setExportFormat}
│                   />
│                   <Button primary onClick={handleExport} loading={fetcher.state === 'submitting'}>
│                     Export {exportFormat.toUpperCase()}
│                   </Button>
│                 </InlineStack>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│         </Layout>
│       </Page>
│     );
│   }
│   
│   export function ErrorBoundary({ error }) {
│     return (
│       <Page title="Analytics">
│         <Layout>
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="300">
│                 <Text variant="headingMd" as="h2">Unable to load analytics</Text>
│                 <Text tone="critical">{error.message}</Text>
│                 <Button url="/app" primary>
│                   Return to dashboard
│                 </Button>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│         </Layout>
│       </Page>
│     );
│   }
│   ```
│   
├── app.billing.jsx
│   
│   ```jsx
│   import { json } from "@remix-run/node";
│   import { useLoaderData, useFetcher } from "@remix-run/react";
│   import { Page, Layout, Card, Text, Button, Banner, ProgressBar, Grid, BlockStack, InlineStack, Badge, DataTable } from "@shopify/polaris";
│   import { authenticate } from "../shopify.server";
│   import apiClient from "../lib/apiClient";
│   import BillingPlans from "../components/BillingPlans";
│   import CreditUsage from "../components/CreditUsage";
│   
│   export const loader = async ({ request }) => {
│     const { session, billing } = await authenticate.admin(request);
│     const shop = session.shop;
│   
│     const [merchantStatus, creditsStatus] = await Promise.all([
│       apiClient.getMerchantStatus(shop),
│       apiClient.getCreditsStatus(shop)
│     ]);
│   
│     return json({
│       shop,
│       subscription: merchantStatus.data,
│       credits: creditsStatus.data,
│       billing
│     });
│   };
│   
│   export const action = async ({ request }) => {
│     const { session, billing } = await authenticate.admin(request);
│     const formData = await request.formData();
│     const plan = formData.get("plan");
│   
│     // Create Shopify recurring charge
│     const planDetails = {
│       starter: { price: 29, credits: 1000 },
│       growth: { price: 99, credits: 5000 },
│       enterprise: { price: 299, credits: -1 } // -1 for unlimited
│     };
│   
│     const selectedPlan = planDetails[plan];
│     if (!selectedPlan) {
│       return json({ error: "Invalid plan selected" });
│     }
│   
│     try {
│       const charge = await billing.require({
│         plan: plan,
│         amount: selectedPlan.price,
│         currencyCode: "USD",
│         interval: "EVERY_30_DAYS"
│       });
│   
│       // Notify external API about subscription
│       const result = await apiClient.createSubscription(
│         session.shop,
│         plan,
│         charge.id
│       );
│   
│       return json(result);
│     } catch (error) {
│       return json({ error: error.message });
│     }
│   };
│   
│   export default function Billing() {
│     const { shop, subscription, credits } = useLoaderData();
│     const fetcher = useFetcher();
│   
│     const handleSelectPlan = (plan) => {
│       fetcher.submit(
│         { plan },
│         { method: "post" }
│       );
│     };
│   
│     const billingHistory = [
│       {
│         date: '2024-01-15',
│         amount: '$99.00',
│         status: 'Paid',
│         invoice: '#INV-001'
│       },
│       {
│         date: '2023-12-15',
│         amount: '$99.00',
│         status: 'Paid',
│         invoice: '#INV-002'
│       }
│     ];
│   
│     const rows = billingHistory.map(item => [
│       item.date,
│       item.amount,
│       <Badge tone={item.status === 'Paid' ? 'success' : 'warning'}>{item.status}</Badge>,
│       item.invoice
│     ]);
│   
│     return (
│       <Page
│         title="Billing & Plans"
│         breadcrumbs={[{ content: 'Dashboard', url: '/app' }]}
│       >
│         <Layout>
│           {subscription?.status === 'trial' && (
│             <Layout.Section>
│               <Banner
│                 title="Free trial active"
│                 tone="info"
│                 action={{
│                   content: 'View plans',
│                   onAction: () => document.querySelector('#plans-section').scrollIntoView()
│                 }}
│               >
│                 <Text>
│                   Your trial ends on {new Date(subscription.trialEndsAt).toLocaleDateString()}.
│                   Choose a plan to continue using Glam You Up after your trial.
│                 </Text>
│               </Banner>
│             </Layout.Section>
│           )}
│   
│           {subscription?.plan && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <InlineStack align="space-between">
│                     <BlockStack gap="200">
│                       <Text variant="headingMd" as="h2">Current Plan</Text>
│                       <InlineStack gap="200">
│                         <Badge tone="success">{subscription.plan.toUpperCase()}</Badge>
│                         <Text tone="subdued">
│                           Next billing: {new Date(subscription.nextBillingDate).toLocaleDateString()}
│                         </Text>
│                       </InlineStack>
│                     </BlockStack>
│                     <Button plain>Change plan</Button>
│                   </InlineStack>
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│   
│           <Layout.Section>
│             <CreditUsage
│               used={credits?.used || 0}
│               limit={credits?.limit || 0}
│               resetsAt={credits?.resetsAt}
│             />
│           </Layout.Section>
│   
│           <Layout.Section id="plans-section">
│             <BillingPlans
│               currentPlan={subscription?.plan}
│               onSelectPlan={handleSelectPlan}
│               loading={fetcher.state === 'submitting'}
│             />
│           </Layout.Section>
│   
│           {billingHistory.length > 0 && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <Text variant="headingMd" as="h2">Billing History</Text>
│                   <DataTable
│                     columnContentTypes={['text', 'text', 'text', 'text']}
│                     headings={['Date', 'Amount', 'Status', 'Invoice']}
│                     rows={rows}
│                   />
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│         </Layout>
│       </Page>
│     );
│   }
│   ```
│   
├── app.catalog.jsx
│   
│   ```jsx
│   import { json } from "@remix-run/node";
│   import { useLoaderData, useFetcher } from "@remix-run/react";
│   import { Page, Layout, Card, Button, Text, Badge, Banner, DataTable, BlockStack, InlineStack, ProgressBar, SkeletonBodyText } from "@shopify/polaris";
│   import { authenticate } from "../shopify.server";
│   import apiClient from "../lib/apiClient";
│   import { useState, useEffect } from "react";
│   import CatalogSync from "../components/CatalogSync";
│   
│   export const loader = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const shop = session.shop;
│   
│     const catalogStatus = await apiClient.getCatalogStatus(shop);
│   
│     return json({
│       shop,
│       catalog: catalogStatus.data || {
│         productCount: 0,
│         lastSyncAt: null,
│         syncHistory: [],
│         syncStatus: 'idle'
│       }
│     });
│   };
│   
│   export const action = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const formData = await request.formData();
│     const action = formData.get("action");
│   
│     if (action === "sync") {
│       const result = await apiClient.syncCatalog(session.shop);
│       return json(result);
│     }
│   
│     return json({ error: "Invalid action" });
│   };
│   
│   export default function Catalog() {
│     const { shop, catalog } = useLoaderData();
│     const fetcher = useFetcher();
│     const [syncing, setSyncing] = useState(false);
│     const [syncProgress, setSyncProgress] = useState(null);
│   
│     useEffect(() => {
│       if (fetcher.data?.websocket_url) {
│         setSyncing(true);
│         const ws = new WebSocket(fetcher.data.websocket_url);
│         
│         ws.onmessage = (event) => {
│           const data = JSON.parse(event.data);
│           if (data.type === 'progress') {
│             setSyncProgress({
│               percent: (data.processed / data.total) * 100,
│               message: data.message,
│               processed: data.processed,
│               total: data.total
│             });
│           } else if (data.type === 'complete') {
│             setSyncing(false);
│             setSyncProgress(null);
│             ws.close();
│             window.location.reload();
│           } else if (data.type === 'error') {
│             setSyncing(false);
│             setSyncProgress(null);
│             ws.close();
│           }
│         };
│   
│         ws.onerror = () => {
│           setSyncing(false);
│           setSyncProgress(null);
│           ws.close();
│         };
│   
│         return () => ws.close();
│       }
│     }, [fetcher.data]);
│   
│     const handleSync = () => {
│       fetcher.submit(
│         { action: "sync" },
│         { method: "post" }
│       );
│     };
│   
│     const syncHistoryRows = (catalog.syncHistory || []).map(sync => [
│       new Date(sync.date).toLocaleString(),
│       sync.productCount.toString(),
│       `${sync.duration}s`,
│       <Badge tone={sync.status === 'success' ? 'success' : sync.status === 'partial' ? 'warning' : 'critical'}>
│         {sync.status}
│       </Badge>
│     ]);
│   
│     return (
│       <Page
│         title="Catalog Management"
│         breadcrumbs={[{ content: 'Dashboard', url: '/app' }]}
│         primaryAction={{
│           content: 'View Products',
│           url: `https://${shop}/admin/products`,
│           external: true
│         }}
│       >
│         <Layout>
│           {catalog.syncStatus === 'error' && (
│             <Layout.Section>
│               <Banner
│                 title="Last sync failed"
│                 tone="critical"
│                 action={{
│                   content: 'Retry sync',
│                   onAction: handleSync
│                 }}
│               >
│                 <Text>
│                   The previous catalog sync encountered an error. Please retry or contact support if the issue persists.
│                 </Text>
│               </Banner>
│             </Layout.Section>
│           )}
│   
│           <Layout.Section>
│             <CatalogSync
│               lastSync={catalog.lastSyncAt}
│               productCount={catalog.productCount}
│               syncing={syncing}
│               progress={syncProgress}
│               onSync={handleSync}
│             />
│           </Layout.Section>
│   
│           {syncProgress && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <Text variant="headingMd" as="h2">Sync Progress</Text>
│                   <ProgressBar progress={syncProgress.percent} />
│                   <InlineStack align="space-between">
│                     <Text>{syncProgress.message}</Text>
│                     <Text tone="subdued">
│                       {syncProgress.processed} / {syncProgress.total} products
│                     </Text>
│                   </InlineStack>
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│   
│           {!syncing && catalog.productCount > 0 && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <InlineStack align="space-between">
│                     <Text variant="headingMd" as="h2">Catalog Statistics</Text>
│                     <Badge tone="success">{catalog.productCount} Products</Badge>
│                   </InlineStack>
│                   <BlockStack gap="200">
│                     <InlineStack gap="400">
│                       <Text tone="subdued">Last synced:</Text>
│                       <Text>{catalog.lastSyncAt ? new Date(catalog.lastSyncAt).toLocaleString() : 'Never'}</Text>
│                     </InlineStack>
│                     <InlineStack gap="400">
│                       <Text tone="subdued">Sync status:</Text>
│                       <Badge tone={catalog.syncStatus === 'idle' ? 'info' : 'success'}>
│                         {catalog.syncStatus}
│                       </Badge>
│                     </InlineStack>
│                   </BlockStack>
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│   
│           {syncHistoryRows.length > 0 && (
│             <Layout.Section>
│               <Card>
│                 <BlockStack gap="400">
│                   <Text variant="headingMd" as="h2">Sync History</Text>
│                   <DataTable
│                     columnContentTypes={['text', 'numeric', 'text', 'text']}
│                     headings={['Date', 'Products', 'Duration', 'Status']}
│                     rows={syncHistoryRows}
│                   />
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│           )}
│         </Layout>
│       </Page>
│     );
│   }
│   ```
│   
├── app.help.jsx
│   
│   ```jsx
│   import { useLoaderData, useFetcher, useNavigate } from "@remix-run/react";
│   import { 
│     Page, 
│     Layout, 
│     Card, 
│     Text, 
│     Button, 
│     TextField, 
│     Select, 
│     BlockStack, 
│     InlineStack, 
│     Badge, 
│     Banner,
│     Link,
│     List,
│     Collapsible,
│     Icon,
│     CalloutCard,
│     Grid,
│     Box,
│     Divider
│   } from "@shopify/polaris";
│   import { 
│     BookOpenIcon,
│     ChevronDownIcon,
│     ChevronRightIcon
│   } from "@shopify/polaris-icons";
│   import { authenticate } from "../shopify.server";
│   import apiClient from "../lib/apiClient";
│   import { useState, useCallback } from "react";
│   import { LoadingState } from "../components/LoadingState";
│   
│   export const loader = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const shop = session.shop;
│   
│     // Fetch merchant status for context
│     const merchantStatus = await apiClient.getMerchantStatus(shop);
│   
│     return Response.json({
│       shop,
│       subscription: merchantStatus.data || { plan: null, status: 'inactive' },
│       supportEmail: 'support@glamyouup.com',
│       supportPhone: '1-800-GLAM-YOU'
│     });
│   };
│   
│   export const action = async ({ request }) => {
│     const { session } = await authenticate.admin(request);
│     const formData = await request.formData();
│     const action = formData.get("action");
│   
│     if (action === "submit_ticket") {
│       const ticketData = {
│         shop: session.shop,
│         subject: formData.get("subject"),
│         category: formData.get("category"),
│         priority: formData.get("priority"),
│         message: formData.get("message"),
│         email: formData.get("email")
│       };
│   
│       // Submit to external API
│       const result = await apiClient.submitSupportTicket(ticketData);
│       return Response.Response.json(result);
│     }
│   
│     return Response.Response.json({ error: "Invalid action" });
│   };
│   
│   export default function Help() {
│     const { shop, subscription, supportEmail, supportPhone } = useLoaderData();
│     const fetcher = useFetcher();
│     const navigate = useNavigate();
│   
│     // Form state
│     const [subject, setSubject] = useState('');
│     const [category, setCategory] = useState('technical');
│     const [priority, setPriority] = useState('normal');
│     const [message, setMessage] = useState('');
│     const [email, setEmail] = useState('');
│     const [errors, setErrors] = useState({});
│   
│     // FAQ state
│     const [expandedFaq, setExpandedFaq] = useState({});
│   
│     const validateForm = () => {
│       const newErrors = {};
│       if (!subject.trim()) newErrors.subject = 'Subject is required';
│       if (!message.trim()) newErrors.message = 'Message is required';
│       if (!email.trim()) newErrors.email = 'Email is required';
│       else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
│         newErrors.email = 'Please enter a valid email';
│       }
│       
│       setErrors(newErrors);
│       return Object.keys(newErrors).length === 0;
│     };
│   
│     const handleSubmit = () => {
│       if (validateForm()) {
│         fetcher.submit(
│           { 
│             action: "submit_ticket",
│             subject,
│             category,
│             priority,
│             message,
│             email
│           },
│           { method: "post" }
│         );
│       }
│     };
│   
│     const toggleFaq = (id) => {
│       setExpandedFaq(prev => ({
│         ...prev,
│         [id]: !prev[id]
│       }));
│     };
│   
│     const faqs = [
│       {
│         id: 'trial',
│         question: 'How does the 14-day free trial work?',
│         answer: 'Your free trial starts when you activate it and includes 500 credits to test our selfie-based recommendation system. No credit card required. You can upgrade to a paid plan anytime during or after the trial.'
│       },
│       {
│         id: 'credits',
│         question: 'What are credits and how are they used?',
│         answer: 'Credits are consumed when processing selfies and generating recommendations. 1 selfie analysis = 1 credit. Credits reset monthly based on your billing cycle. Unused credits do not roll over.'
│       },
│       {
│         id: 'sync',
│         question: 'Why is my catalog sync failing?',
│         answer: 'Common causes include: missing product images, products without published status, or temporary API issues. Ensure all products have images and are published. Try syncing again or contact support if the issue persists.'
│       },
│       {
│         id: 'billing',
│         question: 'How does billing work?',
│         answer: 'We use Shopify\'s native billing system. Charges appear on your regular Shopify invoice. You can upgrade, downgrade, or cancel anytime. Changes take effect at the next billing cycle.'
│       },
│       {
│         id: 'api',
│         question: 'Can I integrate with my custom storefront?',
│         answer: 'Yes! Enterprise plans include API access for custom integrations. You can use our REST API to process selfies and get recommendations programmatically.'
│       },
│       {
│         id: 'accuracy',
│         question: 'How accurate are the recommendations?',
│         answer: 'Our AI achieves 92% accuracy in size recommendations and 87% in style matching. We continuously improve our models based on return data and user feedback.'
│       },
│       {
│         id: 'privacy',
│         question: 'How is customer data handled?',
│         answer: 'We take privacy seriously. Selfies are processed in real-time and deleted immediately after analysis. We never store customer photos. All data is encrypted in transit and at rest.'
│       },
│       {
│         id: 'returns',
│         question: 'How much can this reduce returns?',
│         answer: 'Merchants typically see 25-40% reduction in size-related returns. Results vary based on product category and implementation. Fashion apparel sees the highest improvement.'
│       }
│     ];
│   
│     const quickLinks = [
│       {
│         title: 'Getting Started Guide',
│         description: 'Step-by-step setup instructions',
│         url: 'https://docs.glamyouup.com/getting-started',
│         icon: BookOpenIcon
│       },
│       {
│         title: 'API Documentation',
│         description: 'For developers and custom integrations',
│         url: 'https://docs.glamyouup.com/api',
│         icon: BookOpenIcon,
│         requiresPlan: 'enterprise'
│       },
│       {
│         title: 'Best Practices',
│         description: 'Optimize your recommendation accuracy',
│         url: 'https://docs.glamyouup.com/best-practices',
│         icon: BookOpenIcon
│       },
│       {
│         title: 'Video Tutorials',
│         description: 'Visual guides for common tasks',
│         url: 'https://glamyouup.com/tutorials',
│         icon: BookOpenIcon
│       }
│     ];
│   
│     // Show success message if ticket was submitted
│     const ticketSubmitted = fetcher.data?.data?.ticket_id;
│   
│     return (
│       <Page
│         title="Help & Support"
│         breadcrumbs={[{ content: 'Dashboard', url: '/app' }]}
│       >
│         <Layout>
│           {ticketSubmitted && (
│             <Layout.Section>
│               <Banner
│                 title="Support ticket submitted successfully"
│                 tone="success"
│                 onDismiss={() => window.location.reload()}
│               >
│                 <Text>
│                   Your ticket #{fetcher.data.data.ticket_id} has been submitted. 
│                   We'll respond within 24 hours to {email}.
│                 </Text>
│               </Banner>
│             </Layout.Section>
│           )}
│   
│           <Layout.Section>
│             <Grid>
│               <Grid.Cell columnSpan={{ xs: 6, sm: 6, md: 4, lg: 4, xl: 4 }}>
│                 <CalloutCard
│                   title="Email Support"
│                   illustration="https://cdn.shopify.com/s/files/1/0583/6465/7734/files/email.svg?v=1701930959"
│                   primaryAction={{
│                     content: 'Send Email',
│                     url: `mailto:${supportEmail}`,
│                     external: true
│                   }}
│                 >
│                   <Text>{supportEmail}</Text>
│                   <Text tone="subdued">Response within 24 hours</Text>
│                 </CalloutCard>
│               </Grid.Cell>
│   
│               <Grid.Cell columnSpan={{ xs: 6, sm: 6, md: 4, lg: 4, xl: 4 }}>
│                 <CalloutCard
│                   title="Priority Support"
│                   illustration="https://cdn.shopify.com/s/files/1/0583/6465/7734/files/phone.svg?v=1701930959"
│                   primaryAction={{
│                     content: subscription?.plan === 'growth' || subscription?.plan === 'enterprise' 
│                       ? 'Call Now' 
│                       : 'Upgrade for Phone Support',
│                     url: subscription?.plan === 'growth' || subscription?.plan === 'enterprise'
│                       ? `tel:${supportPhone.replace(/-/g, '')}`
│                       : '/app/billing',
│                     external: subscription?.plan === 'growth' || subscription?.plan === 'enterprise'
│                   }}
│                 >
│                   <Text>{supportPhone}</Text>
│                   <Text tone="subdued">
│                     {subscription?.plan === 'growth' || subscription?.plan === 'enterprise'
│                       ? 'Mon-Fri 9am-6pm EST'
│                       : 'Available on Growth & Enterprise'}
│                   </Text>
│                 </CalloutCard>
│               </Grid.Cell>
│   
│               <Grid.Cell columnSpan={{ xs: 6, sm: 6, md: 4, lg: 4, xl: 4 }}>
│                 <CalloutCard
│                   title="Live Chat"
│                   illustration="https://cdn.shopify.com/s/files/1/0583/6465/7734/files/chat.svg?v=1701930959"
│                   primaryAction={{
│                     content: subscription?.plan === 'enterprise' 
│                       ? 'Start Chat' 
│                       : 'Enterprise Only',
│                     disabled: subscription?.plan !== 'enterprise',
│                     url: '#'
│                   }}
│                 >
│                   <Text>Instant assistance</Text>
│                   <Text tone="subdued">
│                     {subscription?.plan === 'enterprise'
│                       ? 'Available now'
│                       : 'Upgrade to Enterprise'}
│                   </Text>
│                 </CalloutCard>
│               </Grid.Cell>
│             </Grid>
│           </Layout.Section>
│   
│           <Layout>
│             <Layout.Section oneHalf>
│               <Card>
│                 <BlockStack gap="400">
│                   <Text variant="headingMd" as="h2">Submit Support Ticket</Text>
│                   
│                   <TextField
│                     label="Email"
│                     value={email}
│                     onChange={setEmail}
│                     type="email"
│                     error={errors.email}
│                     placeholder="your@email.com"
│                     autoComplete="email"
│                   />
│   
│                   <TextField
│                     label="Subject"
│                     value={subject}
│                     onChange={setSubject}
│                     error={errors.subject}
│                     placeholder="Brief description of your issue"
│                     autoComplete="off"
│                   />
│   
│                   <Select
│                     label="Category"
│                     options={[
│                       { label: 'Technical Issue', value: 'technical' },
│                       { label: 'Billing Question', value: 'billing' },
│                       { label: 'Catalog Sync', value: 'catalog' },
│                       { label: 'API Integration', value: 'api' },
│                       { label: 'Feature Request', value: 'feature' },
│                       { label: 'Other', value: 'other' }
│                     ]}
│                     value={category}
│                     onChange={setCategory}
│                   />
│   
│                   <Select
│                     label="Priority"
│                     options={[
│                       { label: 'Low - General question', value: 'low' },
│                       { label: 'Normal - Some impact on operations', value: 'normal' },
│                       { label: 'High - Significant impact', value: 'high' },
│                       { label: 'Urgent - Service is down', value: 'urgent' }
│                     ]}
│                     value={priority}
│                     onChange={setPriority}
│                   />
│   
│                   <TextField
│                     label="Message"
│                     value={message}
│                     onChange={setMessage}
│                     multiline={4}
│                     error={errors.message}
│                     placeholder="Please describe your issue in detail. Include any error messages, steps to reproduce, and what you expected to happen."
│                     autoComplete="off"
│                   />
│   
│                   <InlineStack gap="200">
│                     <Button 
│                       primary 
│                       onClick={handleSubmit}
│                       loading={fetcher.state === 'submitting'}
│                     >
│                       Submit Ticket
│                     </Button>
│                     {fetcher.state === 'submitting' && (
│                       <Text tone="subdued">Submitting...</Text>
│                     )}
│                   </InlineStack>
│                 </BlockStack>
│               </Card>
│             </Layout.Section>
│   
│             <Layout.Section oneHalf>
│               <BlockStack gap="400">
│                 <Card>
│                   <BlockStack gap="400">
│                     <Text variant="headingMd" as="h2">Quick Links</Text>
│                     <BlockStack gap="300">
│                       {quickLinks.map((link, index) => (
│                         <Box key={index}>
│                           <InlineStack align="space-between" blockAlign="center">
│                             <BlockStack gap="100">
│                               <InlineStack gap="200" blockAlign="center">
│                                 <Icon source={link.icon} />
│                                 <Link url={link.url} external>
│                                   {link.title}
│                                 </Link>
│                                 {link.requiresPlan && subscription?.plan !== link.requiresPlan && (
│                                   <Badge tone="info">{link.requiresPlan}</Badge>
│                                 )}
│                               </InlineStack>
│                               <Text tone="subdued" variant="bodySm">
│                                 {link.description}
│                               </Text>
│                             </BlockStack>
│                           </InlineStack>
│                           {index < quickLinks.length - 1 && <Box paddingBlockStart="300"><Divider /></Box>}
│                         </Box>
│                       ))}
│                     </BlockStack>
│                   </BlockStack>
│                 </Card>
│   
│                 <Card>
│                   <BlockStack gap="400">
│                     <InlineStack align="space-between">
│                       <Text variant="headingMd" as="h2">System Status</Text>
│                       <Badge tone="success">All Systems Operational</Badge>
│                     </InlineStack>
│                     <BlockStack gap="200">
│                       <InlineStack align="space-between">
│                         <Text>API</Text>
│                         <Badge tone="success">Operational</Badge>
│                       </InlineStack>
│                       <InlineStack align="space-between">
│                         <Text>Catalog Sync</Text>
│                         <Badge tone="success">Operational</Badge>
│                       </InlineStack>
│                       <InlineStack align="space-between">
│                         <Text>Recommendations</Text>
│                         <Badge tone="success">Operational</Badge>
│                       </InlineStack>
│                     </BlockStack>
│                     <Link url="https://status.glamyouup.com" external>
│                       View Status Page
│                     </Link>
│                   </BlockStack>
│                 </Card>
│               </BlockStack>
│             </Layout.Section>
│           </Layout>
│   
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="400">
│                 <Text variant="headingMd" as="h2">Frequently Asked Questions</Text>
│                 <BlockStack gap="300">
│                   {faqs.map((faq) => (
│                     <Box key={faq.id}>
│                       <BlockStack gap="200">
│                         <Button
│                           plain
│                           textAlign="left"
│                           onClick={() => toggleFaq(faq.id)}
│                           ariaExpanded={expandedFaq[faq.id]}
│                           ariaControls={`faq-${faq.id}`}
│                         >
│                           <InlineStack gap="200" blockAlign="center">
│                             <Icon 
│                               source={expandedFaq[faq.id] ? ChevronDownIcon : ChevronRightIcon} 
│                             />
│                             <Text variant="bodyMd" fontWeight="semibold">
│                               {faq.question}
│                             </Text>
│                           </InlineStack>
│                         </Button>
│                         <Collapsible
│                           open={expandedFaq[faq.id]}
│                           id={`faq-${faq.id}`}
│                           transition={{ duration: '200ms', timingFunction: 'ease' }}
│                         >
│                           <Box paddingInlineStart="600">
│                             <Text tone="subdued">{faq.answer}</Text>
│                           </Box>
│                         </Collapsible>
│                       </BlockStack>
│                       <Box paddingBlockStart="300">
│                         <Divider />
│                       </Box>
│                     </Box>
│                   ))}
│                 </BlockStack>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│   
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="400">
│                 <Text variant="headingMd" as="h2">Troubleshooting Tips</Text>
│                 <List>
│                   <List.Item>
│                     <Text fontWeight="semibold">Catalog not syncing?</Text> Ensure all products have images and are set to 'Active' status in your Shopify admin.
│                   </List.Item>
│                   <List.Item>
│                     <Text fontWeight="semibold">Credits not resetting?</Text> Credits reset based on your billing cycle date, not calendar month.
│                   </List.Item>
│                   <List.Item>
│                     <Text fontWeight="semibold">API rate limits?</Text> Enterprise plans have higher rate limits. Check headers for X-RateLimit-Remaining.
│                   </List.Item>
│                   <List.Item>
│                     <Text fontWeight="semibold">Recommendations not showing?</Text> Verify the Glam You Up widget is installed on your product pages.
│                   </List.Item>
│                   <List.Item>
│                     <Text fontWeight="semibold">Billing issues?</Text> Billing is managed through Shopify. Check your Shopify admin → Settings → Billing.
│                   </List.Item>
│                 </List>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│         </Layout>
│       </Page>
│     );
│   }
│   
│   export function ErrorBoundary({ error }) {
│     return (
│       <Page title="Help & Support">
│         <Layout>
│           <Layout.Section>
│             <Card>
│               <BlockStack gap="300">
│                 <Text variant="headingMd" as="h2">Unable to load support page</Text>
│                 <Text tone="critical">{error.message}</Text>
│                 <Button url="/app" primary>
│                   Return to dashboard
│                 </Button>
│               </BlockStack>
│             </Card>
│           </Layout.Section>
│         </Layout>
│       </Page>
│     );
│   }
│   ```
│   
├── app.jsx
│   
│   ```jsx
│   import { Link, Outlet, useLoaderData, useRouteError } from "@remix-run/react";
│   import { boundary } from "@shopify/shopify-app-remix/server";
│   import { AppProvider } from "@shopify/shopify-app-remix/react";
│   import { NavMenu } from "@shopify/app-bridge-react";
│   import polarisStyles from "@shopify/polaris/build/esm/styles.css?url";
│   import { authenticate } from "../shopify.server";
│   
│   export const links = () => [{ rel: "stylesheet", href: polarisStyles }];
│   
│   export const loader = async ({ request }) => {
│     await authenticate.admin(request);
│   
│     return { apiKey: process.env.SHOPIFY_API_KEY || "" };
│   };
│   
│   export default function App() {
│     const { apiKey } = useLoaderData();
│   
│     return (
│       <AppProvider isEmbeddedApp apiKey={apiKey}>
│         <NavMenu>
│           <Link to="/app" rel="home">
│             Home
│           </Link>
│           <Link to="/app/billing">Billing page</Link>
│           <Link to="/app/catalog">Catalog</Link>
│           <Link to="/app/analytics">Analytics</Link>
│           <Link to="/app/help">Help</Link>
│         </NavMenu>
│         <Outlet />
│       </AppProvider>
│     );
│   }
│   
│   // Shopify needs Remix to catch some thrown responses, so that their headers are included in the response.
│   export function ErrorBoundary() {
│     return boundary.error(useRouteError());
│   }
│   
│   export const headers = (headersArgs) => {
│     return boundary.headers(headersArgs);
│   };
│   ```
│   
├── auth.$.jsx
│   
│   ```jsx
│   import { authenticate } from "../shopify.server";
│   
│   export const loader = async ({ request }) => {
│     await authenticate.admin(request);
│   
│     return null;
│   };
│   ```
│   
├── match.analysis.jsx
│   
│   ```jsx
│   // import { json } from "@remix-run/node";
│   // import { getProductFromImageId } from "../models/gyuProducts.store";
│   // import { ai_server_match_analysis } from "../constant";
│   // import { isValidBilling } from "../utils/billingConfig";
│   // import { fetchWithTimeout } from "../utils/functions";
│   // /**
│   //  * This route handles requests from the storefront to the Remix server,
│   //  * performing an AI-based product matching and analysis based on provided data.
│   //  * 
│   //  * Expected Request Payload:
│   //  * @request matchData - An object containing:
│   //  *   - shop_id (string): ID of the Shopify store
│   //  *   - image_id (string): ID of the product image
│   //  *   - product_id (string): ID of the product
│   //  */
│   // export const action = async ({ request, params }) => {
│   //   try {
│   //     const form = await request.formData();
│   //     const matchData = JSON.parse(form.get("matchData"));
│   //     // Check billing status for the shop to ensure they have an active subscription
│   //     const isValid = await isValidBilling(String(matchData.shop_id));
│   //     if (!isValid) {
│   //       return json({ error: "billing failed" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   //     for (let key in matchData) {
│   //       if (typeof matchData[key] === 'number') {
│   //         matchData[key] = matchData[key].toString();
│   //       }
│   //     }
│   
│   //     // Retrieve the product associated with the given image ID and shop
│   //     const matchedProduct = await getProductFromImageId(matchData);
│   //     if (matchedProduct == null) {
│   //       return json({ error: "no registered" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   
│   //     console.log("product sort request body -------", JSON.stringify({
│   //       ...matchData,
│   //       variant_id: matchedProduct.variant_id
│   //     }));
│   
│   //     const options = {
│   //       method: "POST",
│   //       headers: {
│   //         "Content-Type": "application/json",
│   //         "apikey": process.env.API_KEY
│   //       },
│   //       body: JSON.stringify({
│   //         ...matchData,
│   //         variant_id: matchedProduct.variant_id
│   //       }),
│   //     };
│   
│   //     let responseData, response;
│   
│   //     try {
│   //       response = await fetchWithTimeout(ai_server_match_analysis, options, 15000); // 5000 ms timeout
│   //       if (!response.ok) {
│   //         throw new Error(`Server responded with status ${response.status}`);
│   //       }
│   //       responseData = await response.json();
│   //     } catch (error) {
│   //       if (error.message === 'Fetch request timed out') {
│   //         return json({ error: "timeout error" }, {
│   //           headers: {
│   //             "Access-Control-Allow-Origin": "*",
│   //           },
│   //         });
│   //       } else {
│   //         return json({ error: "ai response failed" }, {
│   //           headers: {
│   //             "Access-Control-Allow-Origin": "*",
│   //           },
│   //         });
│   //       }      
│   //     }
│   
│   //     // If AI response is received, format and return the data to the storefront
│   //     if (responseData) {
│   //       console.log("product match response -------", JSON.stringify({
│   //         responseData
│   //       }));
│   //       return json({
│   //         score_color: (responseData.score_color) / 20,
│   //         score_morph: (responseData.score_morph) / 20,
│   //         score_overall: (responseData.score_overall) / 20,
│   //         recommendation: responseData.recommendation,
│   //         description: responseData.description,
│   //       }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   //   } catch (error) {
│   //     console.error("Error parsing multipart form data:", error);
│   //     return json({ error: "request failed" }, {
│   //       headers: {
│   //         "Access-Control-Allow-Origin": "*",
│   //       },
│   //     });
│   //   }
│   // }
│   ```
│   
├── selfie.register.jsx
│   
│   ```jsx
│   // import { json, unstable_createMemoryUploadHandler, unstable_parseMultipartFormData } from "@remix-run/node";
│   // import { getDownloadURL, getStorage, ref, uploadBytes, uploadString } from "firebase/storage";
│   // import { ai_server_selfie_register } from "../constant";
│   // import { isValidBilling } from "../utils/billingConfig";
│   // import firebase from "../utils/firebase";
│   // import { fetchWithTimeout } from "../utils/functions";
│   
│   // /**
│   //  * Uploads a file or a captured image URL to Firebase Storage and returns the download URL.
│   //  * 
│   //  * @param {File | null} file - The file to be uploaded (if available).
│   //  * @param {string} selfie_id - A unique identifier for the storage reference (e.g., user ID or selfie ID).
│   //  * @param {string} capturedURL - A data URL string representing the captured image, used if file is not provided.
│   //  * @returns {Promise<string>} - A promise that resolves to the download URL of the uploaded file.
│   //  * 
│   //  */
│   // async function uploadFile(file, selfie_id, capturedURL) {
│   //   const storage = getStorage(firebase);
│   //   const storageRef = ref(storage, selfie_id);
│   //   let fileRef = null;
│   //   if (file)
│   //     fileRef = await uploadBytes(storageRef, file);
│   //   else
│   //     fileRef = await uploadString(storageRef, capturedURL, 'data_url');
│   //   const downloadURL = await getDownloadURL(fileRef.ref);
│   //   return downloadURL;
│   // }
│   
│   // /**
│   //  * Processes a request from the storefront to the Remix server to upload a selfie, validate billing, and register the selfie via an AI server.
│   //  * 
│   //  * @param {Object} request - Incoming request containing multipart form data (selfie_id, shop_id, jpegFile, capturedURL).
│   //  * @param {Object} params - Additional parameters from the route.
│   //  * 
│   //  * @returns {Response} - JSON response with either the registered selfie details or an error status.
│   //  */
│   // export const action = async ({ request, params }) => {
│   //   const uploadHandler = unstable_createMemoryUploadHandler({
│   //     maxPartSize: 10000000, // Maximum file size of 10 MB
│   //   });
│   //   try {
│   //     const formData = await unstable_parseMultipartFormData(
│   //       request,
│   //       uploadHandler // <-- we'll look at this deeper next
│   //     );
│   //     let selfie_url = '';
│   //     let selfie;
│   //     const selfie_id = formData.get("selfie_id");
│   //     const shop_id = formData.get("shop_id");
│   //     const avatar = formData.get("jpegFile");
│   //     const isValid = await isValidBilling(shop_id);
│   
│   //     // Validate billing for the shop
│   //     if (!isValid) {
│   //       return json({ error: "billing failed" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   
│   //     // Upload selfie image (either jpegFile or capturedURL)
│   //     if (avatar)
│   //       selfie_url = await uploadFile(avatar, selfie_id, '');
│   //     else {
│   //       const capturedURL = formData.get("capturedURL");
│   //       selfie_url = await uploadFile(null, selfie_id, capturedURL);
│   //     }
│   
│   //     const options = {
│   //       method: "POST",
│   //       headers: {
│   //         "Content-Type": "application/json",
│   //         "apikey": process.env.API_KEY
│   //       },
│   //       body: JSON.stringify({
│   //         selfie_id,
│   //         selfie_url,
│   //         shop_id
│   //       }),
│   //     };
│   
│   //     console.log({selfie: options});
│   
│   //     let responseData, response;  
│   //     try {
│   //       response = await fetchWithTimeout(ai_server_selfie_register, options, 20000); // 5000 ms timeout
│   //       if (!response.ok) {
│   //         throw new Error(`Server responded with status ${response.status}`);
│   //       }
│   //       responseData = await response.json();
│   //     } catch (error) {
│   //       if (error.message === 'Fetch request timed out') {
│   //         return json({ error: "timeout error" }, {
│   //           headers: {
│   //             "Access-Control-Allow-Origin": "*",
│   //           },
│   //         });
│   //       } else {
│   //         return json({ error: "ai response failed" }, {
│   //           headers: {
│   //             "Access-Control-Allow-Origin": "*",
│   //           },
│   //         });
│   //       }      
│   //     }
│   //     console.log("responseData error: ", {responseData});
│   //     if (responseData) {
│   //       if (responseData.status == "fail") {
│   //         return json({ error: responseData.error, fail: "fail" }, {
│   //           headers: {
│   //             "Access-Control-Allow-Origin": "*",
│   //           },
│   //         });
│   //       } else {
│   //         selfie = {
│   //           url: selfie_url,
│   //           url_image_mesh: responseData.url_image_mesh,
│   //           url_image_colorbars: responseData.url_image_colorbars,
│   //           description: responseData.description,
│   //           recommendation: responseData.recommendation
│   //         };
│   //       }      
│   //     } else {
│   //       return json({ error: "ai response failed" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   
│   //     return json({ selfie }, {
│   //       headers: {
│   //         "Access-Control-Allow-Origin": "*",
│   //       },
│   //     });
│   //   } catch (error) {
│   //     console.error("Error parsing multipart form data:", error);
│   //     return json({ error: "request failed" }, {
│   //       headers: {
│   //         "Access-Control-Allow-Origin": "*",
│   //       },
│   //     });
│   //   }
│   // }
│   ```
│   
├── selfie.remove.jsx
│   
│   ```jsx
│   // import { json } from "@remix-run/node";
│   // import { deleteObject, getStorage, ref } from "firebase/storage";
│   // import firebase from "../utils/firebase";
│   
│   // /**
│   //  * Deletes a file from Firebase Storage given its URL.
│   //  * 
│   //  * @param {string} fileUrl - The URL of the file to be deleted.
│   //  * @returns {void}
│   //  */
│   // async function deleteFileByUrl(fileUrl) {
│   //   const storage = getStorage(firebase);
│   //   const fileRef = ref(storage, fileUrl);
│   
│   //   try {
│   //     await deleteObject(fileRef);
│   //     console.log('File deleted successfully');
│   //   } catch (error) {
│   //     console.error('Error deleting file:', error);
│   //   }
│   // }
│   
│   // /**
│   //  * Handles the request from the storefront to the Remix server for deleting a selfie file.
│   //  * @request Multipart form data containing:
│   //  * - `selfieUrl` (string): Firestore URL of the selfie image to delete.
│   //  * 
│   //  * @returns JSON response:
│   //  * - `{ ok: "ok" }` with status 200 and CORS headers on success.
│   //  * - `{ status: 411 }` on failure, with CORS headers.
│   //  */
│   // export const action = async ({ request, params }) => {
│   //   try {
│   //     const form = await request.formData();
│   //     const selfieUrl = form.get("selfieUrl");   
│   //     await deleteFileByUrl(selfieUrl);
│   //     return json({ ok: "ok" }, {
│   //       headers: {
│   //         "Access-Control-Allow-Origin": "*",
│   //       },
│   //     });    
│   //   } catch (error) {
│   //     return json({ error: "request failed" }, {
│   //       headers: {
│   //         "Access-Control-Allow-Origin": "*",
│   //       },
│   //     });
│   //   }
│   // }
│   ```
│   
├── sort.analysis.jsx
│   
│   ```jsx
│   // import { json } from "@remix-run/node";
│   // import { ai_server_shop_sort } from "../constant";
│   // import { isValidBilling } from "../utils/billingConfig";
│   // import { getDistinctProducts } from "../utils/functions";
│   // import { getRegistered } from "../models/gyuProducts.store";
│   
│   // /**
│   //  * Processes product sorting requests from the storefront to the Remix server.
│   //  * 
│   //  * @request Multipart form data with:
│   //  * - `selfie_id` (string): The ID for the selfie image.
│   //  * - `shop_id` (string): The shop's unique ID.
│   //  * - `gyu_products` (stringified JSON): Array of products to check against the database.
│   //  * 
│   //  * @returns JSON response:
│   //  * - `{ sorted_products }` with sorted products and CORS headers if sorting succeeds.
│   //  * - `{ success: "no update" }` if no update is needed.
│   //  * - `{ error: "billing failed" }` with CORS headers if billing is invalid.
│   //  * - `{ status: 413 }` if the AI server request fails.
│   //  * - `{ status: 411 }` if any other error occurs.
│   //  */
│   // export const action = async ({ request, params }) => {
│   //   try {
│   //     const form = await request.formData();
│   //     const isValid = await isValidBilling(String(form.get("shop_id")));
│   //     const selfie_id = form.get("selfie_id");
│   //     const shop_id = form.get("shop_id");   
│   //     if (!isValid) {
│   //       return json({ error: "billing failed" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   //     // Compares the firebase products registered in the 'Analyzed' status with the cache products obtained from the ai server.
│   //     const gyuProducts = JSON.parse(form.get("gyu_products"));    
│   //     const variants = await getRegistered(shop_id);
│   //     let fDifferent = false;
│   //     const cntGyuProducts = getDistinctProducts(gyuProducts).length;
│   //     const cntFireProducts = getDistinctProducts(variants).length;
│   //     if (cntFireProducts == 0) {
│   //       return json({ success: "no registered" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   //     // compare the amount of products
│   //     if (cntGyuProducts != cntFireProducts) fDifferent = true;
│   //     // compare the each product
│   //     else {
│   //       for (const gyuProduct of gyuProducts) {
│   //         const isRegistered = variants.find(variant => (variant.product_id == gyuProduct.product_id && variant.variant_id == gyuProduct.variant_id));
│   //         if (!isRegistered) {
│   //           fDifferent = true;
│   //           break;
│   //         }
│   //       }
│   //     }
│   //     if (!fDifferent) {
│   //       return json({ success: "no update" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   //     let response = await fetch(
│   //       ai_server_shop_sort,
│   //       {
│   //         method: "POST",
│   //         headers: {
│   //           "Content-Type": "application/json",
│   //           "apikey": process.env.API_KEY
│   //         },
│   //         body: JSON.stringify({
│   //           selfie_id,
│   //           shop_id
│   //         }),
│   //       },
│   //     );
│   //     let responseData = await response.json();
│   //     console.log({sort: responseData});
│   //     if (responseData) {
│   //       const sorted_products = responseData.sorted_products;
│   //       if (sorted_products.length == 0) {
│   //         return json({ success: "no registered" }, {
│   //           headers: {
│   //             "Access-Control-Allow-Origin": "*",
│   //           },
│   //         });
│   //       }
│   //       return json({ sorted_products }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     } else {
│   //       return json({ error: "ai response failed" }, {
│   //         headers: {
│   //           "Access-Control-Allow-Origin": "*",
│   //         },
│   //       });
│   //     }
│   //   } catch (error) {
│   //     return json({ error: "request failed" }, {
│   //       headers: {
│   //         "Access-Control-Allow-Origin": "*",
│   //       },
│   //     });
│   //   }
│   // }
│   ```
│   
└── webhooks.relay.jsx
    
    ```jsx
    // apps/shopify-bff/app/routes/webhooks.relay.jsx
    import { authenticate } from "../shopify.server";
    import apiClient from "../lib/apiClient";
    
    export const action = async ({ request }) => {
      const { topic, shop, payload, webhookId } = await authenticate.webhook(request);
    
      // Fire-and-forget (don’t await)
      void apiClient.relayShopifyWebhook({
        topic,
        shop,
        payload,
        webhookId,
      });
    
      return new Response(JSON.stringify({ relayed: true }), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    };
    ```
    
db.server.js

```js
import { PrismaClient } from "@prisma/client";

if (process.env.NODE_ENV !== "production") {
  if (!global.prismaGlobal) {
    global.prismaGlobal = new PrismaClient();
  }
}

const prisma = global.prismaGlobal ?? new PrismaClient();

export default prisma;
```

entry.server.jsx

```jsx
import { PassThrough } from "stream";
import { renderToPipeableStream } from "react-dom/server";
import { RemixServer } from "@remix-run/react";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { isbot } from "isbot";
import { addDocumentResponseHeaders } from "./shopify.server";

export const streamTimeout = 5000;

export default async function handleRequest(
  request,
  responseStatusCode,
  responseHeaders,
  remixContext,
) {
  addDocumentResponseHeaders(request, responseHeaders);
  const userAgent = request.headers.get("user-agent");
  const callbackName = isbot(userAgent ?? "") ? "onAllReady" : "onShellReady";

  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer context={remixContext} url={request.url} />,
      {
        [callbackName]: () => {
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            }),
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          console.error(error);
        },
      },
    );

    // Automatically timeout the React renderer after 6 seconds, which ensures
    // React has enough time to flush down the rejected boundary contents
    setTimeout(abort, streamTimeout + 1000);
  });
}
```

query.js

```js
export const GET_PRODUCTS_QUERY = `#graphql
query products($after: String) {
  products(first: 250, after: $after) {
    edges {
      node {
        id
        title
        featuredImage {
          id
          originalSrc
        }
        variants(first: 250) {
          edges {
            node {
              id
              image {
                id
                originalSrc
              }
            }
          }
        }
      }
      cursor
    }
    pageInfo {
      hasNextPage
    }
  }
}`;

export const GET_SHOP_INFO = `#graphql
  query getShopInfo {
    shop {
      id
      name
      url
      email
      currencyCode
      primaryDomain {
        url
        host
      }
      plan {
        displayName
        partnerDevelopment
        shopifyPlus
      }
      myshopifyDomain
      contactEmail
      billingAddress {
        country
        countryCodeV2
        city
        province
        provinceCode
        zip
      }
    }
    }
`;

export const GET_A_METAOBJECT_BY_HANDLE = `
{
  metaobjectByHandle(handle: {
    type: "$app:gyu_status",
    handle: "gyu_billing_status"
  }) {
    displayName
    id
    handle
  }
}`;


export const GET_A_METAOBJECTDEFINITION_BY_TYPE = `
{
  metaobjectDefinitionByType(type: "$app:gyu_status") {
    id
  }
}`;


export const CREATE_NEW_METAOBJECT_DEFINITION = `#graphql
mutation metaobjectDefinitionCreate($definition: MetaobjectDefinitionCreateInput!) {
  metaobjectDefinitionCreate(definition: $definition) {
    metaobjectDefinition {
      id
      name
      type
    }
    userErrors {
      field
      message
    }
  }
}`;

export const CREATE_NEW_METAOBJECT = `#graphql
mutation metaobjectCreate($metaobject: MetaobjectCreateInput!) {
  metaobjectCreate(metaobject: $metaobject) {
    metaobject {
      id
      type
    }
    userErrors {
      field
      message
    }
  }
}`;

export const DELETE_A_METAOBJECT_DEFINITION_BY_ID = `#graphql
mutation metaobjectDefinitionDelete($id: ID!) {
  metaobjectDefinitionDelete(id: $id) {
    deletedId
    userErrors {
      field
      message
    }
  }
}`;

export const CREATE_APP_SUBSCRIPTION = `#graphql
mutation AppSubscriptionCreate($name: String!, $lineItems: [AppSubscriptionLineItemInput!]!, $returnUrl: URL!, $test: Boolean!, $trialDays: Int!) {
  appSubscriptionCreate(name: $name, returnUrl: $returnUrl, lineItems: $lineItems, test: $test, trialDays: $trialDays) {
    userErrors {
      field
      message
    }
    appSubscription {
      id
      lineItems {
        id
        plan {
          pricingDetails
          __typename
        }
      }
      currentPeriodEnd
      status
    }
    confirmationUrl
  }
}`;

export const CREATE_APP_ONE_TIME_SUBSCRIPTION = `#graphql
mutation appPurchaseOneTimeCreate($name: String!, $returnUrl: URL!, $price: MoneyInput!, $test: Boolean!) {
  appPurchaseOneTimeCreate(name: $name, returnUrl: $returnUrl, price: $price, test: $test) {
    userErrors {
      field
      message
    }
    appPurchaseOneTime {
      createdAt
      id
      name
      price {
        amount
        currencyCode
      }
      status
      test
    }
    confirmationUrl
  }
}`;

export const CHECK_FOR_SUBSCRIPTION = `#graphql
{
  currentAppInstallation {
    activeSubscriptions {
    id
    lineItems {
      id
      plan {
        pricingDetails {
          ... on AppUsagePricing {
          __typename
          }
        }
      }
    }
    status
    currentPeriodEnd
    name
    }
  }
}`;

export const CANCEL_SUBSCRIPTION = `#graphql
mutation AppSubscriptionCancel($id: ID!) {
  appSubscriptionCancel(id: $id) {
    userErrors {
      field
      message
    }
    appSubscription {
      id
      status
    }
  }
}`;

export function GET_ORDERS_COUNT(startDate, endDate) {
  return `#graphql
  {
    orders(query: "created_at:>='${startDate}' AND created_at:<'${endDate}'") {
      nodes {
        id
      }
    }
  }`;
}
```

root.jsx

```jsx
import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export default function App() {
  return (
    <html>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <link rel="preconnect" href="https://cdn.shopify.com/" />
        <link
          rel="stylesheet"
          href="https://cdn.shopify.com/static/fonts/inter/v4/styles.css"
        />
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```

routes.js

```js
import { flatRoutes } from "@remix-run/fs-routes";

export default flatRoutes();
```

shopify.server.js

```js
import "@shopify/shopify-app-remix/adapters/node";
import {
  ApiVersion,
  AppDistribution,
  shopifyApp,
} from "@shopify/shopify-app-remix/server";
import { PrismaSessionStorage } from "@shopify/shopify-app-session-storage-prisma";
import prisma from "./db.server";
import apiClient from "./lib/apiClient";
import { GET_SHOP_INFO } from "./query";

const shopify = shopifyApp({
  apiKey: process.env.SHOPIFY_API_KEY,
  apiSecretKey: process.env.SHOPIFY_API_SECRET || "",
  apiVersion: ApiVersion.January25,
  scopes: process.env.SCOPES?.split(","),
  appUrl: process.env.SHOPIFY_APP_URL || "",
  authPathPrefix: "/auth",
  sessionStorage: new PrismaSessionStorage(prisma),
  distribution: AppDistribution.AppStore,
  future: {
    unstable_newEmbeddedAuthStrategy: true,
    removeRest: true,
  },
  ...(process.env.SHOP_CUSTOM_DOMAIN
    ? { customShopDomains: [process.env.SHOP_CUSTOM_DOMAIN] }
    : {}),
  hooks: {
    afterAuth: async ({ admin, session, request }) => {
      console.log("[SHOPIFY] After Auth:", session);

      try {
        // Sync the shop with the external API after authentication
        console.log("[SHOPIFY] Syncing shop after authentication...");

        // Execute GraphQL query using the admin client
        const shopInfoResponse = await admin.graphql(GET_SHOP_INFO);
        const shopData = await shopInfoResponse.json();

        console.log("[SHOPIFY] Shop DATA:========", JSON.stringify(shopData, null, 2));

        const syncData = {
          shop_gid: shopData.data.shop.id,
          name: shopData.data.shop.name,
          url: shopData.data.shop.url,
          email: shopData.data.shop.email,
          currencyCode: shopData.data.shop.currencyCode,   
          primaryDomainDomain: shopData.data.shop.primaryDomain?.domain,
          primaryDomainHost: shopData.data.shop.primaryDomain?.host,
          plan: shopData.data.shop.plan?.displayName,
          myshopifyDomain: shopData.data.shop.myshopifyDomain,
          contactEmail: shopData.data.shop.contactEmail,
          country: shopData.data.shop.billingAddress?.countryCodeV2,
          accessToken: session.accessToken,
          scope: session.scope,
        };

        
        const syncResponse = await apiClient.syncShop(syncData);
        console.log("[SHOPIFY] Sync Shop Response:", syncResponse);
        if (syncResponse.error) {
          console.error("[SHOPIFY] Sync Shop Error:", syncResponse.error);
        } else {
          console.log("[SHOPIFY] Shop synced successfully:", syncResponse.data);
        }
      } catch (error) {
        console.error("[SHOPIFY] Error in afterAuth hook:", error);
        throw error;
      }
    },
  },
});

export default shopify;
export const apiVersion = ApiVersion.January25;
export const addDocumentResponseHeaders = shopify.addDocumentResponseHeaders;
export const authenticate = shopify.authenticate;
export const unauthenticated = shopify.unauthenticated;
export const login = shopify.login;
export const registerWebhooks = shopify.registerWebhooks;
export const sessionStorage = shopify.sessionStorage;
```


================================================================================
Output includes file contents
================================================================================